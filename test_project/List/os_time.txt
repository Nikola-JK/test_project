; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_time.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_time.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\os_time.crf Source\uCOS-II\Source\os_time.c]
                          THUMB

                          AREA ||i.OSTimeDly||, CODE, READONLY, ALIGN=2

                  OSTimeDly PROC
;;;43     
;;;44     void  OSTimeDly (INT16U ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;45     {
000002  4605              MOV      r5,r0
;;;46         INT8U      y;
;;;47     #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;48         OS_CPU_SR  cpu_sr = 0;
000004  2600              MOVS     r6,#0
;;;49     #endif
;;;50     
;;;51     
;;;52     
;;;53         if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
000006  4816              LDR      r0,|L1.96|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  2800              CMP      r0,#0
00000c  dd00              BLE      |L1.16|
                  |L1.14|
;;;54             return;
;;;55         }
;;;56         if (ticks > 0) {                             /* 0 means no delay!                                  */
;;;57             OS_ENTER_CRITICAL();
;;;58             y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
;;;59             OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
;;;60             if (OSRdyTbl[y] == 0) {
;;;61                 OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
;;;62             }
;;;63             OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
;;;64             OS_EXIT_CRITICAL();
;;;65             OS_Sched();                              /* Find next task to run!                             */
;;;66         }
;;;67     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  2d00              CMP      r5,#0                 ;56
000012  dd23              BLE      |L1.92|
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  4606              MOV      r6,r0                 ;57
00001a  4812              LDR      r0,|L1.100|
00001c  6800              LDR      r0,[r0,#0]            ;58  ; OSTCBCur
00001e  f8904030          LDRB     r4,[r0,#0x30]         ;58
000022  4811              LDR      r0,|L1.104|
000024  5d00              LDRB     r0,[r0,r4]            ;59
000026  490f              LDR      r1,|L1.100|
000028  6809              LDR      r1,[r1,#0]            ;59  ; OSTCBCur
00002a  f8911031          LDRB     r1,[r1,#0x31]         ;59
00002e  4388              BICS     r0,r0,r1              ;59
000030  490d              LDR      r1,|L1.104|
000032  5508              STRB     r0,[r1,r4]            ;59
000034  4608              MOV      r0,r1                 ;60
000036  5d00              LDRB     r0,[r0,r4]            ;60
000038  b940              CBNZ     r0,|L1.76|
00003a  480a              LDR      r0,|L1.100|
00003c  6800              LDR      r0,[r0,#0]            ;61  ; OSTCBCur
00003e  f8901032          LDRB     r1,[r0,#0x32]         ;61
000042  480a              LDR      r0,|L1.108|
000044  7800              LDRB     r0,[r0,#0]            ;61  ; OSRdyGrp
000046  4388              BICS     r0,r0,r1              ;61
000048  4908              LDR      r1,|L1.108|
00004a  7008              STRB     r0,[r1,#0]            ;61
                  |L1.76|
00004c  4805              LDR      r0,|L1.100|
00004e  6800              LDR      r0,[r0,#0]            ;63  ; OSTCBCur
000050  8545              STRH     r5,[r0,#0x2a]         ;63
000052  4630              MOV      r0,r6                 ;64
000054  f7fffffe          BL       OS_CPU_SR_Restore
000058  f7fffffe          BL       OS_Sched
                  |L1.92|
00005c  bf00              NOP      
00005e  e7d6              B        |L1.14|
;;;68     /*$PAGE*/
                          ENDP

                  |L1.96|
                          DCD      OSIntNesting
                  |L1.100|
                          DCD      OSTCBCur
                  |L1.104|
                          DCD      OSRdyTbl
                  |L1.108|
                          DCD      OSRdyGrp

                          AREA ||i.OSTimeDlyHMSM||, CODE, READONLY, ALIGN=2

                  OSTimeDlyHMSM PROC
;;;95     #if OS_TIME_DLY_HMSM_EN > 0
;;;96     INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;97     {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;98         INT32U ticks;
;;;99         INT16U loops;
;;;100    
;;;101    
;;;102        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00000c  4824              LDR      r0,|L2.160|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  2800              CMP      r0,#0
000012  dd02              BLE      |L2.26|
;;;103            return (OS_ERR_TIME_DLY_ISR);
000014  2055              MOVS     r0,#0x55
                  |L2.22|
;;;104        }
;;;105    #if OS_ARG_CHK_EN > 0
;;;106        if (hours == 0) {
;;;107            if (minutes == 0) {
;;;108                if (seconds == 0) {
;;;109                    if (ms == 0) {
;;;110                        return (OS_ERR_TIME_ZERO_DLY);
;;;111                    }
;;;112                }
;;;113            }
;;;114        }
;;;115        if (minutes > 59) {
;;;116            return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
;;;117        }
;;;118        if (seconds > 59) {
;;;119            return (OS_ERR_TIME_INVALID_SECONDS);
;;;120        }
;;;121        if (ms > 999) {
;;;122            return (OS_ERR_TIME_INVALID_MS);
;;;123        }
;;;124    #endif
;;;125        /* Compute the total number of clock ticks required.. */
;;;126        /* .. (rounded to the nearest tick)                   */
;;;127        ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
;;;128                + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
;;;129        loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
;;;130        ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
;;;131        OSTimeDly((INT16U)ticks);
;;;132        while (loops > 0) {
;;;133            OSTimeDly((INT16U)32768u);
;;;134            OSTimeDly((INT16U)32768u);
;;;135            loops--;
;;;136        }
;;;137        return (OS_ERR_NONE);
;;;138    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L2.26|
00001a  f1b80f00          CMP      r8,#0                 ;106
00001e  d104              BNE      |L2.42|
000020  b91d              CBNZ     r5,|L2.42|
000022  b916              CBNZ     r6,|L2.42|
000024  b90c              CBNZ     r4,|L2.42|
000026  2054              MOVS     r0,#0x54              ;110
000028  e7f5              B        |L2.22|
                  |L2.42|
00002a  2d3b              CMP      r5,#0x3b              ;115
00002c  dd01              BLE      |L2.50|
00002e  2051              MOVS     r0,#0x51              ;116
000030  e7f1              B        |L2.22|
                  |L2.50|
000032  2e3b              CMP      r6,#0x3b              ;118
000034  dd01              BLE      |L2.58|
000036  2052              MOVS     r0,#0x52              ;119
000038  e7ed              B        |L2.22|
                  |L2.58|
00003a  f5b47f7a          CMP      r4,#0x3e8             ;121
00003e  db01              BLT      |L2.68|
000040  2053              MOVS     r0,#0x53              ;122
000042  e7e8              B        |L2.22|
                  |L2.68|
000044  f44f707a          MOV      r0,#0x3e8             ;127
000048  4360              MULS     r0,r4,r0              ;127
00004a  f44f717a          MOV      r1,#0x3e8             ;127
00004e  fbb0f1f1          UDIV     r1,r0,r1              ;127
000052  f44f6061          MOV      r0,#0xe10             ;127
000056  fb08f000          MUL      r0,r8,r0              ;127
00005a  ebc51205          RSB      r2,r5,r5,LSL #4       ;127
00005e  eb000082          ADD      r0,r0,r2,LSL #2       ;127
000062  4430              ADD      r0,r0,r6              ;127
000064  eb000240          ADD      r2,r0,r0,LSL #1       ;127
000068  ebc210c0          RSB      r0,r2,r0,LSL #7       ;127
00006c  eb0107c0          ADD      r7,r1,r0,LSL #3       ;127
000070  ea4f4917          LSR      r9,r7,#16             ;129
000074  b2bf              UXTH     r7,r7                 ;130
000076  4638              MOV      r0,r7                 ;131
000078  f7fffffe          BL       OSTimeDly
00007c  e00b              B        |L2.150|
                  |L2.126|
00007e  f44f4000          MOV      r0,#0x8000            ;133
000082  f7fffffe          BL       OSTimeDly
000086  f44f4000          MOV      r0,#0x8000            ;134
00008a  f7fffffe          BL       OSTimeDly
00008e  f1a90001          SUB      r0,r9,#1              ;135
000092  fa1ff980          UXTH     r9,r0                 ;135
                  |L2.150|
000096  f1b90f00          CMP      r9,#0                 ;132
00009a  dcf0              BGT      |L2.126|
00009c  2000              MOVS     r0,#0                 ;137
00009e  e7ba              B        |L2.22|
;;;139    #endif
                          ENDP

                  |L2.160|
                          DCD      OSIntNesting

                          AREA ||i.OSTimeDlyResume||, CODE, READONLY, ALIGN=2

                  OSTimeDlyResume PROC
;;;166    #if OS_TIME_DLY_RESUME_EN > 0
;;;167    INT8U  OSTimeDlyResume (INT8U prio)
000000  b570              PUSH     {r4-r6,lr}
;;;168    {
000002  4605              MOV      r5,r0
;;;169        OS_TCB    *ptcb;
;;;170    #if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
;;;171        OS_CPU_SR  cpu_sr = 0;
000004  2600              MOVS     r6,#0
;;;172    #endif
;;;173    
;;;174    
;;;175    
;;;176        if (prio >= OS_LOWEST_PRIO) {
000006  2d3f              CMP      r5,#0x3f
000008  db01              BLT      |L3.14|
;;;177            return (OS_ERR_PRIO_INVALID);
00000a  202a              MOVS     r0,#0x2a
                  |L3.12|
;;;178        }
;;;179        OS_ENTER_CRITICAL();
;;;180        ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
;;;181        if (ptcb == (OS_TCB *)0) {
;;;182            OS_EXIT_CRITICAL();
;;;183            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;184        }
;;;185        if (ptcb == OS_TCB_RESERVED) {
;;;186            OS_EXIT_CRITICAL();
;;;187            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;188        }
;;;189        if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
;;;190            OS_EXIT_CRITICAL();
;;;191            return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
;;;192        }
;;;193    
;;;194        ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
;;;195        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;196            ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
;;;197            ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
;;;198        } else {
;;;199            ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
;;;200        }
;;;201        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
;;;202            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
;;;203            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;204            OS_EXIT_CRITICAL();
;;;205            OS_Sched();                                            /* See if this is new highest priority  */
;;;206        } else {
;;;207            OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
;;;208        }
;;;209        return (OS_ERR_NONE);
;;;210    }
00000c  bd70              POP      {r4-r6,pc}
                  |L3.14|
00000e  f7fffffe          BL       OS_CPU_SR_Save
000012  4606              MOV      r6,r0                 ;179
000014  4826              LDR      r0,|L3.176|
000016  f8504025          LDR      r4,[r0,r5,LSL #2]     ;180
00001a  b924              CBNZ     r4,|L3.38|
00001c  4630              MOV      r0,r6                 ;182
00001e  f7fffffe          BL       OS_CPU_SR_Restore
000022  2043              MOVS     r0,#0x43              ;183
000024  e7f2              B        |L3.12|
                  |L3.38|
000026  2c01              CMP      r4,#1                 ;185
000028  d104              BNE      |L3.52|
00002a  4630              MOV      r0,r6                 ;186
00002c  f7fffffe          BL       OS_CPU_SR_Restore
000030  2043              MOVS     r0,#0x43              ;187
000032  e7eb              B        |L3.12|
                  |L3.52|
000034  8d60              LDRH     r0,[r4,#0x2a]         ;189
000036  b920              CBNZ     r0,|L3.66|
000038  4630              MOV      r0,r6                 ;190
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  2050              MOVS     r0,#0x50              ;191
000040  e7e4              B        |L3.12|
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;194
000044  8560              STRH     r0,[r4,#0x2a]         ;194
000046  f894002c          LDRB     r0,[r4,#0x2c]         ;195
00004a  f0100f37          TST      r0,#0x37              ;195
00004e  d009              BEQ      |L3.100|
000050  f8140f2c          LDRB     r0,[r4,#0x2c]!        ;196
000054  f0200037          BIC      r0,r0,#0x37           ;196
000058  7020              STRB     r0,[r4,#0]            ;196
00005a  2001              MOVS     r0,#1                 ;197
00005c  7060              STRB     r0,[r4,#1]            ;197
00005e  f1a4042c          SUB      r4,r4,#0x2c           ;197
000062  e002              B        |L3.106|
                  |L3.100|
000064  2000              MOVS     r0,#0                 ;199
000066  f884002d          STRB     r0,[r4,#0x2d]         ;199
                  |L3.106|
00006a  f894002c          LDRB     r0,[r4,#0x2c]         ;201
00006e  f0100f08          TST      r0,#8                 ;201
000072  d118              BNE      |L3.166|
000074  f1040430          ADD      r4,r4,#0x30           ;202
000078  78a0              LDRB     r0,[r4,#2]            ;202
00007a  490e              LDR      r1,|L3.180|
00007c  7809              LDRB     r1,[r1,#0]            ;202  ; OSRdyGrp
00007e  ea400001          ORR      r0,r0,r1              ;202
000082  490c              LDR      r1,|L3.180|
000084  7008              STRB     r0,[r1,#0]            ;202
000086  7820              LDRB     r0,[r4,#0]            ;203
000088  490b              LDR      r1,|L3.184|
00008a  5c08              LDRB     r0,[r1,r0]            ;203
00008c  7861              LDRB     r1,[r4,#1]            ;203
00008e  ea400001          ORR      r0,r0,r1              ;203
000092  f8141930          LDRB     r1,[r4],#-0x30        ;203
000096  4a08              LDR      r2,|L3.184|
000098  5450              STRB     r0,[r2,r1]            ;203
00009a  4630              MOV      r0,r6                 ;204
00009c  f7fffffe          BL       OS_CPU_SR_Restore
0000a0  f7fffffe          BL       OS_Sched
0000a4  e002              B        |L3.172|
                  |L3.166|
0000a6  4630              MOV      r0,r6                 ;207
0000a8  f7fffffe          BL       OS_CPU_SR_Restore
                  |L3.172|
0000ac  2000              MOVS     r0,#0                 ;209
0000ae  e7ad              B        |L3.12|
;;;211    #endif
                          ENDP

                  |L3.176|
                          DCD      OSTCBPrioTbl
                  |L3.180|
                          DCD      OSRdyGrp
                  |L3.184|
                          DCD      OSRdyTbl

                          AREA ||i.OSTimeGet||, CODE, READONLY, ALIGN=2

                  OSTimeGet PROC
;;;226    #if OS_TIME_GET_SET_EN > 0
;;;227    INT32U  OSTimeGet (void)
000000  b570              PUSH     {r4-r6,lr}
;;;228    {
;;;229        INT32U     ticks;
;;;230    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;231        OS_CPU_SR  cpu_sr = 0;
000002  2500              MOVS     r5,#0
;;;232    #endif
;;;233    
;;;234    
;;;235    
;;;236        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;237        ticks = OSTime;
00000a  4803              LDR      r0,|L4.24|
00000c  6804              LDR      r4,[r0,#0]  ; OSTime
;;;238        OS_EXIT_CRITICAL();
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       OS_CPU_SR_Restore
;;;239        return (ticks);
000014  4620              MOV      r0,r4
;;;240    }
000016  bd70              POP      {r4-r6,pc}
;;;241    #endif
                          ENDP

                  |L4.24|
                          DCD      OSTime

                          AREA ||i.OSTimeSet||, CODE, READONLY, ALIGN=2

                  OSTimeSet PROC
;;;255    #if OS_TIME_GET_SET_EN > 0
;;;256    void  OSTimeSet (INT32U ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
000002  4604              MOV      r4,r0
;;;258    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;259        OS_CPU_SR  cpu_sr = 0;
000004  2500              MOVS     r5,#0
;;;260    #endif
;;;261    
;;;262    
;;;263    
;;;264        OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4605              MOV      r5,r0
;;;265        OSTime = ticks;
00000c  4802              LDR      r0,|L5.24|
00000e  6004              STR      r4,[r0,#0]  ; OSTime
;;;266        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;267    }
000016  bd70              POP      {r4-r6,pc}
;;;268    #endif
                          ENDP

                  |L5.24|
                          DCD      OSTime
