; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\system_stm32f10x.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\system_stm32f10x.crf Source\Libraries\CMSIS\Core\CM3\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=1

                  SetSysClock PROC
;;;233      */
;;;234    static void SetSysClock(void)
000000  b510              PUSH     {r4,lr}
;;;235    {
;;;236    #ifdef SYSCLK_FREQ_HSE
;;;237      SetSysClockToHSE();
;;;238    #elif defined SYSCLK_FREQ_24MHz
;;;239      SetSysClockTo24();
;;;240    #elif defined SYSCLK_FREQ_36MHz
;;;241      SetSysClockTo36();
;;;242    #elif defined SYSCLK_FREQ_48MHz
;;;243      SetSysClockTo48();
;;;244    #elif defined SYSCLK_FREQ_56MHz
;;;245      SetSysClockTo56();  
;;;246    #elif defined SYSCLK_FREQ_72MHz
;;;247      SetSysClockTo72();
000002  f7fffffe          BL       SetSysClockTo72
;;;248    #endif
;;;249     
;;;250     /* If none of the define above is enabled, the HSI is used as System clock
;;;251        source (default after reset) */ 
;;;252    }
000006  bd10              POP      {r4,pc}
;;;253    
                          ENDP


                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;817      */
;;;818    static void SetSysClockTo72(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;819    {
;;;820      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  9000              STR      r0,[sp,#0]
;;;821      
;;;822      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;823      /* Enable HSE */    
;;;824      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000008  4836              LDR      r0,|L2.228|
00000a  6800              LDR      r0,[r0,#0]
00000c  f4403080          ORR      r0,r0,#0x10000
000010  4934              LDR      r1,|L2.228|
000012  6008              STR      r0,[r1,#0]
;;;825     
;;;826      /* Wait till HSE is ready and if Time out is reached exit */
;;;827      do
000014  bf00              NOP      
                  |L2.22|
;;;828      {
;;;829        HSEStatus = RCC->CR & RCC_CR_HSERDY;
000016  4833              LDR      r0,|L2.228|
000018  6800              LDR      r0,[r0,#0]
00001a  f4003000          AND      r0,r0,#0x20000
00001e  9000              STR      r0,[sp,#0]
;;;830        StartUpCounter++;  
000020  9801              LDR      r0,[sp,#4]
000022  1c40              ADDS     r0,r0,#1
000024  9001              STR      r0,[sp,#4]
;;;831      } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
000026  9800              LDR      r0,[sp,#0]
000028  b918              CBNZ     r0,|L2.50|
00002a  9801              LDR      r0,[sp,#4]
00002c  f5b06fa0          CMP      r0,#0x500
000030  d1f1              BNE      |L2.22|
                  |L2.50|
;;;832    
;;;833      if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000032  482c              LDR      r0,|L2.228|
000034  6800              LDR      r0,[r0,#0]
000036  f4103f00          TST      r0,#0x20000
00003a  d002              BEQ      |L2.66|
;;;834      {
;;;835        HSEStatus = (uint32_t)0x01;
00003c  2001              MOVS     r0,#1
00003e  9000              STR      r0,[sp,#0]
000040  e001              B        |L2.70|
                  |L2.66|
;;;836      }
;;;837      else
;;;838      {
;;;839        HSEStatus = (uint32_t)0x00;
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
                  |L2.70|
;;;840      }  
;;;841    
;;;842      if (HSEStatus == (uint32_t)0x01)
000046  9800              LDR      r0,[sp,#0]
000048  2801              CMP      r0,#1
00004a  d148              BNE      |L2.222|
;;;843      {
;;;844        /* Enable Prefetch Buffer */
;;;845        FLASH->ACR |= FLASH_ACR_PRFTBE;
00004c  4826              LDR      r0,|L2.232|
00004e  6800              LDR      r0,[r0,#0]
000050  f0400010          ORR      r0,r0,#0x10
000054  4924              LDR      r1,|L2.232|
000056  6008              STR      r0,[r1,#0]
;;;846    
;;;847        /* Flash 2 wait state */
;;;848        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]
00005c  f0200003          BIC      r0,r0,#3
000060  6008              STR      r0,[r1,#0]
;;;849        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]
000066  f0400002          ORR      r0,r0,#2
00006a  6008              STR      r0,[r1,#0]
;;;850    
;;;851     
;;;852        /* HCLK = SYSCLK */
;;;853        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00006c  481d              LDR      r0,|L2.228|
00006e  6840              LDR      r0,[r0,#4]
000070  491c              LDR      r1,|L2.228|
000072  6048              STR      r0,[r1,#4]
;;;854          
;;;855        /* PCLK2 = HCLK */
;;;856        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000074  4608              MOV      r0,r1
000076  6840              LDR      r0,[r0,#4]
000078  6048              STR      r0,[r1,#4]
;;;857        
;;;858        /* PCLK1 = HCLK/2 */
;;;859        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00007a  4608              MOV      r0,r1
00007c  6840              LDR      r0,[r0,#4]
00007e  f4406080          ORR      r0,r0,#0x400
000082  6048              STR      r0,[r1,#4]
;;;860    
;;;861    	/*ADCCLK = PCLK2/6*/
;;;862    	RCC->CFGR |= (uint32_t)RCC_CFGR_ADCPRE_DIV6;
000084  4608              MOV      r0,r1
000086  6840              LDR      r0,[r0,#4]
000088  f4404000          ORR      r0,r0,#0x8000
00008c  6048              STR      r0,[r1,#4]
;;;863    
;;;864    #ifdef STM32F10X_CL
;;;865        /* Configure PLLs ------------------------------------------------------*/
;;;866        /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;867        /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;868            
;;;869        RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;870                                  RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;871        RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;872                                 RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;873      
;;;874        /* Enable PLL2 */
;;;875        RCC->CR |= RCC_CR_PLL2ON;
;;;876        /* Wait till PLL2 is ready */
;;;877        while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;878        {
;;;879        }
;;;880        
;;;881       
;;;882        /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;883        RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;884        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;885                                RCC_CFGR_PLLMULL9); 
;;;886    #else    
;;;887        /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;888        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
00008e  4608              MOV      r0,r1
000090  6840              LDR      r0,[r0,#4]
000092  f420107c          BIC      r0,r0,#0x3f0000
000096  6048              STR      r0,[r1,#4]
;;;889                                            RCC_CFGR_PLLMULL));
;;;890        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
000098  4608              MOV      r0,r1
00009a  6840              LDR      r0,[r0,#4]
00009c  f44010e8          ORR      r0,r0,#0x1d0000
0000a0  6048              STR      r0,[r1,#4]
;;;891    #endif /* STM32F10X_CL */
;;;892    
;;;893        /* Enable PLL */
;;;894        RCC->CR |= RCC_CR_PLLON;
0000a2  4608              MOV      r0,r1
0000a4  6800              LDR      r0,[r0,#0]
0000a6  f0407080          ORR      r0,r0,#0x1000000
0000aa  6008              STR      r0,[r1,#0]
;;;895    
;;;896        /* Wait till PLL is ready */
;;;897        while((RCC->CR & RCC_CR_PLLRDY) == 0)
0000ac  bf00              NOP      
                  |L2.174|
0000ae  480d              LDR      r0,|L2.228|
0000b0  6800              LDR      r0,[r0,#0]
0000b2  f0107f00          TST      r0,#0x2000000
0000b6  d0fa              BEQ      |L2.174|
;;;898        {
;;;899        }
;;;900        
;;;901        /* Select PLL as system clock source */
;;;902        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
0000b8  480a              LDR      r0,|L2.228|
0000ba  6840              LDR      r0,[r0,#4]
0000bc  f0200003          BIC      r0,r0,#3
0000c0  4908              LDR      r1,|L2.228|
0000c2  6048              STR      r0,[r1,#4]
;;;903        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
0000c4  4608              MOV      r0,r1
0000c6  6840              LDR      r0,[r0,#4]
0000c8  f0400002          ORR      r0,r0,#2
0000cc  6048              STR      r0,[r1,#4]
;;;904    
;;;905        /* Wait till PLL is used as system clock source */
;;;906        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000ce  bf00              NOP      
                  |L2.208|
0000d0  4804              LDR      r0,|L2.228|
0000d2  6840              LDR      r0,[r0,#4]
0000d4  f000000c          AND      r0,r0,#0xc
0000d8  2808              CMP      r0,#8
0000da  d1f9              BNE      |L2.208|
0000dc  e001              B        |L2.226|
                  |L2.222|
;;;907        {
;;;908        }
;;;909      }
;;;910      else
;;;911      { /* If HSE fails to start-up, the application will have wrong clock 
;;;912             configuration. User can add here some code to deal with this error */    
;;;913    
;;;914        /* Go to infinite loop */
;;;915        while (1)
0000de  bf00              NOP      
                  |L2.224|
0000e0  e7fe              B        |L2.224|
                  |L2.226|
;;;916        {
;;;917        }
;;;918      }
;;;919    }
0000e2  bd0c              POP      {r2,r3,pc}
;;;920    #endif
                          ENDP

                  |L2.228|
                          DCD      0x40021000
                  |L2.232|
                          DCD      0x40022000

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;186      */
;;;187    void SystemInit (void)
000000  b510              PUSH     {r4,lr}
;;;188    {
;;;189      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;190      /* Set HSION bit */
;;;191      RCC->CR |= (uint32_t)0x00000001;
000002  4811              LDR      r0,|L3.72|
000004  6800              LDR      r0,[r0,#0]
000006  f0400001          ORR      r0,r0,#1
00000a  490f              LDR      r1,|L3.72|
00000c  6008              STR      r0,[r1,#0]
;;;192    
;;;193      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;194    #ifndef STM32F10X_CL
;;;195      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000e  4608              MOV      r0,r1
000010  6840              LDR      r0,[r0,#4]
000012  490e              LDR      r1,|L3.76|
000014  4008              ANDS     r0,r0,r1
000016  490c              LDR      r1,|L3.72|
000018  6048              STR      r0,[r1,#4]
;;;196    #else
;;;197      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;198    #endif /* STM32F10X_CL */   
;;;199      
;;;200      /* Reset HSEON, CSSON and PLLON bits */
;;;201      RCC->CR &= (uint32_t)0xFEF6FFFF;
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  490c              LDR      r1,|L3.80|
000020  4008              ANDS     r0,r0,r1
000022  4909              LDR      r1,|L3.72|
000024  6008              STR      r0,[r1,#0]
;;;202    
;;;203      /* Reset HSEBYP bit */
;;;204      RCC->CR &= (uint32_t)0xFFFBFFFF;
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]
00002a  f4202080          BIC      r0,r0,#0x40000
00002e  6008              STR      r0,[r1,#0]
;;;205    
;;;206      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;207      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000030  4608              MOV      r0,r1
000032  6840              LDR      r0,[r0,#4]
000034  f42000fe          BIC      r0,r0,#0x7f0000
000038  6048              STR      r0,[r1,#4]
;;;208    
;;;209    #ifndef STM32F10X_CL
;;;210      /* Disable all interrupts and clear pending bits  */
;;;211      RCC->CIR = 0x009F0000;
00003a  f44f001f          MOV      r0,#0x9f0000
00003e  6088              STR      r0,[r1,#8]
;;;212    #else
;;;213      /* Reset PLL2ON and PLL3ON bits */
;;;214      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;215    
;;;216      /* Disable all interrupts and clear pending bits  */
;;;217      RCC->CIR = 0x00FF0000;
;;;218    
;;;219      /* Reset CFGR2 register */
;;;220      RCC->CFGR2 = 0x00000000;
;;;221    #endif /* STM32F10X_CL */
;;;222        
;;;223      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;224      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;225      SetSysClock();
000040  f7fffffe          BL       SetSysClock
;;;226    
;;;227    }
000044  bd10              POP      {r4,pc}
;;;228    
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x40021000
                  |L3.76|
                          DCD      0xf8ff0000
                  |L3.80|
                          DCD      0xfef6ffff

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  SystemFrequency
                          DCD      0x044aa200
                  SystemFrequency_SysClk
                          DCD      0x044aa200
                  SystemFrequency_AHBClk
                          DCD      0x044aa200
                  SystemFrequency_APB1Clk
                          DCD      0x02255100
                  SystemFrequency_APB2Clk
                          DCD      0x044aa200
