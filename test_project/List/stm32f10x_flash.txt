; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_flash.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_flash.crf Source\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;780      */
;;;781    void FLASH_ClearFlag(uint16_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;782    {
;;;783      /* Check the parameters */
;;;784      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;785      
;;;786      /* Clear the flags */
;;;787      FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;788    }
000004  4770              BX       lr
;;;789    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;463      */
;;;464    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;465    {
000004  4604              MOV      r4,r0
;;;466      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;467      
;;;468      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;469      
;;;470      /* Check the parameters */
;;;471      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;472      
;;;473      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;474      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;475      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;476      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;477      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;478      
;;;479      /* Wait for last operation to be completed */
;;;480      status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;481      
;;;482      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13f              BNE      |L2.174|
;;;483      {
;;;484        /* Authorizes the small information block programming */
;;;485        FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;486        FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;487        FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;488        if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d005              BEQ      |L2.82|
;;;489        {
;;;490          OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;491          
;;;492          /* Wait for last operation to be completed */
;;;493          status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  200f              MOVS     r0,#0xf
00004c  f7fffffe          BL       FLASH_WaitForLastOperation
000050  4605              MOV      r5,r0
                  |L2.82|
;;;494        }
;;;495        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000052  2d04              CMP      r5,#4
000054  d108              BNE      |L2.104|
000056  2fff              CMP      r7,#0xff
000058  d006              BEQ      |L2.104|
;;;496        {
;;;497          OB->WRP1 = WRP1_Data;
00005a  4819              LDR      r0,|L2.192|
00005c  1c80              ADDS     r0,r0,#2
00005e  8007              STRH     r7,[r0,#0]
;;;498          
;;;499          /* Wait for last operation to be completed */
;;;500          status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  200f              MOVS     r0,#0xf
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
                  |L2.104|
;;;501        }
;;;502        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000068  2d04              CMP      r5,#4
00006a  d10a              BNE      |L2.130|
00006c  f1b80fff          CMP      r8,#0xff
000070  d007              BEQ      |L2.130|
;;;503        {
;;;504          OB->WRP2 = WRP2_Data;
000072  4813              LDR      r0,|L2.192|
000074  1d00              ADDS     r0,r0,#4
000076  f8a08000          STRH     r8,[r0,#0]
;;;505          
;;;506          /* Wait for last operation to be completed */
;;;507          status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  200f              MOVS     r0,#0xf
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;508        }
;;;509        
;;;510        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d10a              BNE      |L2.156|
000086  f1b90fff          CMP      r9,#0xff
00008a  d007              BEQ      |L2.156|
;;;511        {
;;;512          OB->WRP3 = WRP3_Data;
00008c  480c              LDR      r0,|L2.192|
00008e  1d80              ADDS     r0,r0,#6
000090  f8a09000          STRH     r9,[r0,#0]
;;;513         
;;;514          /* Wait for last operation to be completed */
;;;515          status = FLASH_WaitForLastOperation(ProgramTimeout);
000094  200f              MOVS     r0,#0xf
000096  f7fffffe          BL       FLASH_WaitForLastOperation
00009a  4605              MOV      r5,r0
                  |L2.156|
;;;516        }
;;;517              
;;;518        if(status != FLASH_TIMEOUT)
00009c  2d05              CMP      r5,#5
00009e  d006              BEQ      |L2.174|
;;;519        {
;;;520          /* if the program operation is completed, disable the OPTPG Bit */
;;;521          FLASH->CR &= CR_OPTPG_Reset;
0000a0  4805              LDR      r0,|L2.184|
0000a2  6900              LDR      r0,[r0,#0x10]
0000a4  f64171ef          MOV      r1,#0x1fef
0000a8  4008              ANDS     r0,r0,r1
0000aa  4903              LDR      r1,|L2.184|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L2.174|
;;;522        }
;;;523      } 
;;;524      /* Return the write protection operation Status */
;;;525      return status;       
0000ae  4628              MOV      r0,r5
;;;526    }
0000b0  e8bd87f0          POP      {r4-r10,pc}
;;;527    
                          ENDP

                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;240      */
;;;241    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;242    {
;;;243      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;244      /* Wait for last operation to be completed */
;;;245      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;246      
;;;247      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d118              BNE      |L3.68|
;;;248      {
;;;249        /* if the previous operation is completed, proceed to erase all pages */
;;;250         FLASH->CR |= CR_MER_Set;
000012  480d              LDR      r0,|L3.72|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490b              LDR      r1,|L3.72|
00001c  6108              STR      r0,[r1,#0x10]
;;;251         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;252        
;;;253        /* Wait for last operation to be completed */
;;;254        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f64070ff          MOV      r0,#0xfff
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;255        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L3.68|
;;;256        {
;;;257          /* if the erase operation is completed, disable the MER Bit */
;;;258          FLASH->CR &= CR_MER_Reset;
000036  4804              LDR      r0,|L3.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fb          MOV      r1,#0x1ffb
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L3.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L3.68|
;;;259        }
;;;260      }	   
;;;261      /* Return the Erase Status */
;;;262      return status;
000044  4620              MOV      r0,r4
;;;263    }
000046  bd10              POP      {r4,pc}
;;;264    
                          ENDP

                  |L3.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;274      */
;;;275    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b510              PUSH     {r4,lr}
;;;276    {
;;;277      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;278      
;;;279      /* Wait for last operation to be completed */
;;;280      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;281      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d13b              BNE      |L4.138|
;;;282      {
;;;283        /* Authorize the small information block programming */
;;;284        FLASH->OPTKEYR = FLASH_KEY1;
000012  481f              LDR      r0,|L4.144|
000014  491f              LDR      r1,|L4.148|
000016  6088              STR      r0,[r1,#8]
;;;285        FLASH->OPTKEYR = FLASH_KEY2;
000018  481f              LDR      r0,|L4.152|
00001a  6088              STR      r0,[r1,#8]
;;;286        
;;;287        /* if the previous operation is completed, proceed to erase the option bytes */
;;;288        FLASH->CR |= CR_OPTER_Set;
00001c  4608              MOV      r0,r1
00001e  6900              LDR      r0,[r0,#0x10]
000020  f0400020          ORR      r0,r0,#0x20
000024  6108              STR      r0,[r1,#0x10]
;;;289        FLASH->CR |= CR_STRT_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400040          ORR      r0,r0,#0x40
00002e  6108              STR      r0,[r1,#0x10]
;;;290        /* Wait for last operation to be completed */
;;;291        status = FLASH_WaitForLastOperation(EraseTimeout);
000030  f64070ff          MOV      r0,#0xfff
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4604              MOV      r4,r0
;;;292        
;;;293        if(status == FLASH_COMPLETE)
00003a  2c04              CMP      r4,#4
00003c  d11c              BNE      |L4.120|
;;;294        {
;;;295          /* if the erase operation is completed, disable the OPTER Bit */
;;;296          FLASH->CR &= CR_OPTER_Reset;
00003e  4815              LDR      r0,|L4.148|
000040  6900              LDR      r0,[r0,#0x10]
000042  f64171df          MOV      r1,#0x1fdf
000046  4008              ANDS     r0,r0,r1
000048  4912              LDR      r1,|L4.148|
00004a  6108              STR      r0,[r1,#0x10]
;;;297           
;;;298          /* Enable the Option Bytes Programming operation */
;;;299          FLASH->CR |= CR_OPTPG_Set;
00004c  4608              MOV      r0,r1
00004e  6900              LDR      r0,[r0,#0x10]
000050  f0400010          ORR      r0,r0,#0x10
000054  6108              STR      r0,[r1,#0x10]
;;;300          /* Disable the Read protection */
;;;301          OB->RDP= RDP_Key; 
000056  20a5              MOVS     r0,#0xa5
000058  4910              LDR      r1,|L4.156|
00005a  8008              STRH     r0,[r1,#0]
;;;302          /* Wait for last operation to be completed */
;;;303          status = FLASH_WaitForLastOperation(ProgramTimeout);
00005c  200f              MOVS     r0,#0xf
00005e  f7fffffe          BL       FLASH_WaitForLastOperation
000062  4604              MOV      r4,r0
;;;304     
;;;305          if(status != FLASH_TIMEOUT)
000064  2c05              CMP      r4,#5
000066  d010              BEQ      |L4.138|
;;;306          {
;;;307            /* if the program operation is completed, disable the OPTPG Bit */
;;;308            FLASH->CR &= CR_OPTPG_Reset;
000068  480a              LDR      r0,|L4.148|
00006a  6900              LDR      r0,[r0,#0x10]
00006c  f64171ef          MOV      r1,#0x1fef
000070  4008              ANDS     r0,r0,r1
000072  4908              LDR      r1,|L4.148|
000074  6108              STR      r0,[r1,#0x10]
000076  e008              B        |L4.138|
                  |L4.120|
;;;309          }
;;;310        }
;;;311        else
;;;312        {
;;;313          if (status != FLASH_TIMEOUT)
000078  2c05              CMP      r4,#5
00007a  d006              BEQ      |L4.138|
;;;314          {
;;;315            /* Disable the OPTPG Bit */
;;;316            FLASH->CR &= CR_OPTPG_Reset;
00007c  4805              LDR      r0,|L4.148|
00007e  6900              LDR      r0,[r0,#0x10]
000080  f64171ef          MOV      r1,#0x1fef
000084  4008              ANDS     r0,r0,r1
000086  4903              LDR      r1,|L4.148|
000088  6108              STR      r0,[r1,#0x10]
                  |L4.138|
;;;317          }
;;;318        }  
;;;319      }
;;;320      /* Return the erase status */
;;;321      return status;
00008a  4620              MOV      r0,r4
;;;322    }
00008c  bd10              POP      {r4,pc}
;;;323    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      0x45670123
                  |L4.148|
                          DCD      0x40022000
                  |L4.152|
                          DCD      0xcdef89ab
                  |L4.156|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;207      */
;;;208    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
000002  4605              MOV      r5,r0
;;;210      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;211      /* Check the parameters */
;;;212      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;213      /* Wait for last operation to be completed */
;;;214      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;215      
;;;216      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d119              BNE      |L5.72|
;;;217      { 
;;;218        /* if the previous operation is completed, proceed to erase the page */
;;;219        FLASH->CR|= CR_PER_Set;
000014  480d              LDR      r0,|L5.76|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490b              LDR      r1,|L5.76|
00001e  6108              STR      r0,[r1,#0x10]
;;;220        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6145              STR      r5,[r0,#0x14]
;;;221        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;222        
;;;223        /* Wait for last operation to be completed */
;;;224        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f64070ff          MOV      r0,#0xfff
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4604              MOV      r4,r0
;;;225        if(status != FLASH_TIMEOUT)
000036  2c05              CMP      r4,#5
000038  d006              BEQ      |L5.72|
;;;226        {
;;;227          /* if the erase operation is completed, disable the PER Bit */
;;;228          FLASH->CR &= CR_PER_Reset;
00003a  4804              LDR      r0,|L5.76|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f64171fd          MOV      r1,#0x1ffd
000042  4008              ANDS     r0,r0,r1
000044  4901              LDR      r1,|L5.76|
000046  6108              STR      r0,[r1,#0x10]
                  |L5.72|
;;;229        }
;;;230      }
;;;231      /* Return the Erase Status */
;;;232      return status;
000048  4620              MOV      r0,r4
;;;233    }
00004a  bd70              POP      {r4-r6,pc}
;;;234    
                          ENDP

                  |L5.76|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;740      */
;;;741    FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;742    {
;;;743      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;744      /* Check the parameters */
;;;745      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;746      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L6.26|
;;;747      {
;;;748        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000008  4a08              LDR      r2,|L6.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0120f01          TST      r2,#1
000010  d001              BEQ      |L6.22|
;;;749        {
;;;750          bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L6.40|
                  |L6.22|
;;;751        }
;;;752        else
;;;753        {
;;;754          bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L6.40|
                  |L6.26|
;;;755        }
;;;756      }
;;;757      else
;;;758      {
;;;759       if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00001a  4a04              LDR      r2,|L6.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  420a              TST      r2,r1
000020  d001              BEQ      |L6.38|
;;;760        {
;;;761          bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L6.40|
                  |L6.38|
;;;762        }
;;;763        else
;;;764        {
;;;765          bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L6.40|
;;;766        }
;;;767      }
;;;768      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;769      return bitstatus;
;;;770    }
000028  4770              BX       lr
;;;771    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;686      */
;;;687    FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;688    {
;;;689      FlagStatus bitstatus = RESET;
;;;690      
;;;691      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L7.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0110f20          TST      r1,#0x20
00000a  d001              BEQ      |L7.16|
;;;692      {
;;;693        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;694      }
;;;695      else
;;;696      {
;;;697        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;698      }
;;;699      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;700      return bitstatus; 
;;;701    }
000012  4770              BX       lr
;;;702    
                          ENDP

                  |L7.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;667      */
;;;668    FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;669    {
;;;670      FlagStatus readoutstatus = RESET;
;;;671      if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L8.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0110f02          TST      r1,#2
00000a  d001              BEQ      |L8.16|
;;;672      {
;;;673        readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L8.18|
                  |L8.16|
;;;674      }
;;;675      else
;;;676      {
;;;677        readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;678      }
;;;679      return readoutstatus;
;;;680    }
000012  4770              BX       lr
;;;681    
                          ENDP

                  |L8.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;795      */
;;;796    FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;797    {
;;;798      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;799      
;;;800      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L9.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0110f01          TST      r1,#1
00000a  d001              BEQ      |L9.16|
;;;801      {
;;;802        flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L9.46|
                  |L9.16|
;;;803      }
;;;804      else 
;;;805      {  
;;;806        if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
000010  4907              LDR      r1,|L9.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0110f04          TST      r1,#4
000018  d001              BEQ      |L9.30|
;;;807        { 
;;;808          flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L9.46|
                  |L9.30|
;;;809        }
;;;810        else 
;;;811        {
;;;812          if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L9.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0110f10          TST      r1,#0x10
000026  d001              BEQ      |L9.44|
;;;813          {
;;;814            flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L9.46|
                  |L9.44|
;;;815          }
;;;816          else
;;;817          {
;;;818            flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L9.46|
;;;819          }
;;;820        }
;;;821      }
;;;822      /* Return the Flash Status */
;;;823      return flashstatus;
;;;824    }
00002e  4770              BX       lr
;;;825    
                          ENDP

                  |L9.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;645      */
;;;646    uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L10.8|
;;;647    {
;;;648      /* Return the User Option Byte */
;;;649      return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;650    }
000006  4770              BX       lr
;;;651    
                          ENDP

                  |L10.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;656      */
;;;657    uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L11.8|
;;;658    {
;;;659      /* Return the Falsh write protection Register value */
;;;660      return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;661    }
000004  4770              BX       lr
;;;662    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;150      */
;;;151    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L12.24|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;155      
;;;156      /* Enable or disable the Half cycle access */
;;;157      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L12.24|
00000a  6011              STR      r1,[r2,#0]
;;;158      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;159    }
000014  4770              BX       lr
;;;160    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;712      */
;;;713    void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L13.14|
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;717      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;718      if(NewState != DISABLE)
;;;719      {
;;;720        /* Enable the interrupt sources */
;;;721        FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L13.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L13.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L13.24|
                  |L13.14|
;;;722      }
;;;723      else
;;;724      {
;;;725        /* Disable the interrupt sources */
;;;726        FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L13.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L13.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L13.24|
;;;727      }
;;;728    }
000018  4770              BX       lr
;;;729    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;195      */
;;;196    void FLASH_Lock(void)
000000  4803              LDR      r0,|L14.16|
;;;197    {
;;;198      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;199      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L14.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;200    }
00000c  4770              BX       lr
;;;201    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;168      */
;;;169    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L15.24|
;;;170    {
;;;171      /* Check the parameters */
;;;172      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;173      
;;;174      /* Enable or disable the Prefetch Buffer */
;;;175      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L15.24|
00000a  6011              STR      r1,[r2,#0]
;;;176      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;177    }
000014  4770              BX       lr
;;;178    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;387      */
;;;388    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;390      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;391      /* Check the parameters */
;;;392      assert_param(IS_FLASH_ADDRESS(Address));
;;;393      /* Wait for last operation to be completed */
;;;394      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;395      
;;;396      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d113              BNE      |L16.60|
;;;397      {
;;;398        /* if the previous operation is completed, proceed to program the new data */
;;;399        FLASH->CR |= CR_PG_Set;
000014  480a              LDR      r0,|L16.64|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4908              LDR      r1,|L16.64|
00001e  6108              STR      r0,[r1,#0x10]
;;;400      
;;;401        *(__IO uint16_t*)Address = Data;
000020  802e              STRH     r6,[r5,#0]
;;;402        /* Wait for last operation to be completed */
;;;403        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;404        if(status != FLASH_TIMEOUT)
00002a  2c05              CMP      r4,#5
00002c  d006              BEQ      |L16.60|
;;;405        {
;;;406          /* if the program operation is completed, disable the PG Bit */
;;;407          FLASH->CR &= CR_PG_Reset;
00002e  4804              LDR      r0,|L16.64|
000030  6900              LDR      r0,[r0,#0x10]
000032  f64171fe          MOV      r1,#0x1ffe
000036  4008              ANDS     r0,r0,r1
000038  4901              LDR      r1,|L16.64|
00003a  6108              STR      r0,[r1,#0x10]
                  |L16.60|
;;;408        }
;;;409      } 
;;;410      /* Return the Program Status */
;;;411      return status;
00003c  4620              MOV      r0,r4
;;;412    }
00003e  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

                  |L16.64|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;421      */
;;;422    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;423    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;424      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;425      /* Check the parameters */
;;;426      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;427      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;428      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L17.68|
;;;429      {
;;;430        /* Authorize the small information block programming */
;;;431        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L17.72|
000016  490d              LDR      r1,|L17.76|
000018  6088              STR      r0,[r1,#8]
;;;432        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L17.80|
00001c  6088              STR      r0,[r1,#8]
;;;433        /* Enables the Option Bytes Programming operation */
;;;434        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;435        *(__IO uint16_t*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;436        
;;;437        /* Wait for last operation to be completed */
;;;438        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  200f              MOVS     r0,#0xf
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;439        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L17.68|
;;;440        {
;;;441          /* if the program operation is completed, disable the OPTPG Bit */
;;;442          FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L17.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L17.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L17.68|
;;;443        }
;;;444      }    
;;;445      /* Return the Option Byte Data Program Status */
;;;446      return status;
000044  4620              MOV      r0,r4
;;;447    }
000046  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  |L17.72|
                          DCD      0x45670123
                  |L17.76|
                          DCD      0x40022000
                  |L17.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;330      */
;;;331    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;332    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;333      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;334      __IO uint32_t tmp = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;335    
;;;336      /* Check the parameters */
;;;337      assert_param(IS_FLASH_ADDRESS(Address));
;;;338      /* Wait for last operation to be completed */
;;;339      status = FLASH_WaitForLastOperation(ProgramTimeout);
00000c  200f              MOVS     r0,#0xf
00000e  f7fffffe          BL       FLASH_WaitForLastOperation
000012  4604              MOV      r4,r0
;;;340      
;;;341      if(status == FLASH_COMPLETE)
000014  2c04              CMP      r4,#4
000016  d128              BNE      |L18.106|
;;;342      {
;;;343        /* if the previous operation is completed, proceed to program the new first 
;;;344        half word */
;;;345        FLASH->CR |= CR_PG_Set;
000018  4815              LDR      r0,|L18.112|
00001a  6900              LDR      r0,[r0,#0x10]
00001c  f0400001          ORR      r0,r0,#1
000020  4913              LDR      r1,|L18.112|
000022  6108              STR      r0,[r1,#0x10]
;;;346      
;;;347        *(__IO uint16_t*)Address = (uint16_t)Data;
000024  8035              STRH     r5,[r6,#0]
;;;348        /* Wait for last operation to be completed */
;;;349        status = FLASH_WaitForLastOperation(ProgramTimeout);
000026  200f              MOVS     r0,#0xf
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4604              MOV      r4,r0
;;;350     
;;;351        if(status == FLASH_COMPLETE)
00002e  2c04              CMP      r4,#4
000030  d112              BNE      |L18.88|
;;;352        {
;;;353          /* if the previous operation is completed, proceed to program the new second 
;;;354          half word */
;;;355          tmp = Address + 2;
000032  1cb0              ADDS     r0,r6,#2
000034  9000              STR      r0,[sp,#0]
;;;356    
;;;357          *(__IO uint16_t*) tmp = Data >> 16;
000036  0c28              LSRS     r0,r5,#16
000038  9900              LDR      r1,[sp,#0]
00003a  8008              STRH     r0,[r1,#0]
;;;358        
;;;359          /* Wait for last operation to be completed */
;;;360          status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  200f              MOVS     r0,#0xf
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;361            
;;;362          if(status != FLASH_TIMEOUT)
000044  2c05              CMP      r4,#5
000046  d010              BEQ      |L18.106|
;;;363          {
;;;364            /* Disable the PG Bit */
;;;365            FLASH->CR &= CR_PG_Reset;
000048  4809              LDR      r0,|L18.112|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171fe          MOV      r1,#0x1ffe
000050  4008              ANDS     r0,r0,r1
000052  4907              LDR      r1,|L18.112|
000054  6108              STR      r0,[r1,#0x10]
000056  e008              B        |L18.106|
                  |L18.88|
;;;366          }
;;;367        }
;;;368        else
;;;369        {
;;;370          if (status != FLASH_TIMEOUT)
000058  2c05              CMP      r4,#5
00005a  d006              BEQ      |L18.106|
;;;371          {
;;;372            /* Disable the PG Bit */
;;;373            FLASH->CR &= CR_PG_Reset;
00005c  4804              LDR      r0,|L18.112|
00005e  6900              LDR      r0,[r0,#0x10]
000060  f64171fe          MOV      r1,#0x1ffe
000064  4008              ANDS     r0,r0,r1
000066  4902              LDR      r1,|L18.112|
000068  6108              STR      r0,[r1,#0x10]
                  |L18.106|
;;;374          }
;;;375         }
;;;376      }
;;;377      /* Return the Program Status */
;;;378      return status;
00006a  4620              MOV      r0,r4
;;;379    }
00006c  bdf8              POP      {r3-r7,pc}
;;;380    
                          ENDP

00006e  0000              DCW      0x0000
                  |L18.112|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;536      */
;;;537    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;538    {
000002  4605              MOV      r5,r0
;;;539      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;540      /* Check the parameters */
;;;541      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;542      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;543      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L19.152|
;;;544      {
;;;545        /* Authorizes the small information block programming */
;;;546        FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L19.156|
000016  4922              LDR      r1,|L19.160|
000018  6088              STR      r0,[r1,#8]
;;;547        FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L19.164|
00001c  6088              STR      r0,[r1,#8]
;;;548        FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;549        FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;550        /* Wait for last operation to be completed */
;;;551        status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f64070ff          MOV      r0,#0xfff
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;552        if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L19.134|
;;;553        {
;;;554          /* if the erase operation is completed, disable the OPTER Bit */
;;;555          FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L19.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L19.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;556          /* Enable the Option Bytes Programming operation */
;;;557          FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;558          if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L19.98|
;;;559          {
;;;560            OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L19.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L19.104|
                  |L19.98|
;;;561          }
;;;562          else
;;;563          {
;;;564            OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L19.168|
000066  8008              STRH     r0,[r1,#0]
                  |L19.104|
;;;565          }
;;;566          /* Wait for last operation to be completed */
;;;567          status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f64070ff          MOV      r0,#0xfff
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;568        
;;;569          if(status != FLASH_TIMEOUT)
000072  2c05              CMP      r4,#5
000074  d010              BEQ      |L19.152|
;;;570          {
;;;571            /* if the program operation is completed, disable the OPTPG Bit */
;;;572            FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L19.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L19.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L19.152|
                  |L19.134|
;;;573          }
;;;574        }
;;;575        else 
;;;576        {
;;;577          if(status != FLASH_TIMEOUT)
000086  2c05              CMP      r4,#5
000088  d006              BEQ      |L19.152|
;;;578          {
;;;579            /* Disable the OPTER Bit */
;;;580            FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L19.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L19.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L19.152|
;;;581          }
;;;582        }
;;;583      }
;;;584      /* Return the protection operation Status */
;;;585      return status;      
000098  4620              MOV      r0,r4
;;;586    }
00009a  bd70              POP      {r4-r6,pc}
;;;587    
                          ENDP

                  |L19.156|
                          DCD      0x45670123
                  |L19.160|
                          DCD      0x40022000
                  |L19.164|
                          DCD      0xcdef89ab
                  |L19.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;124      */
;;;125    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;126    {
;;;127      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;128      
;;;129      /* Check the parameters */
;;;130      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;131      
;;;132      /* Read the ACR register */
;;;133      tmpreg = FLASH->ACR;  
000004  4a03              LDR      r2,|L20.20|
000006  6810              LDR      r0,[r2,#0]
;;;134      
;;;135      /* Sets the Latency value */
;;;136      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;137      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;138      
;;;139      /* Write the ACR register */
;;;140      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;141    }
000010  4770              BX       lr
;;;142    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;183      */
;;;184    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L21.12|
;;;185    {
;;;186      /* Authorize the FPEC Access */
;;;187      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L21.16|
000004  6048              STR      r0,[r1,#4]
;;;188      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L21.20|
000008  6048              STR      r0,[r1,#4]
;;;189    }
00000a  4770              BX       lr
;;;190    
                          ENDP

                  |L21.12|
                          DCD      0x45670123
                  |L21.16|
                          DCD      0x40022000
                  |L21.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;604      */
;;;605    FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;606    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;607      FLASH_Status status = FLASH_COMPLETE; 
00000a  2404              MOVS     r4,#4
;;;608    
;;;609      /* Check the parameters */
;;;610      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;611      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;612      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;613    
;;;614      /* Authorize the small information block programming */
;;;615      FLASH->OPTKEYR = FLASH_KEY1;
00000c  4813              LDR      r0,|L22.92|
00000e  4914              LDR      r1,|L22.96|
000010  6088              STR      r0,[r1,#8]
;;;616      FLASH->OPTKEYR = FLASH_KEY2;
000012  4814              LDR      r0,|L22.100|
000014  6088              STR      r0,[r1,#8]
;;;617      
;;;618      /* Wait for last operation to be completed */
;;;619      status = FLASH_WaitForLastOperation(ProgramTimeout);
000016  200f              MOVS     r0,#0xf
000018  f7fffffe          BL       FLASH_WaitForLastOperation
00001c  4604              MOV      r4,r0
;;;620      
;;;621      if(status == FLASH_COMPLETE)
00001e  2c04              CMP      r4,#4
000020  d118              BNE      |L22.84|
;;;622      {  
;;;623        /* Enable the Option Bytes Programming operation */
;;;624        FLASH->CR |= CR_OPTPG_Set; 
000022  480f              LDR      r0,|L22.96|
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400010          ORR      r0,r0,#0x10
00002a  490d              LDR      r1,|L22.96|
00002c  6108              STR      r0,[r1,#0x10]
;;;625               
;;;626        OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
00002e  f04700f8          ORR      r0,r7,#0xf8
000032  4330              ORRS     r0,r0,r6
000034  4328              ORRS     r0,r0,r5
000036  490c              LDR      r1,|L22.104|
000038  8008              STRH     r0,[r1,#0]
;;;627      
;;;628        /* Wait for last operation to be completed */
;;;629        status = FLASH_WaitForLastOperation(ProgramTimeout);
00003a  200f              MOVS     r0,#0xf
00003c  f7fffffe          BL       FLASH_WaitForLastOperation
000040  4604              MOV      r4,r0
;;;630        if(status != FLASH_TIMEOUT)
000042  2c05              CMP      r4,#5
000044  d006              BEQ      |L22.84|
;;;631        {
;;;632          /* if the program operation is completed, disable the OPTPG Bit */
;;;633          FLASH->CR &= CR_OPTPG_Reset;
000046  4806              LDR      r0,|L22.96|
000048  6900              LDR      r0,[r0,#0x10]
00004a  f64171ef          MOV      r1,#0x1fef
00004e  4008              ANDS     r0,r0,r1
000050  4903              LDR      r1,|L22.96|
000052  6108              STR      r0,[r1,#0x10]
                  |L22.84|
;;;634        }
;;;635      }    
;;;636      /* Return the Option Byte program Status */
;;;637      return status;
000054  4620              MOV      r0,r4
;;;638    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;639    
                          ENDP

00005a  0000              DCW      0x0000
                  |L22.92|
                          DCD      0x45670123
                  |L22.96|
                          DCD      0x40022000
                  |L22.100|
                          DCD      0xcdef89ab
                  |L22.104|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;831      */
;;;832    FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;833    { 
000002  4604              MOV      r4,r0
;;;834      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;835       
;;;836      /* Check for the Flash Status */
;;;837      status = FLASH_GetStatus();
000006  f7fffffe          BL       FLASH_GetStatus
00000a  4605              MOV      r5,r0
;;;838      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;839      while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e005              B        |L23.26|
                  |L23.14|
;;;840      {
;;;841        delay();
00000e  f7fffffe          BL       delay
;;;842        status = FLASH_GetStatus();
000012  f7fffffe          BL       FLASH_GetStatus
000016  4605              MOV      r5,r0
;;;843        Timeout--;
000018  1e64              SUBS     r4,r4,#1
                  |L23.26|
00001a  2d01              CMP      r5,#1                 ;839
00001c  d101              BNE      |L23.34|
00001e  2c00              CMP      r4,#0                 ;839
000020  d1f5              BNE      |L23.14|
                  |L23.34|
;;;844      }
;;;845      if(Timeout == 0x00 )
000022  b904              CBNZ     r4,|L23.38|
;;;846      {
;;;847        status = FLASH_TIMEOUT;
000024  2505              MOVS     r5,#5
                  |L23.38|
;;;848      }
;;;849      /* Return the operation status */
;;;850      return status;
000026  4628              MOV      r0,r5
;;;851    }
000028  bd70              POP      {r4-r6,pc}
;;;852    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;857      */
;;;858    static void delay(void)
000000  b508              PUSH     {r3,lr}
;;;859    {
;;;860      __IO uint32_t i = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;861      for(i = 0xFF; i != 0; i--)
000006  20ff              MOVS     r0,#0xff
000008  9000              STR      r0,[sp,#0]
00000a  e002              B        |L24.18|
                  |L24.12|
00000c  9800              LDR      r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  9000              STR      r0,[sp,#0]
                  |L24.18|
000012  9800              LDR      r0,[sp,#0]
000014  2800              CMP      r0,#0
000016  d1f9              BNE      |L24.12|
;;;862      {
;;;863      }
;;;864    }
000018  bd08              POP      {r3,pc}
;;;865    
                          ENDP

