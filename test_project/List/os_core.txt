; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_core.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\os_core.crf Source\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||i.OSEventNameGet||, CODE, READONLY, ALIGN=2

                  OSEventNameGet PROC
;;;107    #if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
;;;108    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;109    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;110        INT8U      len;
;;;111    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;112        OS_CPU_SR  cpu_sr = 0;
00000a  2700              MOVS     r7,#0
;;;113    #endif
;;;114    
;;;115    
;;;116    
;;;117    #if OS_ARG_CHK_EN > 0
;;;118        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
00000c  b914              CBNZ     r4,|L1.20|
;;;119            return (0);
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;120        }
;;;121        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;122            *perr = OS_ERR_PEVENT_NULL;
;;;123            return (0);
;;;124        }
;;;125        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;126            *perr = OS_ERR_PNAME_NULL;
;;;127            return (0);
;;;128        }
;;;129    #endif
;;;130        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;131            *perr  = OS_ERR_NAME_GET_ISR;
;;;132            return (0);
;;;133        }
;;;134        switch (pevent->OSEventType) {
;;;135        case OS_EVENT_TYPE_SEM:
;;;136        case OS_EVENT_TYPE_MUTEX:
;;;137        case OS_EVENT_TYPE_MBOX:
;;;138        case OS_EVENT_TYPE_Q:
;;;139            break;
;;;140    
;;;141        default:
;;;142            *perr = OS_ERR_EVENT_TYPE;
;;;143            return (0);
;;;144        }
;;;145        OS_ENTER_CRITICAL();
;;;146        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;147        OS_EXIT_CRITICAL();
;;;148        *perr = OS_ERR_NONE;
;;;149        return (len);
;;;150    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L1.20|
000014  b91d              CBNZ     r5,|L1.30|
000016  2004              MOVS     r0,#4                 ;122
000018  7020              STRB     r0,[r4,#0]            ;122
00001a  2000              MOVS     r0,#0                 ;123
00001c  e7f8              B        |L1.16|
                  |L1.30|
00001e  b91e              CBNZ     r6,|L1.40|
000020  200c              MOVS     r0,#0xc               ;126
000022  7020              STRB     r0,[r4,#0]            ;126
000024  2000              MOVS     r0,#0                 ;127
000026  e7f3              B        |L1.16|
                  |L1.40|
000028  4815              LDR      r0,|L1.128|
00002a  7800              LDRB     r0,[r0,#0]            ;130  ; OSIntNesting
00002c  2800              CMP      r0,#0                 ;130
00002e  dd03              BLE      |L1.56|
000030  2011              MOVS     r0,#0x11              ;131
000032  7020              STRB     r0,[r4,#0]            ;131
000034  2000              MOVS     r0,#0                 ;132
000036  e7eb              B        |L1.16|
                  |L1.56|
000038  7828              LDRB     r0,[r5,#0]            ;134
00003a  2801              CMP      r0,#1                 ;134
00003c  d008              BEQ      |L1.80|
00003e  2802              CMP      r0,#2                 ;134
000040  d007              BEQ      |L1.82|
000042  2803              CMP      r0,#3                 ;134
000044  d002              BEQ      |L1.76|
000046  2804              CMP      r0,#4                 ;134
000048  d104              BNE      |L1.84|
00004a  e000              B        |L1.78|
                  |L1.76|
00004c  bf00              NOP                            ;136
                  |L1.78|
00004e  bf00              NOP                            ;137
                  |L1.80|
000050  bf00              NOP                            ;138
                  |L1.82|
000052  e003              B        |L1.92|
                  |L1.84|
000054  2001              MOVS     r0,#1                 ;142
000056  7020              STRB     r0,[r4,#0]            ;142
000058  2000              MOVS     r0,#0                 ;143
00005a  e7d9              B        |L1.16|
                  |L1.92|
00005c  bf00              NOP                            ;139
00005e  f7fffffe          BL       OS_CPU_SR_Save
000062  4607              MOV      r7,r0                 ;145
000064  f1050113          ADD      r1,r5,#0x13           ;146
000068  4630              MOV      r0,r6                 ;146
00006a  f7fffffe          BL       OS_StrCopy
00006e  4680              MOV      r8,r0                 ;146
000070  4638              MOV      r0,r7                 ;147
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2000              MOVS     r0,#0                 ;148
000078  7020              STRB     r0,[r4,#0]            ;148
00007a  4640              MOV      r0,r8                 ;149
00007c  e7c8              B        |L1.16|
;;;151    #endif
                          ENDP

00007e  0000              DCW      0x0000
                  |L1.128|
                          DCD      OSIntNesting

                          AREA ||i.OSEventNameSet||, CODE, READONLY, ALIGN=2

                  OSEventNameSet PROC
;;;181    #if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
;;;182    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;183    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;184        INT8U      len;
;;;185    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;186        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0800          MOV      r8,#0
;;;187    #endif
;;;188    
;;;189    
;;;190    
;;;191    #if OS_ARG_CHK_EN > 0
;;;192        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
00000e  b90c              CBNZ     r4,|L2.20|
                  |L2.16|
;;;193            return;
;;;194        }
;;;195        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;196            *perr = OS_ERR_PEVENT_NULL;
;;;197            return;
;;;198        }
;;;199        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;200            *perr = OS_ERR_PNAME_NULL;
;;;201            return;
;;;202        }
;;;203    #endif
;;;204        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;205            *perr = OS_ERR_NAME_SET_ISR;
;;;206            return;
;;;207        }
;;;208        switch (pevent->OSEventType) {
;;;209        case OS_EVENT_TYPE_SEM:
;;;210        case OS_EVENT_TYPE_MUTEX:
;;;211        case OS_EVENT_TYPE_MBOX:
;;;212        case OS_EVENT_TYPE_Q:
;;;213            break;
;;;214    
;;;215        default:
;;;216            *perr = OS_ERR_EVENT_TYPE;
;;;217            return;
;;;218        }
;;;219        OS_ENTER_CRITICAL();
;;;220        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;221        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;222            OS_EXIT_CRITICAL();
;;;223            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;224            return;
;;;225        }
;;;226        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;227        OS_EXIT_CRITICAL();
;;;228        *perr = OS_ERR_NONE;
;;;229    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L2.20|
000014  b915              CBNZ     r5,|L2.28|
000016  2004              MOVS     r0,#4                 ;196
000018  7020              STRB     r0,[r4,#0]            ;196
00001a  e7f9              B        |L2.16|
                  |L2.28|
00001c  b916              CBNZ     r6,|L2.36|
00001e  200c              MOVS     r0,#0xc               ;200
000020  7020              STRB     r0,[r4,#0]            ;200
000022  e7f5              B        |L2.16|
                  |L2.36|
000024  4819              LDR      r0,|L2.140|
000026  7800              LDRB     r0,[r0,#0]            ;204  ; OSIntNesting
000028  2800              CMP      r0,#0                 ;204
00002a  dd02              BLE      |L2.50|
00002c  2012              MOVS     r0,#0x12              ;205
00002e  7020              STRB     r0,[r4,#0]            ;205
000030  e7ee              B        |L2.16|
                  |L2.50|
000032  7828              LDRB     r0,[r5,#0]            ;208
000034  2801              CMP      r0,#1                 ;208
000036  d008              BEQ      |L2.74|
000038  2802              CMP      r0,#2                 ;208
00003a  d007              BEQ      |L2.76|
00003c  2803              CMP      r0,#3                 ;208
00003e  d002              BEQ      |L2.70|
000040  2804              CMP      r0,#4                 ;208
000042  d104              BNE      |L2.78|
000044  e000              B        |L2.72|
                  |L2.70|
000046  bf00              NOP                            ;210
                  |L2.72|
000048  bf00              NOP                            ;211
                  |L2.74|
00004a  bf00              NOP                            ;212
                  |L2.76|
00004c  e002              B        |L2.84|
                  |L2.78|
00004e  2001              MOVS     r0,#1                 ;216
000050  7020              STRB     r0,[r4,#0]            ;216
000052  e7dd              B        |L2.16|
                  |L2.84|
000054  bf00              NOP                            ;213
000056  f7fffffe          BL       OS_CPU_SR_Save
00005a  4680              MOV      r8,r0                 ;219
00005c  4630              MOV      r0,r6                 ;220
00005e  f7fffffe          BL       OS_StrLen
000062  4607              MOV      r7,r0                 ;220
000064  2f0f              CMP      r7,#0xf               ;221
000066  dd05              BLE      |L2.116|
000068  4640              MOV      r0,r8                 ;222
00006a  f7fffffe          BL       OS_CPU_SR_Restore
00006e  200b              MOVS     r0,#0xb               ;223
000070  7020              STRB     r0,[r4,#0]            ;223
000072  e7cd              B        |L2.16|
                  |L2.116|
000074  4631              MOV      r1,r6                 ;226
000076  f1050013          ADD      r0,r5,#0x13           ;226
00007a  f7fffffe          BL       OS_StrCopy
00007e  4640              MOV      r0,r8                 ;227
000080  f7fffffe          BL       OS_CPU_SR_Restore
000084  2000              MOVS     r0,#0                 ;228
000086  7020              STRB     r0,[r4,#0]            ;228
000088  bf00              NOP      
00008a  e7c1              B        |L2.16|
;;;230    #endif
                          ENDP

                  |L2.140|
                          DCD      OSIntNesting

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=1

                  OSInit PROC
;;;245    
;;;246    void  OSInit (void)
000000  b510              PUSH     {r4,lr}
;;;247    {
;;;248        OSInitHookBegin();                                           /* Call port specific initialization code   */
000002  f7fffffe          BL       OSInitHookBegin
;;;249    
;;;250        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000006  f7fffffe          BL       OS_InitMisc
;;;251    
;;;252        OS_InitRdyList();                                            /* Initialize the Ready List                */
00000a  f7fffffe          BL       OS_InitRdyList
;;;253    
;;;254        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000e  f7fffffe          BL       OS_InitTCBList
;;;255    
;;;256        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000012  f7fffffe          BL       OS_InitEventList
;;;257    
;;;258    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;259        OS_FlagInit();                                               /* Initialize the event flag structures     */
000016  f7fffffe          BL       OS_FlagInit
;;;260    #endif
;;;261    
;;;262    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;263        OS_MemInit();                                                /* Initialize the memory manager            */
00001a  f7fffffe          BL       OS_MemInit
;;;264    #endif
;;;265    
;;;266    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;267        OS_QInit();                                                  /* Initialize the message queue structures  */
00001e  f7fffffe          BL       OS_QInit
;;;268    #endif
;;;269    
;;;270        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
000022  f7fffffe          BL       OS_InitTaskIdle
;;;271    #if OS_TASK_STAT_EN > 0
;;;272        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000026  f7fffffe          BL       OS_InitTaskStat
;;;273    #endif
;;;274    
;;;275    #if OS_TMR_EN > 0
;;;276        OSTmr_Init();                                                /* Initialize the Timer Manager             */
00002a  f7fffffe          BL       OSTmr_Init
;;;277    #endif
;;;278    
;;;279        OSInitHookEnd();                                             /* Call port specific init. code            */
00002e  f7fffffe          BL       OSInitHookEnd
;;;280    
;;;281    #if OS_DEBUG_EN > 0
;;;282        OSDebugInit();
;;;283    #endif
;;;284    }
000032  bd10              POP      {r4,pc}
;;;285    /*$PAGE*/
                          ENDP


                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;310    
;;;311    void  OSIntEnter(void)
000000  4806              LDR      r0,|L4.28|
;;;312    {
;;;313        if(OSRunning==OS_TRUE) {
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d108              BNE      |L4.26|
;;;314            if(OSIntNesting<255u) {
000008  4805              LDR      r0,|L4.32|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  28ff              CMP      r0,#0xff
00000e  d204              BCS      |L4.26|
;;;315                OSIntNesting++;    /* Increment ISR nesting level */
000010  4803              LDR      r0,|L4.32|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000014  1c40              ADDS     r0,r0,#1
000016  4902              LDR      r1,|L4.32|
000018  7008              STRB     r0,[r1,#0]
                  |L4.26|
;;;316            }
;;;317        }
;;;318    }
00001a  4770              BX       lr
;;;319    /*$PAGE*/
                          ENDP

                  |L4.28|
                          DCD      OSRunning
                  |L4.32|
                          DCD      OSIntNesting

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;338    
;;;339    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;340    {
;;;341    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;342        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;343    #endif
;;;344    
;;;345        if(OSRunning==OS_TRUE) {
000004  481a              LDR      r0,|L5.112|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d130              BNE      |L5.110|
;;;346            OS_ENTER_CRITICAL();  //保存全局中断标志,关中断
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;347            if(OSIntNesting>0) { /* Prevent OSIntNesting from wrapping       */
000012  4818              LDR      r0,|L5.116|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  2800              CMP      r0,#0
000018  dd04              BLE      |L5.36|
;;;348                OSIntNesting--;
00001a  4816              LDR      r0,|L5.116|
00001c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001e  1e40              SUBS     r0,r0,#1
000020  4914              LDR      r1,|L5.116|
000022  7008              STRB     r0,[r1,#0]
                  |L5.36|
;;;349            }
;;;350            if(OSIntNesting==0) { /* Reschedule only if all ISRs complete ... */
000024  4813              LDR      r0,|L5.116|
000026  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000028  b9f0              CBNZ     r0,|L5.104|
;;;351                if(OSLockNesting==0) {  /* ... and not locked.                      */
00002a  4813              LDR      r0,|L5.120|
00002c  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002e  b9d8              CBNZ     r0,|L5.104|
;;;352                    OS_SchedNew();
000030  f7fffffe          BL       OS_SchedNew
;;;353                    if(OSPrioHighRdy!=OSPrioCur) { /* No Ctx Sw if current task is highest rdy */
000034  4811              LDR      r0,|L5.124|
000036  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000038  4911              LDR      r1,|L5.128|
00003a  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
00003c  4288              CMP      r0,r1
00003e  d013              BEQ      |L5.104|
;;;354                        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
000040  4810              LDR      r0,|L5.132|
000042  490e              LDR      r1,|L5.124|
000044  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000046  f8500021          LDR      r0,[r0,r1,LSL #2]
00004a  490f              LDR      r1,|L5.136|
00004c  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;355    #if OS_TASK_PROFILE_EN > 0
;;;356                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00004e  4608              MOV      r0,r1
000050  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000052  6b40              LDR      r0,[r0,#0x34]
000054  1c40              ADDS     r0,r0,#1
000056  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000058  6348              STR      r0,[r1,#0x34]
;;;357    #endif
;;;358                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00005a  480c              LDR      r0,|L5.140|
00005c  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00005e  1c40              ADDS     r0,r0,#1
000060  490a              LDR      r1,|L5.140|
000062  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;359                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000064  f7fffffe          BL       OSIntCtxSw
                  |L5.104|
;;;360                    }
;;;361                }
;;;362            }
;;;363            OS_EXIT_CRITICAL();	 //恢复之前的中断标志
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L5.110|
;;;364        }
;;;365    }
00006e  bd10              POP      {r4,pc}
;;;366    /*$PAGE*/
                          ENDP

                  |L5.112|
                          DCD      OSRunning
                  |L5.116|
                          DCD      OSIntNesting
                  |L5.120|
                          DCD      OSLockNesting
                  |L5.124|
                          DCD      OSPrioHighRdy
                  |L5.128|
                          DCD      OSPrioCur
                  |L5.132|
                          DCD      OSTCBPrioTbl
                  |L5.136|
                          DCD      OSTCBHighRdy
                  |L5.140|
                          DCD      OSCtxSwCtr

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;383    #if OS_SCHED_LOCK_EN > 0
;;;384    void  OSSchedLock (void)
000000  b510              PUSH     {r4,lr}
;;;385    {
;;;386    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;387        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;388    #endif
;;;389    
;;;390    
;;;391    
;;;392        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000004  480b              LDR      r0,|L6.52|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d111              BNE      |L6.48|
;;;393            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;394            if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
000012  4809              LDR      r0,|L6.56|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b940              CBNZ     r0,|L6.42|
;;;395                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000018  4808              LDR      r0,|L6.60|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  28ff              CMP      r0,#0xff
00001e  d204              BCS      |L6.42|
;;;396                    OSLockNesting++;                 /* Increment lock nesting level                       */
000020  4806              LDR      r0,|L6.60|
000022  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000024  1c40              ADDS     r0,r0,#1
000026  4905              LDR      r1,|L6.60|
000028  7008              STRB     r0,[r1,#0]
                  |L6.42|
;;;397                }
;;;398            }
;;;399            OS_EXIT_CRITICAL();
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L6.48|
;;;400        }
;;;401    }
000030  bd10              POP      {r4,pc}
;;;402    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      OSRunning
                  |L6.56|
                          DCD      OSIntNesting
                  |L6.60|
                          DCD      OSLockNesting

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;420    #if OS_SCHED_LOCK_EN > 0
;;;421    void  OSSchedUnlock (void)
000000  b510              PUSH     {r4,lr}
;;;422    {
;;;423    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;424        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;425    #endif
;;;426    
;;;427    
;;;428    
;;;429        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000004  4813              LDR      r0,|L7.84|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d122              BNE      |L7.82|
;;;430            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;431            if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
000012  4811              LDR      r0,|L7.88|
000014  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000016  2800              CMP      r0,#0
000018  dd18              BLE      |L7.76|
;;;432                OSLockNesting--;                               /* Decrement lock nesting level             */
00001a  480f              LDR      r0,|L7.88|
00001c  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001e  1e40              SUBS     r0,r0,#1
000020  490d              LDR      r1,|L7.88|
000022  7008              STRB     r0,[r1,#0]
;;;433                if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
000024  4608              MOV      r0,r1
000026  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000028  b960              CBNZ     r0,|L7.68|
;;;434                    if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
00002a  480c              LDR      r0,|L7.92|
00002c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00002e  b928              CBNZ     r0,|L7.60|
;;;435                        OS_EXIT_CRITICAL();
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       OS_CPU_SR_Restore
;;;436                        OS_Sched();                            /* See if a HPT is ready                    */
000036  f7fffffe          BL       OS_Sched
00003a  e00a              B        |L7.82|
                  |L7.60|
;;;437                    } else {
;;;438                        OS_EXIT_CRITICAL();
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  e006              B        |L7.82|
                  |L7.68|
;;;439                    }
;;;440                } else {
;;;441                    OS_EXIT_CRITICAL();
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  e002              B        |L7.82|
                  |L7.76|
;;;442                }
;;;443            } else {
;;;444                OS_EXIT_CRITICAL();
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       OS_CPU_SR_Restore
                  |L7.82|
;;;445            }
;;;446        }
;;;447    }
000052  bd10              POP      {r4,pc}
;;;448    #endif
                          ENDP

                  |L7.84|
                          DCD      OSRunning
                  |L7.88|
                          DCD      OSLockNesting
                  |L7.92|
                          DCD      OSIntNesting

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;470    
;;;471    void  OSStart (void)
000000  b510              PUSH     {r4,lr}
;;;472    {
;;;473        if (OSRunning == OS_FALSE) {
000002  480b              LDR      r0,|L8.48|
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  b990              CBNZ     r0,|L8.46|
;;;474            OS_SchedNew();                               /* Find highest priority's task priority number   */
000008  f7fffffe          BL       OS_SchedNew
;;;475            OSPrioCur     = OSPrioHighRdy;
00000c  4809              LDR      r0,|L8.52|
00000e  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000010  4909              LDR      r1,|L8.56|
000012  7008              STRB     r0,[r1,#0]
;;;476            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000014  4809              LDR      r0,|L8.60|
000016  4907              LDR      r1,|L8.52|
000018  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00001a  f8500021          LDR      r0,[r0,r1,LSL #2]
00001e  4908              LDR      r1,|L8.64|
000020  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;477            OSTCBCur      = OSTCBHighRdy;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000026  4907              LDR      r1,|L8.68|
000028  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;478            OSStartHighRdy();                            /* Execute target specific code to start task     */
00002a  f7fffffe          BL       OSStartHighRdy
                  |L8.46|
;;;479        }
;;;480    }
00002e  bd10              POP      {r4,pc}
;;;481    /*$PAGE*/
                          ENDP

                  |L8.48|
                          DCD      OSRunning
                  |L8.52|
                          DCD      OSPrioHighRdy
                  |L8.56|
                          DCD      OSPrioCur
                  |L8.60|
                          DCD      OSTCBPrioTbl
                  |L8.64|
                          DCD      OSTCBHighRdy
                  |L8.68|
                          DCD      OSTCBCur

                          AREA ||i.OSStatInit||, CODE, READONLY, ALIGN=2

                  OSStatInit PROC
;;;502    #if OS_TASK_STAT_EN > 0
;;;503    void  OSStatInit (void)
000000  b510              PUSH     {r4,lr}
;;;504    {
;;;505    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;506        OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;507    #endif
;;;508    
;;;509    
;;;510    
;;;511        OSTimeDly(2);                                /* Synchronize with clock tick                        */
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       OSTimeDly
;;;512        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4604              MOV      r4,r0
;;;513        OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
000010  2000              MOVS     r0,#0
000012  490b              LDR      r1,|L9.64|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;514        OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;515        OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
00001c  2064              MOVS     r0,#0x64
00001e  f7fffffe          BL       OSTimeDly
;;;516        OS_ENTER_CRITICAL();
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4604              MOV      r4,r0
;;;517        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000028  4805              LDR      r0,|L9.64|
00002a  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00002c  4905              LDR      r1,|L9.68|
00002e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;518        OSStatRdy    = OS_TRUE;
000030  2001              MOVS     r0,#1
000032  4905              LDR      r1,|L9.72|
000034  7008              STRB     r0,[r1,#0]
;;;519        OS_EXIT_CRITICAL();
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       OS_CPU_SR_Restore
;;;520    }
00003c  bd10              POP      {r4,pc}
;;;521    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      OSIdleCtr
                  |L9.68|
                          DCD      OSIdleCtrMax
                  |L9.72|
                          DCD      OSStatRdy

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;536    
;;;537    void  OSTimeTick (void)
000000  b570              PUSH     {r4-r6,lr}
;;;538    {
;;;539        OS_TCB    *ptcb;
;;;540    #if OS_TICK_STEP_EN > 0
;;;541        BOOLEAN    step;
;;;542    #endif
;;;543    
;;;544    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;545        OS_CPU_SR  cpu_sr = 0;
000002  2600              MOVS     r6,#0
;;;546    #endif
;;;547    
;;;548    
;;;549    
;;;550    #if OS_TIME_TICK_HOOK_EN > 0
;;;551        OSTimeTickHook();                                      /* Call user definable hook */
000004  f7fffffe          BL       OSTimeTickHook
;;;552    #endif
;;;553    
;;;554    #if OS_TIME_GET_SET_EN > 0
;;;555        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter */
000008  f7fffffe          BL       OS_CPU_SR_Save
00000c  4606              MOV      r6,r0
;;;556        OSTime++;
00000e  4833              LDR      r0,|L10.220|
000010  6800              LDR      r0,[r0,#0]  ; OSTime
000012  1c40              ADDS     r0,r0,#1
000014  4931              LDR      r1,|L10.220|
000016  6008              STR      r0,[r1,#0]  ; OSTime
;;;557        OS_EXIT_CRITICAL();
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       OS_CPU_SR_Restore
;;;558    #endif
;;;559    
;;;560        if(OSRunning==OS_TRUE) {
00001e  4830              LDR      r0,|L10.224|
000020  7800              LDRB     r0,[r0,#0]  ; OSRunning
000022  2801              CMP      r0,#1
000024  d158              BNE      |L10.216|
;;;561    #if OS_TICK_STEP_EN > 0
;;;562            switch(OSTickStepState) {
000026  482f              LDR      r0,|L10.228|
000028  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
00002a  b120              CBZ      r0,|L10.54|
00002c  2801              CMP      r0,#1
00002e  d004              BEQ      |L10.58|
000030  2802              CMP      r0,#2
000032  d109              BNE      |L10.72|
000034  e003              B        |L10.62|
                  |L10.54|
;;;563            /* Determine whether we need to process a tick  */
;;;564            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled */
;;;565                step = OS_TRUE;
000036  2501              MOVS     r5,#1
;;;566                break;
000038  e00b              B        |L10.82|
                  |L10.58|
;;;567    
;;;568            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ... */
;;;569                step = OS_FALSE;                       /* .. OSTickStepState to OS_TICK_STEP_ONCE */
00003a  2500              MOVS     r5,#0
;;;570                break;
00003c  e009              B        |L10.82|
                  |L10.62|
;;;571    
;;;572            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;573                step = OS_TRUE;                       /*... step command from uC/OS-View */
00003e  2501              MOVS     r5,#1
;;;574                OSTickStepState = OS_TICK_STEP_WAIT;
000040  2001              MOVS     r0,#1
000042  4928              LDR      r1,|L10.228|
000044  7008              STRB     r0,[r1,#0]
;;;575                break;
000046  e004              B        |L10.82|
                  |L10.72|
;;;576    
;;;577            default:                                       /* Invalid case, correct situation */
;;;578                step = OS_TRUE;
000048  2501              MOVS     r5,#1
;;;579                OSTickStepState = OS_TICK_STEP_DIS;
00004a  2000              MOVS     r0,#0
00004c  4925              LDR      r1,|L10.228|
00004e  7008              STRB     r0,[r1,#0]
;;;580                break;
000050  bf00              NOP      
                  |L10.82|
000052  bf00              NOP                            ;566
;;;581            }
;;;582            if(step==OS_FALSE) {  /* Return if waiting for step command  */
000054  b905              CBNZ     r5,|L10.88|
                  |L10.86|
;;;583                return;
;;;584            }
;;;585    #endif
;;;586    
;;;587            ptcb = OSTCBList;                          /* Point at first TCB in TCB list  */
;;;588            while(ptcb->OSTCBPrio!=OS_TASK_IDLE_PRIO) { /* Go through all TCBs in TCB list */
;;;589                OS_ENTER_CRITICAL();
;;;590                if(ptcb->OSTCBDly!=0) {  /* No, Delayed or waiting for event with TO */
;;;591                    if(--ptcb->OSTCBDly==0) {	    /* Decrement nbr of ticks to end of delay */
;;;592                        /* Check for timeout */
;;;593                        if((ptcb->OSTCBStat&OS_STAT_PEND_ANY)!=OS_STAT_RDY) {
;;;594                            ptcb->OSTCBStat&=~(INT8U)OS_STAT_PEND_ANY;  /* Yes, Clear status flag */
;;;595                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;      /* Indicate PEND timeout */
;;;596                        } else {
;;;597                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;598                        }
;;;599    
;;;600                        if((ptcb->OSTCBStat&OS_STAT_SUSPEND)==OS_STAT_RDY) { /*Is task suspended? */
;;;601                            OSRdyGrp|= ptcb->OSTCBBitY;             /* No, Make ready */
;;;602                            OSRdyTbl[ptcb->OSTCBY]|=ptcb->OSTCBBitX;
;;;603                        }
;;;604                    }
;;;605                }
;;;606                ptcb = ptcb->OSTCBNext;  /* Point at next TCB in TCB list */
;;;607                OS_EXIT_CRITICAL();
;;;608            }
;;;609        }
;;;610    }
000056  bd70              POP      {r4-r6,pc}
                  |L10.88|
000058  4823              LDR      r0,|L10.232|
00005a  6804              LDR      r4,[r0,#0]            ;587  ; OSTCBList
00005c  e038              B        |L10.208|
                  |L10.94|
00005e  f7fffffe          BL       OS_CPU_SR_Save
000062  4606              MOV      r6,r0                 ;589
000064  8d60              LDRH     r0,[r4,#0x2a]         ;590
000066  b378              CBZ      r0,|L10.200|
000068  8d60              LDRH     r0,[r4,#0x2a]         ;591
00006a  1e40              SUBS     r0,r0,#1              ;591
00006c  0400              LSLS     r0,r0,#16             ;591
00006e  0c00              LSRS     r0,r0,#16             ;591
000070  8560              STRH     r0,[r4,#0x2a]         ;591
000072  d129              BNE      |L10.200|
000074  f894002c          LDRB     r0,[r4,#0x2c]         ;593
000078  f0100f37          TST      r0,#0x37              ;593
00007c  d009              BEQ      |L10.146|
00007e  f8140f2c          LDRB     r0,[r4,#0x2c]!        ;594
000082  f0200037          BIC      r0,r0,#0x37           ;594
000086  7020              STRB     r0,[r4,#0]            ;594
000088  2001              MOVS     r0,#1                 ;595
00008a  7060              STRB     r0,[r4,#1]            ;595
00008c  f1a4042c          SUB      r4,r4,#0x2c           ;595
000090  e002              B        |L10.152|
                  |L10.146|
000092  2000              MOVS     r0,#0                 ;597
000094  f884002d          STRB     r0,[r4,#0x2d]         ;597
                  |L10.152|
000098  f894002c          LDRB     r0,[r4,#0x2c]         ;600
00009c  f0100f08          TST      r0,#8                 ;600
0000a0  d112              BNE      |L10.200|
0000a2  f1040430          ADD      r4,r4,#0x30           ;601
0000a6  78a0              LDRB     r0,[r4,#2]            ;601
0000a8  4910              LDR      r1,|L10.236|
0000aa  7809              LDRB     r1,[r1,#0]            ;601  ; OSRdyGrp
0000ac  ea400001          ORR      r0,r0,r1              ;601
0000b0  490e              LDR      r1,|L10.236|
0000b2  7008              STRB     r0,[r1,#0]            ;601
0000b4  7820              LDRB     r0,[r4,#0]            ;602
0000b6  490e              LDR      r1,|L10.240|
0000b8  5c08              LDRB     r0,[r1,r0]            ;602
0000ba  7861              LDRB     r1,[r4,#1]            ;602
0000bc  ea400001          ORR      r0,r0,r1              ;602
0000c0  f8141930          LDRB     r1,[r4],#-0x30        ;602
0000c4  4a0a              LDR      r2,|L10.240|
0000c6  5450              STRB     r0,[r2,r1]            ;602
                  |L10.200|
0000c8  6964              LDR      r4,[r4,#0x14]         ;606
0000ca  4630              MOV      r0,r6                 ;607
0000cc  f7fffffe          BL       OS_CPU_SR_Restore
                  |L10.208|
0000d0  f894002e          LDRB     r0,[r4,#0x2e]         ;588
0000d4  283f              CMP      r0,#0x3f              ;588
0000d6  d1c2              BNE      |L10.94|
                  |L10.216|
0000d8  bf00              NOP      
0000da  e7bc              B        |L10.86|
;;;611    
                          ENDP

                  |L10.220|
                          DCD      OSTime
                  |L10.224|
                          DCD      OSRunning
                  |L10.228|
                          DCD      OSTickStepState
                  |L10.232|
                          DCD      OSTCBList
                  |L10.236|
                          DCD      OSRdyGrp
                  |L10.240|
                          DCD      OSRdyTbl

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;626    
;;;627    INT16U  OSVersion (void)
000000  f240101d          MOV      r0,#0x11d
;;;628    {
;;;629        return (OS_VERSION);
;;;630    }
000004  4770              BX       lr
;;;631    
                          ENDP


                          AREA ||i.OS_Dummy||, CODE, READONLY, ALIGN=1

                  OS_Dummy PROC
;;;645    #if OS_TASK_DEL_EN > 0
;;;646    void  OS_Dummy (void)
000000  4770              BX       lr
;;;647    {
;;;648    }
;;;649    #endif
                          ENDP


                          AREA ||i.OS_EventTOAbort||, CODE, READONLY, ALIGN=2

                  OS_EventTOAbort PROC
;;;786    #if OS_EVENT_EN
;;;787    void  OS_EventTOAbort (OS_EVENT *pevent)
000000  4a12              LDR      r2,|L13.76|
;;;788    {
;;;789        INT8U  y;
;;;790    
;;;791    
;;;792        y                       =  OSTCBCur->OSTCBY;
000002  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000004  f8921030          LDRB     r1,[r2,#0x30]
;;;793        pevent->OSEventTbl[y]  &= ~OSTCBCur->OSTCBBitX;    /* Remove task from wait list                   */
000008  f100020b          ADD      r2,r0,#0xb
00000c  5c52              LDRB     r2,[r2,r1]
00000e  4b0f              LDR      r3,|L13.76|
000010  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000012  f8933031          LDRB     r3,[r3,#0x31]
000016  439a              BICS     r2,r2,r3
000018  f100030b          ADD      r3,r0,#0xb
00001c  545a              STRB     r2,[r3,r1]
;;;794        if (pevent->OSEventTbl[y] == 0x00) {
00001e  461a              MOV      r2,r3
000020  5c52              LDRB     r2,[r2,r1]
000022  b932              CBNZ     r2,|L13.50|
;;;795            pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
000024  7a82              LDRB     r2,[r0,#0xa]
000026  4b09              LDR      r3,|L13.76|
000028  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00002a  f8933032          LDRB     r3,[r3,#0x32]
00002e  439a              BICS     r2,r2,r3
000030  7282              STRB     r2,[r0,#0xa]
                  |L13.50|
;;;796        }
;;;797        OSTCBCur->OSTCBStatPend =  OS_STAT_PEND_OK;        /* Clear pend status                            */
000032  2200              MOVS     r2,#0
000034  4b05              LDR      r3,|L13.76|
000036  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000038  f883202d          STRB     r2,[r3,#0x2d]
;;;798        OSTCBCur->OSTCBStat     =  OS_STAT_RDY;            /* Set status to ready                          */
00003c  4b03              LDR      r3,|L13.76|
00003e  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000040  f883202c          STRB     r2,[r3,#0x2c]
;;;799        OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
000044  4b01              LDR      r3,|L13.76|
000046  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000048  61da              STR      r2,[r3,#0x1c]
;;;800    }
00004a  4770              BX       lr
;;;801    #endif
                          ENDP

                  |L13.76|
                          DCD      OSTCBCur

                          AREA ||i.OS_EventTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_EventTaskRdy PROC
;;;679    #if OS_EVENT_EN
;;;680    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;681    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;682        OS_TCB  *ptcb;
;;;683        INT8U    x;
;;;684        INT8U    y;
;;;685        INT8U    prio;
;;;686    #if OS_LOWEST_PRIO <= 63
;;;687        INT8U    bitx;
;;;688        INT8U    bity;
;;;689    #else
;;;690        INT16U   bitx;
;;;691        INT16U   bity;
;;;692        INT16U  *ptbl;
;;;693    #endif
;;;694    
;;;695    
;;;696    #if OS_LOWEST_PRIO <= 63
;;;697        y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
00000a  f894900a          LDRB     r9,[r4,#0xa]
00000e  f8dfa0bc          LDR      r10,|L14.204|
000012  f81a2009          LDRB     r2,[r10,r9]
;;;698        bity  = (INT8U)(1 << y);
000016  f04f0901          MOV      r9,#1
00001a  fa09f902          LSL      r9,r9,r2
00001e  f00908ff          AND      r8,r9,#0xff
;;;699        x     = OSUnMapTbl[pevent->OSEventTbl[y]];
000022  f104090b          ADD      r9,r4,#0xb
000026  f8199002          LDRB     r9,[r9,r2]
00002a  f81a7009          LDRB     r7,[r10,r9]
;;;700        bitx  = (INT8U)(1 << x);
00002e  f04f0901          MOV      r9,#1
000032  fa09f907          LSL      r9,r9,r7
000036  f0090cff          AND      r12,r9,#0xff
;;;701        prio  = (INT8U)((y << 3) + x);                      /* Find priority of task getting the msg       */
00003a  eb0709c2          ADD      r9,r7,r2,LSL #3
00003e  f00900ff          AND      r0,r9,#0xff
;;;702    #else
;;;703        if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;704            y = OSUnMapTbl[pevent->OSEventGrp & 0xFF];
;;;705        } else {
;;;706            y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;707        }
;;;708        bity = (INT16U)(1 << y);
;;;709        ptbl = &pevent->OSEventTbl[y];
;;;710        if ((*ptbl & 0xFF) != 0) {
;;;711            x = OSUnMapTbl[*ptbl & 0xFF];
;;;712        } else {
;;;713            x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;714        }
;;;715        bitx = (INT16U)(1 << x);
;;;716        prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;717    #endif
;;;718    
;;;719        pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
000042  f104090b          ADD      r9,r4,#0xb
000046  f8199002          LDRB     r9,[r9,r2]
00004a  ea29090c          BIC      r9,r9,r12
00004e  f1040a0b          ADD      r10,r4,#0xb
000052  f80a9002          STRB     r9,[r10,r2]
;;;720        if (pevent->OSEventTbl[y] == 0) {
000056  46d1              MOV      r9,r10
000058  f8199002          LDRB     r9,[r9,r2]
00005c  f1b90f00          CMP      r9,#0
000060  d105              BNE      |L14.110|
;;;721            pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
000062  f894900a          LDRB     r9,[r4,#0xa]
000066  ea290908          BIC      r9,r9,r8
00006a  f884900a          STRB     r9,[r4,#0xa]
                  |L14.110|
;;;722        }
;;;723        ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
00006e  f8df9060          LDR      r9,|L14.208|
000072  f8591020          LDR      r1,[r9,r0,LSL #2]
;;;724        ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
000076  f04f0900          MOV      r9,#0
00007a  f8a1902a          STRH     r9,[r1,#0x2a]
;;;725        ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
00007e  f8c1901c          STR      r9,[r1,#0x1c]
;;;726    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;727        ptcb->OSTCBMsg       =  pmsg;                       /* Send message directly to waiting task       */
000082  620d              STR      r5,[r1,#0x20]
;;;728    #else
;;;729        pmsg                 =  pmsg;                       /* Prevent compiler warning if not used        */
;;;730    #endif
;;;731        ptcb->OSTCBStatPend  =  pend_stat;                  /* Set pend status of post or abort            */
000084  f881302d          STRB     r3,[r1,#0x2d]
;;;732        ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
000088  f891902c          LDRB     r9,[r1,#0x2c]
00008c  ea290906          BIC      r9,r9,r6
000090  f881902c          STRB     r9,[r1,#0x2c]
;;;733        if (ptcb->OSTCBStat ==  OS_STAT_RDY) {              /* See if task is ready (could be susp'd)      */
000094  f891902c          LDRB     r9,[r1,#0x2c]
000098  f1b90f00          CMP      r9,#0
00009c  d113              BNE      |L14.198|
;;;734            OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
00009e  f8df9034          LDR      r9,|L14.212|
0000a2  f8999000          LDRB     r9,[r9,#0]  ; OSRdyGrp
0000a6  ea490908          ORR      r9,r9,r8
0000aa  f8dfa028          LDR      r10,|L14.212|
0000ae  f88a9000          STRB     r9,[r10,#0]
;;;735            OSRdyTbl[y]     |=  bitx;
0000b2  f8df9024          LDR      r9,|L14.216|
0000b6  f8199002          LDRB     r9,[r9,r2]
0000ba  ea49090c          ORR      r9,r9,r12
0000be  f8dfa018          LDR      r10,|L14.216|
0000c2  f80a9002          STRB     r9,[r10,r2]
                  |L14.198|
;;;736        }
;;;737        return (prio);
;;;738    }
0000c6  e8bd87f0          POP      {r4-r10,pc}
;;;739    #endif
                          ENDP

0000ca  0000              DCW      0x0000
                  |L14.204|
                          DCD      OSUnMapTbl
                  |L14.208|
                          DCD      OSTCBPrioTbl
                  |L14.212|
                          DCD      OSRdyGrp
                  |L14.216|
                          DCD      OSRdyTbl

                          AREA ||i.OS_EventTaskWait||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWait PROC
;;;755    #if OS_EVENT_EN
;;;756    void  OS_EventTaskWait (OS_EVENT *pevent)
000000  b510              PUSH     {r4,lr}
;;;757    {
;;;758        INT8U  y;
;;;759    
;;;760    
;;;761        OSTCBCur->OSTCBEventPtr =  pevent;            /* Store pointer to event control block in TCB       */
000002  4a1b              LDR      r2,|L15.112|
000004  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000006  61d0              STR      r0,[r2,#0x1c]
;;;762        y                       =  OSTCBCur->OSTCBY;  /* Task no longer ready                              */
000008  4a19              LDR      r2,|L15.112|
00000a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00000c  f8921030          LDRB     r1,[r2,#0x30]
;;;763        OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
000010  4a18              LDR      r2,|L15.116|
000012  5c52              LDRB     r2,[r2,r1]
000014  4b16              LDR      r3,|L15.112|
000016  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000018  f8933031          LDRB     r3,[r3,#0x31]
00001c  439a              BICS     r2,r2,r3
00001e  4b15              LDR      r3,|L15.116|
000020  545a              STRB     r2,[r3,r1]
;;;764        if (OSRdyTbl[y] == 0) {
000022  461a              MOV      r2,r3
000024  5c52              LDRB     r2,[r2,r1]
000026  b942              CBNZ     r2,|L15.58|
;;;765            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
000028  4a11              LDR      r2,|L15.112|
00002a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00002c  f8923032          LDRB     r3,[r2,#0x32]
000030  4a11              LDR      r2,|L15.120|
000032  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000034  439a              BICS     r2,r2,r3
000036  4b10              LDR      r3,|L15.120|
000038  701a              STRB     r2,[r3,#0]
                  |L15.58|
;;;766        }
;;;767        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
00003a  4a0d              LDR      r2,|L15.112|
00003c  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00003e  f8923030          LDRB     r3,[r2,#0x30]
000042  f100020b          ADD      r2,r0,#0xb
000046  5cd2              LDRB     r2,[r2,r3]
000048  4b09              LDR      r3,|L15.112|
00004a  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00004c  f8933031          LDRB     r3,[r3,#0x31]
000050  431a              ORRS     r2,r2,r3
000052  4b07              LDR      r3,|L15.112|
000054  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000056  f8934030          LDRB     r4,[r3,#0x30]
00005a  f100030b          ADD      r3,r0,#0xb
00005e  551a              STRB     r2,[r3,r4]
;;;768        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000060  7a82              LDRB     r2,[r0,#0xa]
000062  4b03              LDR      r3,|L15.112|
000064  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000066  f8933032          LDRB     r3,[r3,#0x32]
00006a  431a              ORRS     r2,r2,r3
00006c  7282              STRB     r2,[r0,#0xa]
;;;769    }
00006e  bd10              POP      {r4,pc}
;;;770    #endif
                          ENDP

                  |L15.112|
                          DCD      OSTCBCur
                  |L15.116|
                          DCD      OSRdyTbl
                  |L15.120|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventWaitListInit||, CODE, READONLY, ALIGN=1

                  OS_EventWaitListInit PROC
;;;816    #if OS_EVENT_EN
;;;817    void  OS_EventWaitListInit (OS_EVENT *pevent)
000000  2300              MOVS     r3,#0
;;;818    {
;;;819    #if OS_LOWEST_PRIO <= 63
;;;820        INT8U  *ptbl;
;;;821    #else
;;;822        INT16U *ptbl;
;;;823    #endif
;;;824        INT8U   i;
;;;825    
;;;826    
;;;827        pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
000002  7283              STRB     r3,[r0,#0xa]
;;;828        ptbl               = &pevent->OSEventTbl[0];
000004  f100010b          ADD      r1,r0,#0xb
;;;829    
;;;830        for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
000008  2200              MOVS     r2,#0
00000a  e004              B        |L16.22|
                  |L16.12|
;;;831            *ptbl++ = 0;
00000c  2300              MOVS     r3,#0
00000e  f8013b01          STRB     r3,[r1],#1
000012  1c53              ADDS     r3,r2,#1              ;830
000014  b2da              UXTB     r2,r3                 ;830
                  |L16.22|
000016  2a08              CMP      r2,#8                 ;830
000018  dbf8              BLT      |L16.12|
;;;832        }
;;;833    }
00001a  4770              BX       lr
;;;834    #endif
                          ENDP


                          AREA ||i.OS_InitEventList||, CODE, READONLY, ALIGN=2

                  OS_InitEventList PROC
;;;848    
;;;849    static  void  OS_InitEventList (void)
000000  b530              PUSH     {r4,r5,lr}
;;;850    {
;;;851    #if OS_EVENT_EN && (OS_MAX_EVENTS > 0)
;;;852    #if (OS_MAX_EVENTS > 1)
;;;853        INT16U     i;
;;;854        OS_EVENT  *pevent1;
;;;855        OS_EVENT  *pevent2;
;;;856    
;;;857    
;;;858        OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000002  f44f71b4          MOV      r1,#0x168
000006  4810              LDR      r0,|L17.72|
000008  f7fffffe          BL       OS_MemClr
;;;859        pevent1 = &OSEventTbl[0];
00000c  4b0e              LDR      r3,|L17.72|
;;;860        pevent2 = &OSEventTbl[1];
00000e  f1030524          ADD      r5,r3,#0x24
;;;861        for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
000012  2400              MOVS     r4,#0
000014  e00a              B        |L17.44|
                  |L17.22|
;;;862            pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
000016  2000              MOVS     r0,#0
000018  7018              STRB     r0,[r3,#0]
;;;863            pevent1->OSEventPtr     = pevent2;
00001a  605d              STR      r5,[r3,#4]
;;;864    #if OS_EVENT_NAME_SIZE > 1
;;;865            pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
00001c  203f              MOVS     r0,#0x3f
00001e  74d8              STRB     r0,[r3,#0x13]
;;;866            pevent1->OSEventName[1] = OS_ASCII_NUL;
000020  2100              MOVS     r1,#0
000022  7519              STRB     r1,[r3,#0x14]
;;;867    #endif
;;;868            pevent1++;
000024  3324              ADDS     r3,r3,#0x24
;;;869            pevent2++;
000026  3524              ADDS     r5,r5,#0x24
000028  1c60              ADDS     r0,r4,#1              ;861
00002a  b284              UXTH     r4,r0                 ;861
                  |L17.44|
00002c  2c09              CMP      r4,#9                 ;861
00002e  dbf2              BLT      |L17.22|
;;;870        }
;;;871        pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000030  2000              MOVS     r0,#0
000032  7018              STRB     r0,[r3,#0]
;;;872        pevent1->OSEventPtr             = (OS_EVENT *)0;
000034  6058              STR      r0,[r3,#4]
;;;873    #if OS_EVENT_NAME_SIZE > 1
;;;874        pevent1->OSEventName[0]         = '?';
000036  203f              MOVS     r0,#0x3f
000038  74d8              STRB     r0,[r3,#0x13]
;;;875        pevent1->OSEventName[1]         = OS_ASCII_NUL;
00003a  2100              MOVS     r1,#0
00003c  7519              STRB     r1,[r3,#0x14]
;;;876    #endif
;;;877        OSEventFreeList                 = &OSEventTbl[0];
00003e  4802              LDR      r0,|L17.72|
000040  4902              LDR      r1,|L17.76|
000042  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;878    #else
;;;879        OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;880        OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;881        OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;882    #if OS_EVENT_NAME_SIZE > 1
;;;883        OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;884        OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;885    #endif
;;;886    #endif
;;;887    #endif
;;;888    }
000044  bd30              POP      {r4,r5,pc}
;;;889    /*$PAGE*/
                          ENDP

000046  0000              DCW      0x0000
                  |L17.72|
                          DCD      OSEventTbl
                  |L17.76|
                          DCD      OSEventFreeList

                          AREA ||i.OS_InitMisc||, CODE, READONLY, ALIGN=2

                  OS_InitMisc PROC
;;;902    
;;;903    static  void  OS_InitMisc (void)
000000  2000              MOVS     r0,#0
;;;904    {
;;;905    #if OS_TIME_GET_SET_EN > 0
;;;906        OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
000002  490a              LDR      r1,|L18.44|
000004  6008              STR      r0,[r1,#0]  ; OSTime
;;;907    #endif
;;;908    
;;;909        OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
000006  490a              LDR      r1,|L18.48|
000008  7008              STRB     r0,[r1,#0]
;;;910        OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
00000a  490a              LDR      r1,|L18.52|
00000c  7008              STRB     r0,[r1,#0]
;;;911    
;;;912        OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
00000e  490a              LDR      r1,|L18.56|
000010  7008              STRB     r0,[r1,#0]
;;;913    
;;;914        OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
000012  490a              LDR      r1,|L18.60|
000014  7008              STRB     r0,[r1,#0]
;;;915    
;;;916        OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
000016  490a              LDR      r1,|L18.64|
000018  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;917        OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
00001a  490a              LDR      r1,|L18.68|
00001c  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;918    
;;;919    #if OS_TASK_STAT_EN > 0
;;;920        OSIdleCtrRun  = 0L;
00001e  490a              LDR      r1,|L18.72|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;921        OSIdleCtrMax  = 0L;
000022  490a              LDR      r1,|L18.76|
000024  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;922        OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
000026  490a              LDR      r1,|L18.80|
000028  7008              STRB     r0,[r1,#0]
;;;923    #endif
;;;924    }
00002a  4770              BX       lr
;;;925    /*$PAGE*/
                          ENDP

                  |L18.44|
                          DCD      OSTime
                  |L18.48|
                          DCD      OSIntNesting
                  |L18.52|
                          DCD      OSLockNesting
                  |L18.56|
                          DCD      OSTaskCtr
                  |L18.60|
                          DCD      OSRunning
                  |L18.64|
                          DCD      OSCtxSwCtr
                  |L18.68|
                          DCD      OSIdleCtr
                  |L18.72|
                          DCD      OSIdleCtrRun
                  |L18.76|
                          DCD      OSIdleCtrMax
                  |L18.80|
                          DCD      OSStatRdy

                          AREA ||i.OS_InitRdyList||, CODE, READONLY, ALIGN=2

                  OS_InitRdyList PROC
;;;938    
;;;939    static  void  OS_InitRdyList (void)
000000  2200              MOVS     r2,#0
;;;940    {
;;;941        INT8U    i;
;;;942    #if OS_LOWEST_PRIO <= 63
;;;943        INT8U   *prdytbl;
;;;944    #else
;;;945        INT16U  *prdytbl;
;;;946    #endif
;;;947    
;;;948    
;;;949        OSRdyGrp      = 0;                                     /* Clear the ready list                     */
000002  4b0b              LDR      r3,|L19.48|
000004  701a              STRB     r2,[r3,#0]
;;;950        prdytbl       = &OSRdyTbl[0];
000006  490b              LDR      r1,|L19.52|
;;;951        for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
000008  2000              MOVS     r0,#0
00000a  e004              B        |L19.22|
                  |L19.12|
;;;952            *prdytbl++ = 0;
00000c  2200              MOVS     r2,#0
00000e  f8012b01          STRB     r2,[r1],#1
000012  1c42              ADDS     r2,r0,#1              ;951
000014  b2d0              UXTB     r0,r2                 ;951
                  |L19.22|
000016  2808              CMP      r0,#8                 ;951
000018  dbf8              BLT      |L19.12|
;;;953        }
;;;954    
;;;955        OSPrioCur     = 0;
00001a  2200              MOVS     r2,#0
00001c  4b06              LDR      r3,|L19.56|
00001e  701a              STRB     r2,[r3,#0]
;;;956        OSPrioHighRdy = 0;
000020  4b06              LDR      r3,|L19.60|
000022  701a              STRB     r2,[r3,#0]
;;;957    
;;;958        OSTCBHighRdy  = (OS_TCB *)0;
000024  4b06              LDR      r3,|L19.64|
000026  601a              STR      r2,[r3,#0]  ; OSTCBHighRdy
;;;959        OSTCBCur      = (OS_TCB *)0;
000028  4b06              LDR      r3,|L19.68|
00002a  601a              STR      r2,[r3,#0]  ; OSTCBCur
;;;960    }
00002c  4770              BX       lr
;;;961    
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      OSRdyGrp
                  |L19.52|
                          DCD      OSRdyTbl
                  |L19.56|
                          DCD      OSPrioCur
                  |L19.60|
                          DCD      OSPrioHighRdy
                  |L19.64|
                          DCD      OSTCBHighRdy
                  |L19.68|
                          DCD      OSTCBCur

                          AREA ||i.OS_InitTCBList||, CODE, READONLY, ALIGN=2

                  OS_InitTCBList PROC
;;;1107   
;;;1108   static  void  OS_InitTCBList (void)
000000  b530              PUSH     {r4,r5,lr}
;;;1109   {
;;;1110       INT8U    i;
;;;1111       OS_TCB  *ptcb1;
;;;1112       OS_TCB  *ptcb2;
;;;1113   
;;;1114   
;;;1115       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000002  f44f61c6          MOV      r1,#0x630
000006  4814              LDR      r0,|L20.88|
000008  f7fffffe          BL       OS_MemClr
;;;1116       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00000c  f44f7180          MOV      r1,#0x100
000010  4812              LDR      r0,|L20.92|
000012  f7fffffe          BL       OS_MemClr
;;;1117       ptcb1 = &OSTCBTbl[0];
000016  4b10              LDR      r3,|L20.88|
;;;1118       ptcb2 = &OSTCBTbl[1];
000018  f1030558          ADD      r5,r3,#0x58
;;;1119       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
00001c  2400              MOVS     r4,#0
00001e  e00a              B        |L20.54|
                  |L20.32|
;;;1120           ptcb1->OSTCBNext = ptcb2;
000020  615d              STR      r5,[r3,#0x14]
;;;1121   #if OS_TASK_NAME_SIZE > 1
;;;1122           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
000022  203f              MOVS     r0,#0x3f
000024  f8830048          STRB     r0,[r3,#0x48]
;;;1123           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
000028  2100              MOVS     r1,#0
00002a  2049              MOVS     r0,#0x49
00002c  54c1              STRB     r1,[r0,r3]
;;;1124   #endif
;;;1125           ptcb1++;
00002e  3358              ADDS     r3,r3,#0x58
;;;1126           ptcb2++;
000030  3558              ADDS     r5,r5,#0x58
000032  1c60              ADDS     r0,r4,#1              ;1119
000034  b2c4              UXTB     r4,r0                 ;1119
                  |L20.54|
000036  2c11              CMP      r4,#0x11              ;1119
000038  d3f2              BCC      |L20.32|
;;;1127       }
;;;1128       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
00003a  2000              MOVS     r0,#0
00003c  6158              STR      r0,[r3,#0x14]
;;;1129   #if OS_TASK_NAME_SIZE > 1
;;;1130       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
00003e  203f              MOVS     r0,#0x3f
000040  f8830048          STRB     r0,[r3,#0x48]
;;;1131       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
000044  2100              MOVS     r1,#0
000046  2049              MOVS     r0,#0x49
000048  54c1              STRB     r1,[r0,r3]
;;;1132   #endif
;;;1133       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00004a  2000              MOVS     r0,#0
00004c  4904              LDR      r1,|L20.96|
00004e  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1134       OSTCBFreeList           = &OSTCBTbl[0];
000050  4801              LDR      r0,|L20.88|
000052  4904              LDR      r1,|L20.100|
000054  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1135   }
000056  bd30              POP      {r4,r5,pc}
;;;1136   /*$PAGE*/
                          ENDP

                  |L20.88|
                          DCD      OSTCBTbl
                  |L20.92|
                          DCD      OSTCBPrioTbl
                  |L20.96|
                          DCD      OSTCBList
                  |L20.100|
                          DCD      OSTCBFreeList

                          AREA ||i.OS_InitTaskIdle||, CODE, READONLY, ALIGN=2

                  OS_InitTaskIdle PROC
;;;975    
;;;976    static  void  OS_InitTaskIdle (void)
000000  b500              PUSH     {lr}
;;;977    {
000002  b087              SUB      sp,sp,#0x1c
;;;978    #if OS_TASK_NAME_SIZE > 7
;;;979        INT8U  err;
;;;980    #endif
;;;981    
;;;982    
;;;983    #if OS_TASK_CREATE_EXT_EN > 0
;;;984    #if OS_STK_GROWTH == 1
;;;985        (void)OSTaskCreateExt(OS_TaskIdle,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L21.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70ff          MOV      r0,#0xffff
000018  233f              MOVS     r3,#0x3f
00001a  4a07              LDR      r2,|L21.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L21.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;986                              (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;987                              &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;988                              OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;989                              OS_TASK_IDLE_ID,
;;;990                              &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;991                              OS_TASK_IDLE_STK_SIZE,
;;;992                              (void *)0,                                 /* No TCB extension                     */
;;;993                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;994    #else
;;;995        (void)OSTaskCreateExt(OS_TaskIdle,
;;;996                              (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;997                              &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;998                              OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;999                              OS_TASK_IDLE_ID,
;;;1000                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1001                             OS_TASK_IDLE_STK_SIZE,
;;;1002                             (void *)0,                                 /* No TCB extension                     */
;;;1003                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1004   #endif
;;;1005   #else
;;;1006   #if OS_STK_GROWTH == 1
;;;1007       (void)OSTaskCreate(OS_TaskIdle,
;;;1008                          (void *)0,
;;;1009                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1010                          OS_TASK_IDLE_PRIO);
;;;1011   #else
;;;1012       (void)OSTaskCreate(OS_TaskIdle,
;;;1013                          (void *)0,
;;;1014                          &OSTaskIdleStk[0],
;;;1015                          OS_TASK_IDLE_PRIO);
;;;1016   #endif
;;;1017   #endif
;;;1018   
;;;1019   #if OS_TASK_NAME_SIZE > 14
;;;1020       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L21.64|
000028  203f              MOVS     r0,#0x3f
00002a  f7fffffe          BL       OSTaskNameSet
;;;1021   #else
;;;1022   #if OS_TASK_NAME_SIZE > 7
;;;1023       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1024   #endif
;;;1025   #endif
;;;1026   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1027   /*$PAGE*/
                          ENDP

000032  0000              DCW      0x0000
                  |L21.52|
                          DCD      OSTaskIdleStk
                  |L21.56|
                          DCD      OSTaskIdleStk+0x1fc
                  |L21.60|
                          DCD      OS_TaskIdle
                  |L21.64|
000040  75432f4f          DCB      "uC/OS-II Idle",0
000044  532d4949
000048  2049646c
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_InitTaskStat||, CODE, READONLY, ALIGN=2

                  OS_InitTaskStat PROC
;;;1041   #if OS_TASK_STAT_EN > 0
;;;1042   static  void  OS_InitTaskStat (void)
000000  b500              PUSH     {lr}
;;;1043   {
000002  b087              SUB      sp,sp,#0x1c
;;;1044   #if OS_TASK_NAME_SIZE > 7
;;;1045       INT8U  err;
;;;1046   #endif
;;;1047   
;;;1048   
;;;1049   #if OS_TASK_CREATE_EXT_EN > 0
;;;1050   #if OS_STK_GROWTH == 1
;;;1051       (void)OSTaskCreateExt(OS_TaskStat,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L22.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fe          MOV      r0,#0xfffe
000018  233e              MOVS     r3,#0x3e
00001a  4a07              LDR      r2,|L22.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L22.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1052                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1053                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
;;;1054                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1055                             OS_TASK_STAT_ID,
;;;1056                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1057                             OS_TASK_STAT_STK_SIZE,
;;;1058                             (void *)0,                                   /* No TCB extension               */
;;;1059                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1060   #else
;;;1061       (void)OSTaskCreateExt(OS_TaskStat,
;;;1062                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1063                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1064                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1065                             OS_TASK_STAT_ID,
;;;1066                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
;;;1067                             OS_TASK_STAT_STK_SIZE,
;;;1068                             (void *)0,                                   /* No TCB extension               */
;;;1069                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1070   #endif
;;;1071   #else
;;;1072   #if OS_STK_GROWTH == 1
;;;1073       (void)OSTaskCreate(OS_TaskStat,
;;;1074                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1075                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
;;;1076                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1077   #else
;;;1078       (void)OSTaskCreate(OS_TaskStat,
;;;1079                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1080                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1081                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1082   #endif
;;;1083   #endif
;;;1084   
;;;1085   #if OS_TASK_NAME_SIZE > 14
;;;1086       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L22.64|
000028  203e              MOVS     r0,#0x3e
00002a  f7fffffe          BL       OSTaskNameSet
;;;1087   #else
;;;1088   #if OS_TASK_NAME_SIZE > 7
;;;1089       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
;;;1090   #endif
;;;1091   #endif
;;;1092   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1093   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
                          DCD      OSTaskStatStk
                  |L22.56|
                          DCD      OSTaskStatStk+0x1fc
                  |L22.60|
                          DCD      OS_TaskStat
                  |L22.64|
000040  75432f4f          DCB      "uC/OS-II Stat",0
000044  532d4949
000048  20537461
00004c  7400    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_MemClr||, CODE, READONLY, ALIGN=1

                  OS_MemClr PROC
;;;1156   
;;;1157   void  OS_MemClr (INT8U *pdest, INT16U size)
000000  e004              B        |L23.12|
                  |L23.2|
;;;1158   {
;;;1159       while (size > 0) {
;;;1160           *pdest++ = (INT8U)0;
000002  2200              MOVS     r2,#0
000004  f8002b01          STRB     r2,[r0],#1
;;;1161           size--;
000008  1e4a              SUBS     r2,r1,#1
00000a  b291              UXTH     r1,r2
                  |L23.12|
00000c  2900              CMP      r1,#0                 ;1159
00000e  dcf8              BGT      |L23.2|
;;;1162       }
;;;1163   }
000010  4770              BX       lr
;;;1164   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_MemCopy||, CODE, READONLY, ALIGN=1

                  OS_MemCopy PROC
;;;1188   
;;;1189   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
000000  e005              B        |L24.14|
                  |L24.2|
;;;1190   {
;;;1191       while (size > 0) {
;;;1192           *pdest++ = *psrc++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
;;;1193           size--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b29a              UXTH     r2,r3
                  |L24.14|
00000e  2a00              CMP      r2,#0                 ;1191
000010  dcf7              BGT      |L24.2|
;;;1194       }
;;;1195   }
000012  4770              BX       lr
;;;1196   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_Sched||, CODE, READONLY, ALIGN=2

                  OS_Sched PROC
;;;1213   
;;;1214   void  OS_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;1215   {
;;;1216   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1217       OS_CPU_SR  cpu_sr = 0;
000002  2400              MOVS     r4,#0
;;;1218   #endif
;;;1219   
;;;1220   
;;;1221   
;;;1222       OS_ENTER_CRITICAL();  //保存全局中断标志,关中断
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1223       if(OSIntNesting==0) { /* Schedule only if all ISRs done and ...*/
00000a  4813              LDR      r0,|L25.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b9f0              CBNZ     r0,|L25.78|
;;;1224           if(OSLockNesting==0) { /* ... scheduler is not locked */
000010  4812              LDR      r0,|L25.92|
000012  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000014  b9d8              CBNZ     r0,|L25.78|
;;;1225               OS_SchedNew(); //计算就绪任务里优先级最高的优先级,结果保存在OSPrioHighRdy里
000016  f7fffffe          BL       OS_SchedNew
;;;1226               if(OSPrioHighRdy!=OSPrioCur) { /* No Ctx Sw if current task is highest rdy  */
00001a  4811              LDR      r0,|L25.96|
00001c  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00001e  4911              LDR      r1,|L25.100|
000020  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000022  4288              CMP      r0,r1
000024  d013              BEQ      |L25.78|
;;;1227                   OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000026  4810              LDR      r0,|L25.104|
000028  490d              LDR      r1,|L25.96|
00002a  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00002c  f8500021          LDR      r0,[r0,r1,LSL #2]
000030  490e              LDR      r1,|L25.108|
000032  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1228   #if OS_TASK_PROFILE_EN > 0
;;;1229                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task */
000034  4608              MOV      r0,r1
000036  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000038  6b40              LDR      r0,[r0,#0x34]
00003a  1c40              ADDS     r0,r0,#1
00003c  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
00003e  6348              STR      r0,[r1,#0x34]
;;;1230   #endif
;;;1231                   OSCtxSwCtr++;   /* Increment context switch counter */
000040  480b              LDR      r0,|L25.112|
000042  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000044  1c40              ADDS     r0,r0,#1
000046  490a              LDR      r1,|L25.112|
000048  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1232                   OS_TASK_SW();   //悬起PSV异常   /* Perform a context switch */
00004a  f7fffffe          BL       OSCtxSw
                  |L25.78|
;;;1233               }
;;;1234           }
;;;1235       }
;;;1236       OS_EXIT_CRITICAL(); //恢复全局中断标志
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       OS_CPU_SR_Restore
;;;1237   }
000054  bd10              POP      {r4,pc}
;;;1238   
                          ENDP

000056  0000              DCW      0x0000
                  |L25.88|
                          DCD      OSIntNesting
                  |L25.92|
                          DCD      OSLockNesting
                  |L25.96|
                          DCD      OSPrioHighRdy
                  |L25.100|
                          DCD      OSPrioCur
                  |L25.104|
                          DCD      OSTCBPrioTbl
                  |L25.108|
                          DCD      OSTCBHighRdy
                  |L25.112|
                          DCD      OSCtxSwCtr

                          AREA ||i.OS_SchedNew||, CODE, READONLY, ALIGN=2

                  OS_SchedNew PROC
;;;1255   
;;;1256   static  void  OS_SchedNew (void)
000000  4906              LDR      r1,|L26.28|
;;;1257   {
;;;1258   #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
;;;1259       INT8U   y;
;;;1260   
;;;1261       y = OSUnMapTbl[OSRdyGrp];
000002  4a07              LDR      r2,|L26.32|
000004  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000006  5c88              LDRB     r0,[r1,r2]
;;;1262       OSPrioHighRdy = (INT8U)((y<<3)+OSUnMapTbl[OSRdyTbl[y]]);
000008  4906              LDR      r1,|L26.36|
00000a  5c09              LDRB     r1,[r1,r0]
00000c  4a03              LDR      r2,|L26.28|
00000e  5c51              LDRB     r1,[r2,r1]
000010  eb0101c0          ADD      r1,r1,r0,LSL #3
000014  4a04              LDR      r2,|L26.40|
000016  7011              STRB     r1,[r2,#0]
;;;1263   #else                                            /* We support up to 256 tasks                         */
;;;1264       INT8U   y;
;;;1265       INT16U *ptbl;
;;;1266   
;;;1267       if((OSRdyGrp&0xFF)!=0) {
;;;1268           y = OSUnMapTbl[OSRdyGrp&0xFF];
;;;1269       } else {
;;;1270           y = OSUnMapTbl[(OSRdyGrp>>8)&0xFF]+8;
;;;1271       }
;;;1272       ptbl = &OSRdyTbl[y];
;;;1273       if((*ptbl&0xFF)!=0) {
;;;1274           OSPrioHighRdy = (INT8U)((y<<4)+OSUnMapTbl[(*ptbl&0xFF)]);
;;;1275       } else {
;;;1276           OSPrioHighRdy = (INT8U)((y<<4)+OSUnMapTbl[(*ptbl>>8)&0xFF]+8);
;;;1277       }
;;;1278   #endif
;;;1279   }
000018  4770              BX       lr
;;;1280   
                          ENDP

00001a  0000              DCW      0x0000
                  |L26.28|
                          DCD      OSUnMapTbl
                  |L26.32|
                          DCD      OSRdyGrp
                  |L26.36|
                          DCD      OSRdyTbl
                  |L26.40|
                          DCD      OSPrioHighRdy

                          AREA ||i.OS_StrCopy||, CODE, READONLY, ALIGN=1

                  OS_StrCopy PROC
;;;1301   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1302   INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
000000  4602              MOV      r2,r0
;;;1303   {
;;;1304       INT8U  len;
;;;1305   
;;;1306   
;;;1307       len = 0;
000002  2000              MOVS     r0,#0
;;;1308       while (*psrc != OS_ASCII_NUL) {
000004  e005              B        |L27.18|
                  |L27.6|
;;;1309           *pdest++ = *psrc++;
000006  f8113b01          LDRB     r3,[r1],#1
00000a  f8023b01          STRB     r3,[r2],#1
;;;1310           len++;
00000e  1c43              ADDS     r3,r0,#1
000010  b2d8              UXTB     r0,r3
                  |L27.18|
000012  780b              LDRB     r3,[r1,#0]            ;1308
000014  2b00              CMP      r3,#0                 ;1308
000016  d1f6              BNE      |L27.6|
;;;1311       }
;;;1312       *pdest = OS_ASCII_NUL;
000018  7013              STRB     r3,[r2,#0]
;;;1313       return (len);
;;;1314   }
00001a  4770              BX       lr
;;;1315   #endif
                          ENDP


                          AREA ||i.OS_StrLen||, CODE, READONLY, ALIGN=1

                  OS_StrLen PROC
;;;1333   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1334   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1335   {
;;;1336       INT8U  len;
;;;1337   
;;;1338   
;;;1339       len = 0;
000002  2000              MOVS     r0,#0
;;;1340       while (*psrc != OS_ASCII_NUL) {
000004  e002              B        |L28.12|
                  |L28.6|
;;;1341           psrc++;
000006  1c49              ADDS     r1,r1,#1
;;;1342           len++;
000008  1c42              ADDS     r2,r0,#1
00000a  b2d0              UXTB     r0,r2
                  |L28.12|
00000c  780a              LDRB     r2,[r1,#0]            ;1340
00000e  2a00              CMP      r2,#0                 ;1340
000010  d1f9              BNE      |L28.6|
;;;1343       }
;;;1344       return (len);
;;;1345   }
000012  4770              BX       lr
;;;1346   #endif
                          ENDP


                          AREA ||i.OS_TCBInit||, CODE, READONLY, ALIGN=2

                  OS_TCBInit PROC
;;;1535   
;;;1536   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1537   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
;;;1538       OS_TCB    *ptcb;
;;;1539   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1540       OS_CPU_SR  cpu_sr = 0;
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
;;;1541   #endif
;;;1542   
;;;1543   
;;;1544   
;;;1545       OS_ENTER_CRITICAL();
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  9000              STR      r0,[sp,#0]
;;;1546       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001e  483d              LDR      r0,|L29.276|
000020  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1547       if (ptcb != (OS_TCB *)0) {
000022  2c00              CMP      r4,#0
000024  d071              BEQ      |L29.266|
;;;1548           OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
000026  f8540f14          LDR      r0,[r4,#0x14]!
00002a  493a              LDR      r1,|L29.276|
00002c  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1549           OS_EXIT_CRITICAL();
00002e  9800              LDR      r0,[sp,#0]
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;1550           ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
000034  f8446c14          STR      r6,[r4,#-0x14]
;;;1551           ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
000038  76a5              STRB     r5,[r4,#0x1a]
;;;1552           ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
00003a  2000              MOVS     r0,#0
00003c  7620              STRB     r0,[r4,#0x18]
;;;1553           ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;            /* Clear pend status                        */
00003e  7660              STRB     r0,[r4,#0x19]
;;;1554           ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
000040  82e0              STRH     r0,[r4,#0x16]
;;;1555   
;;;1556   #if OS_TASK_CREATE_EXT_EN > 0
;;;1557           ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
000042  f844ac10          STR      r10,[r4,#-0x10]
;;;1558           ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
000046  f8449c08          STR      r9,[r4,#-8]
;;;1559           ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
00004a  f8447c0c          STR      r7,[r4,#-0xc]
;;;1560           ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
00004e  f824bc04          STRH     r11,[r4,#-4]
;;;1561           ptcb->OSTCBId        = id;                         /* Store task ID                            */
000052  f8248c02          STRH     r8,[r4,#-2]
;;;1562   #else
;;;1563           pext                 = pext;                       /* Prevent compiler warning if not used     */
;;;1564           stk_size             = stk_size;
;;;1565           pbos                 = pbos;
;;;1566           opt                  = opt;
;;;1567           id                   = id;
;;;1568   #endif
;;;1569   
;;;1570   #if OS_TASK_DEL_EN > 0
;;;1571           ptcb->OSTCBDelReq    = OS_ERR_NONE;
000056  77e0              STRB     r0,[r4,#0x1f]
;;;1572   #endif
;;;1573   
;;;1574   #if OS_LOWEST_PRIO <= 63
;;;1575           ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
000058  10e8              ASRS     r0,r5,#3
00005a  7720              STRB     r0,[r4,#0x1c]
;;;1576           ptcb->OSTCBBitY      = (INT8U)(1 << ptcb->OSTCBY);
00005c  7f21              LDRB     r1,[r4,#0x1c]
00005e  2001              MOVS     r0,#1
000060  4088              LSLS     r0,r0,r1
000062  77a0              STRB     r0,[r4,#0x1e]
;;;1577           ptcb->OSTCBX         = (INT8U)(prio & 0x07);
000064  f0050007          AND      r0,r5,#7
000068  76e0              STRB     r0,[r4,#0x1b]
;;;1578           ptcb->OSTCBBitX      = (INT8U)(1 << ptcb->OSTCBX);
00006a  7ee1              LDRB     r1,[r4,#0x1b]
00006c  2001              MOVS     r0,#1
00006e  4088              LSLS     r0,r0,r1
000070  7760              STRB     r0,[r4,#0x1d]
;;;1579   #else
;;;1580           ptcb->OSTCBY         = (INT8U)((prio >> 4) & 0xFF);/* Pre-compute X, Y, BitX and BitY          */
;;;1581           ptcb->OSTCBBitY      = (INT16U)(1 << ptcb->OSTCBY);
;;;1582           ptcb->OSTCBX         = (INT8U)(prio & 0x0F);
;;;1583           ptcb->OSTCBBitX      = (INT16U)(1 << ptcb->OSTCBX);
;;;1584   #endif
;;;1585   
;;;1586   #if OS_EVENT_EN
;;;1587           ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
000072  2000              MOVS     r0,#0
000074  60a0              STR      r0,[r4,#8]
;;;1588   #endif
;;;1589   
;;;1590   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1591           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000076  6120              STR      r0,[r4,#0x10]
;;;1592   #endif
;;;1593   
;;;1594   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1595           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
000078  60e0              STR      r0,[r4,#0xc]
;;;1596   #endif
;;;1597   
;;;1598   #if OS_TASK_PROFILE_EN > 0
;;;1599           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
00007a  6220              STR      r0,[r4,#0x20]
;;;1600           ptcb->OSTCBCyclesStart = 0L;
00007c  62a0              STR      r0,[r4,#0x28]
;;;1601           ptcb->OSTCBCyclesTot   = 0L;
00007e  6260              STR      r0,[r4,#0x24]
;;;1602           ptcb->OSTCBStkBase     = (OS_STK *)0;
000080  62e0              STR      r0,[r4,#0x2c]
;;;1603           ptcb->OSTCBStkUsed     = 0L;
000082  6320              STR      r0,[r4,#0x30]
;;;1604   #endif
;;;1605   
;;;1606   #if OS_TASK_NAME_SIZE > 1
;;;1607           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
000084  203f              MOVS     r0,#0x3f
000086  f8840034          STRB     r0,[r4,#0x34]
00008a  f1a40414          SUB      r4,r4,#0x14
;;;1608           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
00008e  f04f0100          MOV      r1,#0
000092  f04f0049          MOV      r0,#0x49
000096  5501              STRB     r1,[r0,r4]
;;;1609   #endif
;;;1610   
;;;1611           OSTCBInitHook(ptcb);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       OSTCBInitHook
;;;1612   
;;;1613           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       OSTaskCreateHook
;;;1614   
;;;1615           OS_ENTER_CRITICAL();
0000a4  f7fffffe          BL       OS_CPU_SR_Save
0000a8  9000              STR      r0,[sp,#0]
;;;1616           OSTCBPrioTbl[prio] = ptcb;
0000aa  481b              LDR      r0,|L29.280|
0000ac  f8404025          STR      r4,[r0,r5,LSL #2]
;;;1617           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0000b0  481a              LDR      r0,|L29.284|
0000b2  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000b4  6160              STR      r0,[r4,#0x14]
;;;1618           ptcb->OSTCBPrev    = (OS_TCB *)0;
0000b6  2000              MOVS     r0,#0
0000b8  61a0              STR      r0,[r4,#0x18]
;;;1619           if (OSTCBList != (OS_TCB *)0) {
0000ba  4818              LDR      r0,|L29.284|
0000bc  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000be  b110              CBZ      r0,|L29.198|
;;;1620               OSTCBList->OSTCBPrev = ptcb;
0000c0  4816              LDR      r0,|L29.284|
0000c2  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000c4  6184              STR      r4,[r0,#0x18]
                  |L29.198|
;;;1621           }
;;;1622           OSTCBList               = ptcb;
0000c6  4815              LDR      r0,|L29.284|
0000c8  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;1623           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0000ca  f1040430          ADD      r4,r4,#0x30
0000ce  78a0              LDRB     r0,[r4,#2]
0000d0  4913              LDR      r1,|L29.288|
0000d2  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
0000d4  ea400001          ORR      r0,r0,r1
0000d8  4911              LDR      r1,|L29.288|
0000da  7008              STRB     r0,[r1,#0]
;;;1624           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000dc  7820              LDRB     r0,[r4,#0]
0000de  4911              LDR      r1,|L29.292|
0000e0  5c08              LDRB     r0,[r1,r0]
0000e2  7861              LDRB     r1,[r4,#1]
0000e4  ea400001          ORR      r0,r0,r1
0000e8  f8141930          LDRB     r1,[r4],#-0x30
0000ec  4a0d              LDR      r2,|L29.292|
0000ee  5450              STRB     r0,[r2,r1]
;;;1625           OSTaskCtr++;                                       /* Increment the #tasks counter             */
0000f0  480d              LDR      r0,|L29.296|
0000f2  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
0000f4  f1000001          ADD      r0,r0,#1
0000f8  490b              LDR      r1,|L29.296|
0000fa  7008              STRB     r0,[r1,#0]
;;;1626           OS_EXIT_CRITICAL();
0000fc  9800              LDR      r0,[sp,#0]
0000fe  f7fffffe          BL       OS_CPU_SR_Restore
;;;1627           return (OS_ERR_NONE);
000102  2000              MOVS     r0,#0
                  |L29.260|
;;;1628       }
;;;1629       OS_EXIT_CRITICAL();
;;;1630       return (OS_ERR_TASK_NO_MORE_TCB);
;;;1631   }
000104  e8bd8ff8          POP      {r3-r11,pc}
000108  e7ff              B        |L29.266|
                  |L29.266|
00010a  9800              LDR      r0,[sp,#0]            ;1629
00010c  f7fffffe          BL       OS_CPU_SR_Restore
000110  2042              MOVS     r0,#0x42              ;1630
000112  e7f7              B        |L29.260|
                          ENDP

                  |L29.276|
                          DCD      OSTCBFreeList
                  |L29.280|
                          DCD      OSTCBPrioTbl
                  |L29.284|
                          DCD      OSTCBList
                  |L29.288|
                          DCD      OSRdyGrp
                  |L29.292|
                          DCD      OSRdyTbl
                  |L29.296|
                          DCD      OSTaskCtr

                          AREA ||i.OS_TaskIdle||, CODE, READONLY, ALIGN=2

                  OS_TaskIdle PROC
;;;1368   
;;;1369   void  OS_TaskIdle (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1370   {
;;;1371   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1372       OS_CPU_SR  cpu_sr = 0;
;;;1373   #endif
;;;1374   
;;;1375       (void)p_arg;                                 /* Prevent compiler warning for not using 'parg'      */
;;;1376       for(;;) {
000002  bf00              NOP      
                  |L30.4|
;;;1377           OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1378           OSIdleCtr++;
00000a  4805              LDR      r0,|L30.32|
00000c  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00000e  1c40              ADDS     r0,r0,#1
000010  4903              LDR      r1,|L30.32|
000012  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1379           OS_EXIT_CRITICAL();
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       OS_CPU_SR_Restore
;;;1380           OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001a  f7fffffe          BL       OSTaskIdleHook
00001e  e7f1              B        |L30.4|
;;;1381       }
;;;1382   }
;;;1383   /*$PAGE*/
                          ENDP

                  |L30.32|
                          DCD      OSIdleCtr

                          AREA ||i.OS_TaskStat||, CODE, READONLY, ALIGN=2

                  OS_TaskStat PROC
;;;1408   #if OS_TASK_STAT_EN > 0
;;;1409   void  OS_TaskStat (void *p_arg)
000000  2700              MOVS     r7,#0
;;;1410   {
;;;1411       INT32U     run;
;;;1412       INT32U     max;
;;;1413       INT8S      usage;
;;;1414   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1415       OS_CPU_SR  cpu_sr = 0;
;;;1416   #endif
;;;1417   
;;;1418   
;;;1419   
;;;1420       p_arg = p_arg;                               /* Prevent compiler warning for not using 'parg'      */
000002  bf00              NOP      
;;;1421       while (OSStatRdy == OS_FALSE) {
000004  e002              B        |L31.12|
                  |L31.6|
;;;1422           OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
000006  20c8              MOVS     r0,#0xc8
000008  f7fffffe          BL       OSTimeDly
                  |L31.12|
00000c  481b              LDR      r0,|L31.124|
00000e  7800              LDRB     r0,[r0,#0]            ;1421  ; OSStatRdy
000010  2800              CMP      r0,#0                 ;1421
000012  d0f8              BEQ      |L31.6|
;;;1423       }
;;;1424       max = OSIdleCtrMax / 100L;
000014  481a              LDR      r0,|L31.128|
000016  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000018  2164              MOVS     r1,#0x64
00001a  fbb0f4f1          UDIV     r4,r0,r1
;;;1425       for (;;) {
00001e  bf00              NOP      
                  |L31.32|
;;;1426           OS_ENTER_CRITICAL();
000020  f7fffffe          BL       OS_CPU_SR_Save
000024  4607              MOV      r7,r0
;;;1427           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
000026  4817              LDR      r0,|L31.132|
000028  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00002a  4917              LDR      r1,|L31.136|
00002c  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1428           run          = OSIdleCtr;
00002e  4815              LDR      r0,|L31.132|
000030  6806              LDR      r6,[r0,#0]  ; OSIdleCtr
;;;1429           OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
000032  2000              MOVS     r0,#0
000034  4913              LDR      r1,|L31.132|
000036  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1430           OS_EXIT_CRITICAL();
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       OS_CPU_SR_Restore
;;;1431           if (max > 0L) {
00003e  b16c              CBZ      r4,|L31.92|
;;;1432               usage = (INT8S)(100L - run / max);
000040  fbb6f0f4          UDIV     r0,r6,r4
000044  f1c00064          RSB      r0,r0,#0x64
000048  b245              SXTB     r5,r0
;;;1433               if (usage >= 0) {                    /* Make sure we don't have a negative percentage      */
00004a  2d00              CMP      r5,#0
00004c  db02              BLT      |L31.84|
;;;1434                   OSCPUUsage = usage;
00004e  480f              LDR      r0,|L31.140|
000050  7005              STRB     r5,[r0,#0]
000052  e00b              B        |L31.108|
                  |L31.84|
;;;1435               } else {
;;;1436                   OSCPUUsage = 0;
000054  2000              MOVS     r0,#0
000056  490d              LDR      r1,|L31.140|
000058  7008              STRB     r0,[r1,#0]
00005a  e007              B        |L31.108|
                  |L31.92|
;;;1437               }
;;;1438           } else {
;;;1439               OSCPUUsage = 0;
00005c  2000              MOVS     r0,#0
00005e  490b              LDR      r1,|L31.140|
000060  7008              STRB     r0,[r1,#0]
;;;1440               max        = OSIdleCtrMax / 100L;
000062  4807              LDR      r0,|L31.128|
000064  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000066  2164              MOVS     r1,#0x64
000068  fbb0f4f1          UDIV     r4,r0,r1
                  |L31.108|
;;;1441           }
;;;1442           OSTaskStatHook();                        /* Invoke user definable hook                         */
00006c  f7fffffe          BL       OSTaskStatHook
;;;1443   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1444           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000070  f7fffffe          BL       OS_TaskStatStkChk
;;;1445   #endif
;;;1446           OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
000074  2064              MOVS     r0,#0x64
000076  f7fffffe          BL       OSTimeDly
00007a  e7d1              B        |L31.32|
;;;1447       }
;;;1448   }
;;;1449   #endif
                          ENDP

                  |L31.124|
                          DCD      OSStatRdy
                  |L31.128|
                          DCD      OSIdleCtrMax
                  |L31.132|
                          DCD      OSIdleCtr
                  |L31.136|
                          DCD      OSIdleCtrRun
                  |L31.140|
                          DCD      OSCPUUsage

                          AREA ||i.OS_TaskStatStkChk||, CODE, READONLY, ALIGN=2

                  OS_TaskStatStkChk PROC
;;;1463   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1464   void  OS_TaskStatStkChk (void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1465   {
;;;1466       OS_TCB      *ptcb;
;;;1467       OS_STK_DATA  stk_data;
;;;1468       INT8U        err;
;;;1469       INT8U        prio;
;;;1470   
;;;1471   
;;;1472       for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
000002  2500              MOVS     r5,#0
000004  e014              B        |L32.48|
                  |L32.6|
;;;1473           err = OSTaskStkChk(prio, &stk_data);
000006  4669              MOV      r1,sp
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       OSTaskStkChk
00000e  4606              MOV      r6,r0
;;;1474           if (err == OS_ERR_NONE) {
000010  b966              CBNZ     r6,|L32.44|
;;;1475               ptcb = OSTCBPrioTbl[prio];
000012  4809              LDR      r0,|L32.56|
000014  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1476               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000018  b144              CBZ      r4,|L32.44|
;;;1477                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001a  2c01              CMP      r4,#1
00001c  d006              BEQ      |L32.44|
;;;1478   #if OS_TASK_PROFILE_EN > 0
;;;1479   #if OS_STK_GROWTH == 1
;;;1480                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001e  e9d40102          LDRD     r0,r1,[r4,#8]
000022  eb000081          ADD      r0,r0,r1,LSL #2
000026  6420              STR      r0,[r4,#0x40]
;;;1481   #else
;;;1482                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1483   #endif
;;;1484                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000028  9801              LDR      r0,[sp,#4]
00002a  6460              STR      r0,[r4,#0x44]
                  |L32.44|
00002c  1c68              ADDS     r0,r5,#1              ;1472
00002e  b2c5              UXTB     r5,r0                 ;1472
                  |L32.48|
000030  2d3f              CMP      r5,#0x3f              ;1472
000032  dde8              BLE      |L32.6|
;;;1485   #endif
;;;1486                   }
;;;1487               }
;;;1488           }
;;;1489       }
;;;1490   }
000034  bd7c              POP      {r2-r6,pc}
;;;1491   #endif
                          ENDP

000036  0000              DCW      0x0000
                  |L32.56|
                          DCD      OSTCBPrioTbl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        360
                  OSFlagTbl
                          %        140
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        256
                  OSTCBTbl
                          %        1584
                  OSMemTbl
                          %        180
                  OSQTbl
                          %        96
                  OSTmrTbl
                          %        832
                  OSTmrTaskStk
                          %        512
                  OSTmrWheelTbl
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
                          DCD      0x00000000
000024  0000              DCB      0x00,0x00
                  OSRunning
000026  00                DCB      0x00
                  OSTaskCtr
000027  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
00003c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSMemFreeList
                          DCD      0x00000000
                  OSQFreeList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000
                  OSTmrFree
00004c  0000              DCB      0x00,0x00
                  OSTmrUsed
00004e  0000              DCB      0x00,0x00
                  OSTmrTime
                          DCD      0x00000000
                  OSTmrSem
                          DCD      0x00000000
                  OSTmrSemSignal
                          DCD      0x00000000
                  OSTmrFreeList
                          DCD      0x00000000
