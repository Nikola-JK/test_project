; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usart_printf.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\usart_printf.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\usart_printf.crf Source\APP\usart_printf.c]
                          THUMB

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;33     */
;;;34     void USART_Configuration(void)
000000  b500              PUSH     {lr}
;;;35     {
000002  b085              SUB      sp,sp,#0x14
;;;36     	GPIO_InitTypeDef GPIO_InitStructure;
;;;37     	USART_InitTypeDef USART_InitStructure;
;;;38     
;;;39     // 配置USART1
;;;40     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;41     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;42     		/* 将USART1 Tx的GPIO配置为推挽复用模式 */
;;;43     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;44     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;45     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;46     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  4843              LDR      r0,|L1.312|
00002c  f7fffffe          BL       GPIO_Init
;;;47     	/*将USART1 Rx的GPIO配置为浮空输入模式
;;;48     		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;49     		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;50     	*/
;;;51     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;52     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;53     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  483d              LDR      r0,|L1.312|
000042  f7fffffe          BL       GPIO_Init
;;;54     	
;;;55     	USART_InitStructure.USART_BaudRate = 9600;
000046  f44f5016          MOV      r0,#0x2580
00004a  9000              STR      r0,[sp,#0]
;;;56     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;57     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;58     	USART_InitStructure.USART_Parity = USART_Parity_No;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;59     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;60     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;61     	USART_Init(USART1, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  4835              LDR      r0,|L1.316|
000068  f7fffffe          BL       USART_Init
;;;62     	/* Enable USART1 Receive and Transmit interrupts */
;;;63       USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
00006c  2201              MOVS     r2,#1
00006e  f2405125          MOV      r1,#0x525
000072  4832              LDR      r0,|L1.316|
000074  f7fffffe          BL       USART_ITConfig
;;;64     	/* 使能 USART， 配置完毕 */
;;;65     	USART_Cmd(USART1, ENABLE);
000078  2101              MOVS     r1,#1
00007a  4830              LDR      r0,|L1.316|
00007c  f7fffffe          BL       USART_Cmd
;;;66     	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;67     		如下语句解决第1个字节无法正确发送出去的问题 */
;;;68     	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000080  2140              MOVS     r1,#0x40
000082  482e              LDR      r0,|L1.316|
000084  f7fffffe          BL       USART_ClearFlag
;;;69     	USART_SendData(USART1,0xaa);
000088  21aa              MOVS     r1,#0xaa
00008a  482c              LDR      r0,|L1.316|
00008c  f7fffffe          BL       USART_SendData
;;;70     	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
000090  bf00              NOP      
                  |L1.146|
000092  2140              MOVS     r1,#0x40
000094  4829              LDR      r0,|L1.316|
000096  f7fffffe          BL       USART_GetFlagStatus
00009a  2800              CMP      r0,#0
00009c  d0f9              BEQ      |L1.146|
;;;71     
;;;72     
;;;73     
;;;74     // 配置USART2
;;;75     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  2005              MOVS     r0,#5
0000a2  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;76       RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
0000a6  2101              MOVS     r1,#1
0000a8  0448              LSLS     r0,r1,#17
0000aa  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;77     	/* 将USART2 Tx的GPIO配置为推挽复用模式 */
;;;78     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
0000ae  2004              MOVS     r0,#4
0000b0  f8ad0010          STRH     r0,[sp,#0x10]
;;;79     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000b4  2018              MOVS     r0,#0x18
0000b6  f88d0013          STRB     r0,[sp,#0x13]
;;;80     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000ba  2003              MOVS     r0,#3
0000bc  f88d0012          STRB     r0,[sp,#0x12]
;;;81     	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000c0  a904              ADD      r1,sp,#0x10
0000c2  481d              LDR      r0,|L1.312|
0000c4  f7fffffe          BL       GPIO_Init
;;;82     	/* 将USART2 Rx的GPIO配置为浮空输入模式
;;;83     		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;84     		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;85     	*/
;;;86     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000c8  2008              MOVS     r0,#8
0000ca  f8ad0010          STRH     r0,[sp,#0x10]
;;;87     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000ce  2004              MOVS     r0,#4
0000d0  f88d0013          STRB     r0,[sp,#0x13]
;;;88     	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000d4  a904              ADD      r1,sp,#0x10
0000d6  4818              LDR      r0,|L1.312|
0000d8  f7fffffe          BL       GPIO_Init
;;;89     	
;;;90     	USART_InitStructure.USART_BaudRate = 9600;
0000dc  f44f5016          MOV      r0,#0x2580
0000e0  9000              STR      r0,[sp,#0]
;;;91     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000e2  2000              MOVS     r0,#0
0000e4  f8ad0004          STRH     r0,[sp,#4]
;;;92     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000e8  f8ad0006          STRH     r0,[sp,#6]
;;;93     	USART_InitStructure.USART_Parity = USART_Parity_No;
0000ec  f8ad0008          STRH     r0,[sp,#8]
;;;94     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000f0  f8ad000c          STRH     r0,[sp,#0xc]
;;;95     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000f4  200c              MOVS     r0,#0xc
0000f6  f8ad000a          STRH     r0,[sp,#0xa]
;;;96     	USART_Init(USART2, &USART_InitStructure);
0000fa  4669              MOV      r1,sp
0000fc  4810              LDR      r0,|L1.320|
0000fe  f7fffffe          BL       USART_Init
;;;97     	/* Enable USART2 Receive and Transmit interrupts */
;;;98       USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000102  2201              MOVS     r2,#1
000104  f2405125          MOV      r1,#0x525
000108  480d              LDR      r0,|L1.320|
00010a  f7fffffe          BL       USART_ITConfig
;;;99     	/* 使能 USART， 配置完毕 */
;;;100    	USART_Cmd(USART2, ENABLE);
00010e  2101              MOVS     r1,#1
000110  480b              LDR      r0,|L1.320|
000112  f7fffffe          BL       USART_Cmd
;;;101    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;102    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;103    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000116  2140              MOVS     r1,#0x40
000118  4809              LDR      r0,|L1.320|
00011a  f7fffffe          BL       USART_ClearFlag
;;;104    	USART_SendData(USART2,0xaa);
00011e  21aa              MOVS     r1,#0xaa
000120  4807              LDR      r0,|L1.320|
000122  f7fffffe          BL       USART_SendData
;;;105    	while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET);
000126  bf00              NOP      
                  |L1.296|
000128  2140              MOVS     r1,#0x40
00012a  4805              LDR      r0,|L1.320|
00012c  f7fffffe          BL       USART_GetFlagStatus
000130  2800              CMP      r0,#0
000132  d0f9              BEQ      |L1.296|
;;;106    
;;;107    #if 0
;;;108    // 配置USART3
;;;109    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;110    	RCC_APB2PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;111    	 /* 将USART3 Tx的GPIO配置为推挽复用模式 */
;;;112    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;113    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;114    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;115    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;116    	/*将USART3 Rx的GPIO配置为浮空输入模式
;;;117    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;118    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;119    	*/
;;;120    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;121    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;122    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;123    
;;;124    	USART_InitStructure.USART_BaudRate = 4800;
;;;125    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;126    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;127    	USART_InitStructure.USART_Parity = USART_Parity_No;
;;;128    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;129    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;130    	USART_Init(USART3, &USART_InitStructure);
;;;131    	/* Enable USART3 Receive and Transmit interrupts */
;;;132      USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
;;;133    	/* 使能 USART， 配置完毕 */
;;;134    	USART_Cmd(USART3, ENABLE);
;;;135    
;;;136    //	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;137    //		如下语句解决第1个字节无法正确发送出去的问题 */
;;;138    //	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;139    //	USART_SendData(USART3,0xaa);
;;;140    //	while (USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET);
;;;141    #endif
;;;142    	
;;;143    	
;;;144    }
000134  b005              ADD      sp,sp,#0x14
000136  bd00              POP      {pc}
;;;145    
                          ENDP

                  |L1.312|
                          DCD      0x40010800
                  |L1.316|
                          DCD      0x40013800
                  |L1.320|
                          DCD      0x40004400

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;169    /// <returns></returns>
;;;170    _sys_exit(int x)
000000  4601              MOV      r1,r0
;;;171    {
;;;172        x = x;
000002  bf00              NOP      
;;;173    }
000004  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;278    */
;;;279    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;280    {
000002  4604              MOV      r4,r0
;;;281        /* 等待串口1输入数据 */
;;;282        while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET) {
000004  bf00              NOP      
                  |L3.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L3.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L3.6|
;;;283        }
;;;284    
;;;285        return (int)USART_ReceiveData(USART1);
000012  4802              LDR      r0,|L3.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;286    }
000018  bd10              POP      {r4,pc}
;;;287    #endif
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;258    */
;;;259    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;260    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;261        /* Place your implementation of fputc here */
;;;262        /* e.g. write a character to the USART */
;;;263        USART_SendData(USART1, (u8) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L4.32|
00000a  f7fffffe          BL       USART_SendData
;;;264    
;;;265        /* Loop until the end of transmission */
;;;266        while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET) {
00000e  bf00              NOP      
                  |L4.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L4.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L4.16|
;;;267        }
;;;268    
;;;269        return ch;
00001c  4620              MOV      r0,r4
;;;270    }
00001e  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP

                  |L4.32|
                          DCD      0x40013800

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
