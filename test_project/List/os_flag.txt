; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_flag.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_flag.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\os_flag.crf Source\uCOS-II\Source\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagAccept||, CODE, READONLY, ALIGN=1

                  OSFlagAccept PROC
;;;91     #if OS_FLAG_ACCEPT_EN > 0
;;;92     OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;93     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;94         OS_FLAGS      flags_rdy;
;;;95         INT8U         result;
;;;96         BOOLEAN       consume;
;;;97     #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;98         OS_CPU_SR     cpu_sr = 0;
00000c  f04f0b00          MOV      r11,#0
;;;99     #endif
;;;100    
;;;101    
;;;102    
;;;103    #if OS_ARG_CHK_EN > 0
;;;104        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
000010  b916              CBNZ     r6,|L1.24|
;;;105            return ((OS_FLAGS)0);
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;106        }
;;;107        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;108            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;109            return ((OS_FLAGS)0);
;;;110        }
;;;111    #endif
;;;112        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;113            *perr = OS_ERR_EVENT_TYPE;
;;;114            return ((OS_FLAGS)0);
;;;115        }
;;;116        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;117        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;118            wait_type &= ~OS_FLAG_CONSUME;
;;;119            consume    = OS_TRUE;
;;;120        } else {
;;;121            consume    = OS_FALSE;
;;;122        }
;;;123        /*$PAGE*/
;;;124        *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
;;;125        OS_ENTER_CRITICAL();
;;;126        switch (wait_type) {
;;;127        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;128            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;129            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;130                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;131                    pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
;;;132                }
;;;133            } else {
;;;134                *perr = OS_ERR_FLAG_NOT_RDY;
;;;135            }
;;;136            OS_EXIT_CRITICAL();
;;;137            break;
;;;138    
;;;139        case OS_FLAG_WAIT_SET_ANY:
;;;140            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;141            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;142                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;143                    pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
;;;144                }
;;;145            } else {
;;;146                *perr = OS_ERR_FLAG_NOT_RDY;
;;;147            }
;;;148            OS_EXIT_CRITICAL();
;;;149            break;
;;;150    
;;;151    #if OS_FLAG_WAIT_CLR_EN > 0
;;;152        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;153            flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
;;;154            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;155                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;156                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;157                }
;;;158            } else {
;;;159                *perr = OS_ERR_FLAG_NOT_RDY;
;;;160            }
;;;161            OS_EXIT_CRITICAL();
;;;162            break;
;;;163    
;;;164        case OS_FLAG_WAIT_CLR_ANY:
;;;165            flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
;;;166            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;167                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;168                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;169                }
;;;170            } else {
;;;171                *perr = OS_ERR_FLAG_NOT_RDY;
;;;172            }
;;;173            OS_EXIT_CRITICAL();
;;;174            break;
;;;175    #endif
;;;176    
;;;177        default:
;;;178            OS_EXIT_CRITICAL();
;;;179            flags_rdy = (OS_FLAGS)0;
;;;180            *perr     = OS_ERR_FLAG_WAIT_TYPE;
;;;181            break;
;;;182        }
;;;183        return (flags_rdy);
;;;184    }
000014  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.24|
000018  b91c              CBNZ     r4,|L1.34|
00001a  206e              MOVS     r0,#0x6e              ;108
00001c  7030              STRB     r0,[r6,#0]            ;108
00001e  2000              MOVS     r0,#0                 ;109
000020  e7f8              B        |L1.20|
                  |L1.34|
000022  7820              LDRB     r0,[r4,#0]            ;112
000024  2805              CMP      r0,#5                 ;112
000026  d003              BEQ      |L1.48|
000028  2001              MOVS     r0,#1                 ;113
00002a  7030              STRB     r0,[r6,#0]            ;113
00002c  2000              MOVS     r0,#0                 ;114
00002e  e7f1              B        |L1.20|
                  |L1.48|
000030  f0090a80          AND      r10,r9,#0x80          ;116
000034  f1ba0f00          CMP      r10,#0                ;117
000038  d004              BEQ      |L1.68|
00003a  f0290980          BIC      r9,r9,#0x80           ;118
00003e  f04f0801          MOV      r8,#1                 ;119
000042  e001              B        |L1.72|
                  |L1.68|
000044  f04f0800          MOV      r8,#0                 ;121
                  |L1.72|
000048  2000              MOVS     r0,#0                 ;124
00004a  7030              STRB     r0,[r6,#0]            ;124
00004c  f7fffffe          BL       OS_CPU_SR_Save
000050  4683              MOV      r11,r0                ;125
000052  f1b90f00          CMP      r9,#0                 ;126
000056  d02c              BEQ      |L1.178|
000058  f1b90f01          CMP      r9,#1                 ;126
00005c  d03b              BEQ      |L1.214|
00005e  f1b90f02          CMP      r9,#2                 ;126
000062  d003              BEQ      |L1.108|
000064  f1b90f03          CMP      r9,#3                 ;126
000068  d146              BNE      |L1.248|
00006a  e011              B        |L1.144|
                  |L1.108|
00006c  8920              LDRH     r0,[r4,#8]            ;128
00006e  ea000507          AND      r5,r0,r7              ;128
000072  42bd              CMP      r5,r7                 ;129
000074  d106              BNE      |L1.132|
000076  f1b80f01          CMP      r8,#1                 ;130
00007a  d105              BNE      |L1.136|
00007c  8920              LDRH     r0,[r4,#8]            ;131
00007e  43a8              BICS     r0,r0,r5              ;131
000080  8120              STRH     r0,[r4,#8]            ;131
000082  e001              B        |L1.136|
                  |L1.132|
000084  2070              MOVS     r0,#0x70              ;134
000086  7030              STRB     r0,[r6,#0]            ;134
                  |L1.136|
000088  4658              MOV      r0,r11                ;136
00008a  f7fffffe          BL       OS_CPU_SR_Restore
00008e  e03a              B        |L1.262|
                  |L1.144|
000090  8920              LDRH     r0,[r4,#8]            ;140
000092  ea000507          AND      r5,r0,r7              ;140
000096  b135              CBZ      r5,|L1.166|
000098  f1b80f01          CMP      r8,#1                 ;142
00009c  d105              BNE      |L1.170|
00009e  8920              LDRH     r0,[r4,#8]            ;143
0000a0  43a8              BICS     r0,r0,r5              ;143
0000a2  8120              STRH     r0,[r4,#8]            ;143
0000a4  e001              B        |L1.170|
                  |L1.166|
0000a6  2070              MOVS     r0,#0x70              ;146
0000a8  7030              STRB     r0,[r6,#0]            ;146
                  |L1.170|
0000aa  4658              MOV      r0,r11                ;148
0000ac  f7fffffe          BL       OS_CPU_SR_Restore
0000b0  e029              B        |L1.262|
                  |L1.178|
0000b2  8920              LDRH     r0,[r4,#8]            ;153
0000b4  ea270500          BIC      r5,r7,r0              ;153
0000b8  42bd              CMP      r5,r7                 ;154
0000ba  d106              BNE      |L1.202|
0000bc  f1b80f01          CMP      r8,#1                 ;155
0000c0  d105              BNE      |L1.206|
0000c2  8920              LDRH     r0,[r4,#8]            ;156
0000c4  4328              ORRS     r0,r0,r5              ;156
0000c6  8120              STRH     r0,[r4,#8]            ;156
0000c8  e001              B        |L1.206|
                  |L1.202|
0000ca  2070              MOVS     r0,#0x70              ;159
0000cc  7030              STRB     r0,[r6,#0]            ;159
                  |L1.206|
0000ce  4658              MOV      r0,r11                ;161
0000d0  f7fffffe          BL       OS_CPU_SR_Restore
0000d4  e017              B        |L1.262|
                  |L1.214|
0000d6  8920              LDRH     r0,[r4,#8]            ;165
0000d8  ea270500          BIC      r5,r7,r0              ;165
0000dc  b135              CBZ      r5,|L1.236|
0000de  f1b80f01          CMP      r8,#1                 ;167
0000e2  d105              BNE      |L1.240|
0000e4  8920              LDRH     r0,[r4,#8]            ;168
0000e6  4328              ORRS     r0,r0,r5              ;168
0000e8  8120              STRH     r0,[r4,#8]            ;168
0000ea  e001              B        |L1.240|
                  |L1.236|
0000ec  2070              MOVS     r0,#0x70              ;171
0000ee  7030              STRB     r0,[r6,#0]            ;171
                  |L1.240|
0000f0  4658              MOV      r0,r11                ;173
0000f2  f7fffffe          BL       OS_CPU_SR_Restore
0000f6  e006              B        |L1.262|
                  |L1.248|
0000f8  4658              MOV      r0,r11                ;178
0000fa  f7fffffe          BL       OS_CPU_SR_Restore
0000fe  2500              MOVS     r5,#0                 ;179
000100  206f              MOVS     r0,#0x6f              ;180
000102  7030              STRB     r0,[r6,#0]            ;180
000104  bf00              NOP                            ;181
                  |L1.262|
000106  bf00              NOP                            ;137
000108  4628              MOV      r0,r5                 ;183
00010a  e783              B        |L1.20|
;;;185    #endif
                          ENDP


                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;207    
;;;208    OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;209    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;210        OS_FLAG_GRP *pgrp;
;;;211    #if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
;;;212        OS_CPU_SR    cpu_sr = 0;
000008  2700              MOVS     r7,#0
;;;213    #endif
;;;214    
;;;215    
;;;216    
;;;217    #if OS_ARG_CHK_EN > 0
;;;218        if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
00000a  b915              CBNZ     r5,|L2.18|
;;;219            return ((OS_FLAG_GRP *)0);
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;220        }
;;;221    #endif
;;;222        if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
;;;223            *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
;;;224            return ((OS_FLAG_GRP *)0);
;;;225        }
;;;226        OS_ENTER_CRITICAL();
;;;227        pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
;;;228        if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
;;;229            /* Adjust free list                                */
;;;230            OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
;;;231            pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
;;;232            pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
;;;233            pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
;;;234    #if OS_FLAG_NAME_SIZE > 1
;;;235            pgrp->OSFlagName[0]  = '?';
;;;236            pgrp->OSFlagName[1]  = OS_ASCII_NUL;
;;;237    #endif
;;;238            OS_EXIT_CRITICAL();
;;;239            *perr                = OS_ERR_NONE;
;;;240        } else {
;;;241            OS_EXIT_CRITICAL();
;;;242            *perr                = OS_ERR_FLAG_GRP_DEPLETED;
;;;243        }
;;;244        return (pgrp);                                  /* Return pointer to event flag group              */
;;;245    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L2.18|
000012  4814              LDR      r0,|L2.100|
000014  7800              LDRB     r0,[r0,#0]            ;222  ; OSIntNesting
000016  2800              CMP      r0,#0                 ;222
000018  dd03              BLE      |L2.34|
00001a  2010              MOVS     r0,#0x10              ;223
00001c  7028              STRB     r0,[r5,#0]            ;223
00001e  2000              MOVS     r0,#0                 ;224
000020  e7f5              B        |L2.14|
                  |L2.34|
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4607              MOV      r7,r0                 ;226
000028  480f              LDR      r0,|L2.104|
00002a  6804              LDR      r4,[r0,#0]            ;227  ; OSFlagFreeList
00002c  b194              CBZ      r4,|L2.84|
00002e  6800              LDR      r0,[r0,#0]            ;230  ; OSFlagFreeList
000030  6840              LDR      r0,[r0,#4]            ;230
000032  490d              LDR      r1,|L2.104|
000034  6008              STR      r0,[r1,#0]            ;230  ; OSFlagFreeList
000036  2005              MOVS     r0,#5                 ;231
000038  7020              STRB     r0,[r4,#0]            ;231
00003a  8126              STRH     r6,[r4,#8]            ;232
00003c  2000              MOVS     r0,#0                 ;233
00003e  6060              STR      r0,[r4,#4]            ;233
000040  203f              MOVS     r0,#0x3f              ;235
000042  72a0              STRB     r0,[r4,#0xa]          ;235
000044  2100              MOVS     r1,#0                 ;236
000046  72e1              STRB     r1,[r4,#0xb]          ;236
000048  4638              MOV      r0,r7                 ;238
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;239
000050  7028              STRB     r0,[r5,#0]            ;239
000052  e004              B        |L2.94|
                  |L2.84|
000054  4638              MOV      r0,r7                 ;241
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  2072              MOVS     r0,#0x72              ;242
00005c  7028              STRB     r0,[r5,#0]            ;242
                  |L2.94|
00005e  4620              MOV      r0,r4                 ;244
000060  e7d5              B        |L2.14|
;;;246    
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      OSIntNesting
                  |L2.104|
                          DCD      OSFlagFreeList

                          AREA ||i.OSFlagDel||, CODE, READONLY, ALIGN=2

                  OSFlagDel PROC
;;;284    #if OS_FLAG_DEL_EN > 0
;;;285    OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;286    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;287        BOOLEAN       tasks_waiting;
;;;288        OS_FLAG_NODE *pnode;
;;;289        OS_FLAG_GRP  *pgrp_return;
;;;290    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;291        OS_CPU_SR     cpu_sr = 0;
00000a  f04f0a00          MOV      r10,#0
;;;292    #endif
;;;293    
;;;294    
;;;295    
;;;296    #if OS_ARG_CHK_EN > 0
;;;297        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
00000e  b915              CBNZ     r5,|L3.22|
;;;298            return (pgrp);
000010  4620              MOV      r0,r4
                  |L3.18|
;;;299        }
;;;300        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;301            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;302            return (pgrp);
;;;303        }
;;;304    #endif
;;;305        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
;;;306            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
;;;307            return (pgrp);
;;;308        }
;;;309        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
;;;310            *perr = OS_ERR_EVENT_TYPE;
;;;311            return (pgrp);
;;;312        }
;;;313        OS_ENTER_CRITICAL();
;;;314        if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
;;;315            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;316        } else {
;;;317            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;318        }
;;;319        switch (opt) {
;;;320        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
;;;321            if (tasks_waiting == OS_FALSE) {
;;;322    #if OS_FLAG_NAME_SIZE > 1
;;;323                pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
;;;324                pgrp->OSFlagName[1]  = OS_ASCII_NUL;
;;;325    #endif
;;;326                pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;327                pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
;;;328                pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;329                OSFlagFreeList       = pgrp;
;;;330                OS_EXIT_CRITICAL();
;;;331                *perr                = OS_ERR_NONE;
;;;332                pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
;;;333            } else {
;;;334                OS_EXIT_CRITICAL();
;;;335                *perr                = OS_ERR_TASK_WAITING;
;;;336                pgrp_return          = pgrp;
;;;337            }
;;;338            break;
;;;339    
;;;340        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
;;;341            pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;342            while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
;;;343                (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
;;;344                pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
;;;345            }
;;;346    #if OS_FLAG_NAME_SIZE > 1
;;;347            pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
;;;348            pgrp->OSFlagName[1]  = OS_ASCII_NUL;
;;;349    #endif
;;;350            pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;351            pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
;;;352            pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;353            OSFlagFreeList       = pgrp;
;;;354            OS_EXIT_CRITICAL();
;;;355            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;356                OS_Sched();                               /* Find highest priority task ready to run  */
;;;357            }
;;;358            *perr = OS_ERR_NONE;
;;;359            pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
;;;360            break;
;;;361    
;;;362        default:
;;;363            OS_EXIT_CRITICAL();
;;;364            *perr                = OS_ERR_INVALID_OPT;
;;;365            pgrp_return          = pgrp;
;;;366            break;
;;;367        }
;;;368        return (pgrp_return);
;;;369    }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L3.22|
000016  b91c              CBNZ     r4,|L3.32|
000018  206e              MOVS     r0,#0x6e              ;301
00001a  7028              STRB     r0,[r5,#0]            ;301
00001c  4620              MOV      r0,r4                 ;302
00001e  e7f8              B        |L3.18|
                  |L3.32|
000020  4833              LDR      r0,|L3.240|
000022  7800              LDRB     r0,[r0,#0]            ;305  ; OSIntNesting
000024  2800              CMP      r0,#0                 ;305
000026  dd03              BLE      |L3.48|
000028  200f              MOVS     r0,#0xf               ;306
00002a  7028              STRB     r0,[r5,#0]            ;306
00002c  4620              MOV      r0,r4                 ;307
00002e  e7f0              B        |L3.18|
                  |L3.48|
000030  7820              LDRB     r0,[r4,#0]            ;309
000032  2805              CMP      r0,#5                 ;309
000034  d003              BEQ      |L3.62|
000036  2001              MOVS     r0,#1                 ;310
000038  7028              STRB     r0,[r5,#0]            ;310
00003a  4620              MOV      r0,r4                 ;311
00003c  e7e9              B        |L3.18|
                  |L3.62|
00003e  f7fffffe          BL       OS_CPU_SR_Save
000042  4682              MOV      r10,r0                ;313
000044  6860              LDR      r0,[r4,#4]            ;314
000046  b108              CBZ      r0,|L3.76|
000048  2701              MOVS     r7,#1                 ;315
00004a  e000              B        |L3.78|
                  |L3.76|
00004c  2700              MOVS     r7,#0                 ;317
                  |L3.78|
00004e  f1b90f00          CMP      r9,#0                 ;319
000052  d003              BEQ      |L3.92|
000054  f1b90f01          CMP      r9,#1                 ;319
000058  d140              BNE      |L3.220|
00005a  e01b              B        |L3.148|
                  |L3.92|
00005c  b99f              CBNZ     r7,|L3.134|
00005e  203f              MOVS     r0,#0x3f              ;323
000060  72a0              STRB     r0,[r4,#0xa]          ;323
000062  2100              MOVS     r1,#0                 ;324
000064  72e1              STRB     r1,[r4,#0xb]          ;324
000066  2000              MOVS     r0,#0                 ;326
000068  7020              STRB     r0,[r4,#0]            ;326
00006a  4822              LDR      r0,|L3.244|
00006c  6800              LDR      r0,[r0,#0]            ;327  ; OSFlagFreeList
00006e  6060              STR      r0,[r4,#4]            ;327
000070  2000              MOVS     r0,#0                 ;328
000072  8120              STRH     r0,[r4,#8]            ;328
000074  481f              LDR      r0,|L3.244|
000076  6004              STR      r4,[r0,#0]            ;329  ; OSFlagFreeList
000078  4650              MOV      r0,r10                ;330
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  2000              MOVS     r0,#0                 ;331
000080  7028              STRB     r0,[r5,#0]            ;331
000082  2600              MOVS     r6,#0                 ;332
000084  e005              B        |L3.146|
                  |L3.134|
000086  4650              MOV      r0,r10                ;334
000088  f7fffffe          BL       OS_CPU_SR_Restore
00008c  2049              MOVS     r0,#0x49              ;335
00008e  7028              STRB     r0,[r5,#0]            ;335
000090  4626              MOV      r6,r4                 ;336
                  |L3.146|
000092  e02a              B        |L3.234|
                  |L3.148|
000094  f8d48004          LDR      r8,[r4,#4]            ;341
000098  e005              B        |L3.166|
                  |L3.154|
00009a  2100              MOVS     r1,#0                 ;343
00009c  4640              MOV      r0,r8                 ;343
00009e  f7fffffe          BL       OS_FlagTaskRdy
0000a2  f8d88000          LDR      r8,[r8,#0]            ;344
                  |L3.166|
0000a6  f1b80f00          CMP      r8,#0                 ;342
0000aa  d1f6              BNE      |L3.154|
0000ac  203f              MOVS     r0,#0x3f              ;347
0000ae  72a0              STRB     r0,[r4,#0xa]          ;347
0000b0  2100              MOVS     r1,#0                 ;348
0000b2  72e1              STRB     r1,[r4,#0xb]          ;348
0000b4  2000              MOVS     r0,#0                 ;350
0000b6  7020              STRB     r0,[r4,#0]            ;350
0000b8  480e              LDR      r0,|L3.244|
0000ba  6800              LDR      r0,[r0,#0]            ;351  ; OSFlagFreeList
0000bc  6060              STR      r0,[r4,#4]            ;351
0000be  2000              MOVS     r0,#0                 ;352
0000c0  8120              STRH     r0,[r4,#8]            ;352
0000c2  480c              LDR      r0,|L3.244|
0000c4  6004              STR      r4,[r0,#0]            ;353  ; OSFlagFreeList
0000c6  4650              MOV      r0,r10                ;354
0000c8  f7fffffe          BL       OS_CPU_SR_Restore
0000cc  2f01              CMP      r7,#1                 ;355
0000ce  d101              BNE      |L3.212|
0000d0  f7fffffe          BL       OS_Sched
                  |L3.212|
0000d4  2000              MOVS     r0,#0                 ;358
0000d6  7028              STRB     r0,[r5,#0]            ;358
0000d8  2600              MOVS     r6,#0                 ;359
0000da  e006              B        |L3.234|
                  |L3.220|
0000dc  4650              MOV      r0,r10                ;363
0000de  f7fffffe          BL       OS_CPU_SR_Restore
0000e2  2007              MOVS     r0,#7                 ;364
0000e4  7028              STRB     r0,[r5,#0]            ;364
0000e6  4626              MOV      r6,r4                 ;365
0000e8  bf00              NOP                            ;366
                  |L3.234|
0000ea  bf00              NOP                            ;338
0000ec  4630              MOV      r0,r6                 ;368
0000ee  e790              B        |L3.18|
;;;370    #endif
                          ENDP

                  |L3.240|
                          DCD      OSIntNesting
                  |L3.244|
                          DCD      OSFlagFreeList

                          AREA ||i.OSFlagNameGet||, CODE, READONLY, ALIGN=2

                  OSFlagNameGet PROC
;;;395    #if OS_FLAG_NAME_SIZE > 1
;;;396    INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;397    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;398        INT8U      len;
;;;399    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;400        OS_CPU_SR  cpu_sr = 0;
00000a  2700              MOVS     r7,#0
;;;401    #endif
;;;402    
;;;403    
;;;404    
;;;405    #if OS_ARG_CHK_EN > 0
;;;406        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
00000c  b914              CBNZ     r4,|L4.20|
;;;407            return (0);
00000e  2000              MOVS     r0,#0
                  |L4.16|
;;;408        }
;;;409        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;410            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;411            return (0);
;;;412        }
;;;413        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;414            *perr = OS_ERR_PNAME_NULL;
;;;415            return (0);
;;;416        }
;;;417    #endif
;;;418        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;419            *perr = OS_ERR_NAME_GET_ISR;
;;;420            return (0);
;;;421        }
;;;422        OS_ENTER_CRITICAL();
;;;423        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;424            OS_EXIT_CRITICAL();
;;;425            *perr = OS_ERR_EVENT_TYPE;
;;;426            return (0);
;;;427        }
;;;428        len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
;;;429        OS_EXIT_CRITICAL();
;;;430        *perr = OS_ERR_NONE;
;;;431        return (len);
;;;432    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L4.20|
000014  b91d              CBNZ     r5,|L4.30|
000016  206e              MOVS     r0,#0x6e              ;410
000018  7020              STRB     r0,[r4,#0]            ;410
00001a  2000              MOVS     r0,#0                 ;411
00001c  e7f8              B        |L4.16|
                  |L4.30|
00001e  b91e              CBNZ     r6,|L4.40|
000020  200c              MOVS     r0,#0xc               ;414
000022  7020              STRB     r0,[r4,#0]            ;414
000024  2000              MOVS     r0,#0                 ;415
000026  e7f3              B        |L4.16|
                  |L4.40|
000028  4810              LDR      r0,|L4.108|
00002a  7800              LDRB     r0,[r0,#0]            ;418  ; OSIntNesting
00002c  2800              CMP      r0,#0                 ;418
00002e  dd03              BLE      |L4.56|
000030  2011              MOVS     r0,#0x11              ;419
000032  7020              STRB     r0,[r4,#0]            ;419
000034  2000              MOVS     r0,#0                 ;420
000036  e7eb              B        |L4.16|
                  |L4.56|
000038  f7fffffe          BL       OS_CPU_SR_Save
00003c  4607              MOV      r7,r0                 ;422
00003e  7828              LDRB     r0,[r5,#0]            ;423
000040  2805              CMP      r0,#5                 ;423
000042  d006              BEQ      |L4.82|
000044  4638              MOV      r0,r7                 ;424
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  2001              MOVS     r0,#1                 ;425
00004c  7020              STRB     r0,[r4,#0]            ;425
00004e  2000              MOVS     r0,#0                 ;426
000050  e7de              B        |L4.16|
                  |L4.82|
000052  f105010a          ADD      r1,r5,#0xa            ;428
000056  4630              MOV      r0,r6                 ;428
000058  f7fffffe          BL       OS_StrCopy
00005c  4680              MOV      r8,r0                 ;428
00005e  4638              MOV      r0,r7                 ;429
000060  f7fffffe          BL       OS_CPU_SR_Restore
000064  2000              MOVS     r0,#0                 ;430
000066  7020              STRB     r0,[r4,#0]            ;430
000068  4640              MOV      r0,r8                 ;431
00006a  e7d1              B        |L4.16|
;;;433    #endif
                          ENDP

                  |L4.108|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagNameSet||, CODE, READONLY, ALIGN=2

                  OSFlagNameSet PROC
;;;459    #if OS_FLAG_NAME_SIZE > 1
;;;460    void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;461    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;462        INT8U      len;
;;;463    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;464        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0800          MOV      r8,#0
;;;465    #endif
;;;466    
;;;467    
;;;468    
;;;469    #if OS_ARG_CHK_EN > 0
;;;470        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
00000e  b90c              CBNZ     r4,|L5.20|
                  |L5.16|
;;;471            return;
;;;472        }
;;;473        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;474            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;475            return;
;;;476        }
;;;477        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;478            *perr = OS_ERR_PNAME_NULL;
;;;479            return;
;;;480        }
;;;481    #endif
;;;482        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;483            *perr = OS_ERR_NAME_SET_ISR;
;;;484            return;
;;;485        }
;;;486        OS_ENTER_CRITICAL();
;;;487        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;488            OS_EXIT_CRITICAL();
;;;489            *perr = OS_ERR_EVENT_TYPE;
;;;490            return;
;;;491        }
;;;492        len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
;;;493        if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
;;;494            OS_EXIT_CRITICAL();
;;;495            *perr = OS_ERR_FLAG_NAME_TOO_LONG;
;;;496            return;
;;;497        }
;;;498        (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
;;;499        OS_EXIT_CRITICAL();
;;;500        *perr = OS_ERR_NONE;
;;;501        return;
;;;502    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L5.20|
000014  b915              CBNZ     r5,|L5.28|
000016  206e              MOVS     r0,#0x6e              ;474
000018  7020              STRB     r0,[r4,#0]            ;474
00001a  e7f9              B        |L5.16|
                  |L5.28|
00001c  b916              CBNZ     r6,|L5.36|
00001e  200c              MOVS     r0,#0xc               ;478
000020  7020              STRB     r0,[r4,#0]            ;478
000022  e7f5              B        |L5.16|
                  |L5.36|
000024  4815              LDR      r0,|L5.124|
000026  7800              LDRB     r0,[r0,#0]            ;482  ; OSIntNesting
000028  2800              CMP      r0,#0                 ;482
00002a  dd02              BLE      |L5.50|
00002c  2012              MOVS     r0,#0x12              ;483
00002e  7020              STRB     r0,[r4,#0]            ;483
000030  e7ee              B        |L5.16|
                  |L5.50|
000032  f7fffffe          BL       OS_CPU_SR_Save
000036  4680              MOV      r8,r0                 ;486
000038  7828              LDRB     r0,[r5,#0]            ;487
00003a  2805              CMP      r0,#5                 ;487
00003c  d005              BEQ      |L5.74|
00003e  4640              MOV      r0,r8                 ;488
000040  f7fffffe          BL       OS_CPU_SR_Restore
000044  2001              MOVS     r0,#1                 ;489
000046  7020              STRB     r0,[r4,#0]            ;489
000048  e7e2              B        |L5.16|
                  |L5.74|
00004a  4630              MOV      r0,r6                 ;492
00004c  f7fffffe          BL       OS_StrLen
000050  4607              MOV      r7,r0                 ;492
000052  2f0f              CMP      r7,#0xf               ;493
000054  dd05              BLE      |L5.98|
000056  4640              MOV      r0,r8                 ;494
000058  f7fffffe          BL       OS_CPU_SR_Restore
00005c  2073              MOVS     r0,#0x73              ;495
00005e  7020              STRB     r0,[r4,#0]            ;495
000060  e7d6              B        |L5.16|
                  |L5.98|
000062  4631              MOV      r1,r6                 ;498
000064  f105000a          ADD      r0,r5,#0xa            ;498
000068  f7fffffe          BL       OS_StrCopy
00006c  4640              MOV      r0,r8                 ;499
00006e  f7fffffe          BL       OS_CPU_SR_Restore
000072  2000              MOVS     r0,#0                 ;500
000074  7020              STRB     r0,[r4,#0]            ;500
000076  bf00              NOP                            ;501
000078  e7ca              B        |L5.16|
;;;503    #endif
                          ENDP

00007a  0000              DCW      0x0000
                  |L5.124|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;559    
;;;560    OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;561    {
000004  b089              SUB      sp,sp,#0x24
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  9e12              LDR      r6,[sp,#0x48]
;;;562        OS_FLAG_NODE  node;
;;;563        OS_FLAGS      flags_rdy;
;;;564        INT8U         result;
;;;565        INT8U         pend_stat;
;;;566        BOOLEAN       consume;
;;;567    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;568        OS_CPU_SR     cpu_sr = 0;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;569    #endif
;;;570    
;;;571    
;;;572    
;;;573    #if OS_ARG_CHK_EN > 0
;;;574        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
000014  b916              CBNZ     r6,|L6.28|
                  |L6.22|
;;;575            return ((OS_FLAGS)0);
;;;576        }
;;;577        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;578            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;579            return ((OS_FLAGS)0);
;;;580        }
;;;581    #endif
;;;582        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
;;;583            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
;;;584            return ((OS_FLAGS)0);
;;;585        }
;;;586        if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
;;;587            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;588            return ((OS_FLAGS)0);
;;;589        }
;;;590        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;591            *perr = OS_ERR_EVENT_TYPE;
;;;592            return ((OS_FLAGS)0);
;;;593        }
;;;594        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;595        if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
;;;596            wait_type &= ~(INT8U)OS_FLAG_CONSUME;
;;;597            consume    = OS_TRUE;
;;;598        } else {
;;;599            consume    = OS_FALSE;
;;;600        }
;;;601        /*$PAGE*/
;;;602        OS_ENTER_CRITICAL();
;;;603        switch (wait_type) {
;;;604        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;605            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
;;;606            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;607                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;608                    pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
;;;609                }
;;;610                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;611                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;612                *perr                   = OS_ERR_NONE;
;;;613                return (flags_rdy);
;;;614            } else {                                      /* Block task until events occur or timeout */
;;;615                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;616                OS_EXIT_CRITICAL();
;;;617            }
;;;618            break;
;;;619    
;;;620        case OS_FLAG_WAIT_SET_ANY:
;;;621            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
;;;622            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;623                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;624                    pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
;;;625                }
;;;626                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;627                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;628                *perr                   = OS_ERR_NONE;
;;;629                return (flags_rdy);
;;;630            } else {                                      /* Block task until events occur or timeout */
;;;631                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;632                OS_EXIT_CRITICAL();
;;;633            }
;;;634            break;
;;;635    
;;;636    #if OS_FLAG_WAIT_CLR_EN > 0
;;;637        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;638            flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
;;;639            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;640                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;641                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;642                }
;;;643                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;644                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;645                *perr                   = OS_ERR_NONE;
;;;646                return (flags_rdy);
;;;647            } else {                                      /* Block task until events occur or timeout */
;;;648                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;649                OS_EXIT_CRITICAL();
;;;650            }
;;;651            break;
;;;652    
;;;653        case OS_FLAG_WAIT_CLR_ANY:
;;;654            flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
;;;655            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;656                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;657                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;658                }
;;;659                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;660                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;661                *perr                   = OS_ERR_NONE;
;;;662                return (flags_rdy);
;;;663            } else {                                      /* Block task until events occur or timeout */
;;;664                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;665                OS_EXIT_CRITICAL();
;;;666            }
;;;667            break;
;;;668    #endif
;;;669    
;;;670        default:
;;;671            OS_EXIT_CRITICAL();
;;;672            flags_rdy = (OS_FLAGS)0;
;;;673            *perr      = OS_ERR_FLAG_WAIT_TYPE;
;;;674            return (flags_rdy);
;;;675        }
;;;676        /*$PAGE*/
;;;677        OS_Sched();                                            /* Find next HPT ready to run               */
;;;678        OS_ENTER_CRITICAL();
;;;679        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
;;;680            pend_stat                = OSTCBCur->OSTCBStatPend;
;;;681            OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;682            OS_FlagUnlink(&node);
;;;683            OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
;;;684            OS_EXIT_CRITICAL();
;;;685            flags_rdy                = (OS_FLAGS)0;
;;;686            switch (pend_stat) {
;;;687            case OS_STAT_PEND_TO:
;;;688            default:
;;;689                *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
;;;690                break;
;;;691    
;;;692            case OS_STAT_PEND_ABORT:
;;;693                *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
;;;694                break;
;;;695            }
;;;696            return (flags_rdy);
;;;697        }
;;;698        flags_rdy = OSTCBCur->OSTCBFlagsRdy;
;;;699        if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
;;;700            switch (wait_type) {
;;;701            case OS_FLAG_WAIT_SET_ALL:
;;;702            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
;;;703                pgrp->OSFlagFlags &= ~flags_rdy;
;;;704                break;
;;;705    
;;;706    #if OS_FLAG_WAIT_CLR_EN > 0
;;;707            case OS_FLAG_WAIT_CLR_ALL:
;;;708            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
;;;709                pgrp->OSFlagFlags |=  flags_rdy;
;;;710                break;
;;;711    #endif
;;;712            default:
;;;713                OS_EXIT_CRITICAL();
;;;714                *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;715                return ((OS_FLAGS)0);
;;;716            }
;;;717        }
;;;718        OS_EXIT_CRITICAL();
;;;719        *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
;;;720        return (flags_rdy);
;;;721    }
000016  b009              ADD      sp,sp,#0x24
000018  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.28|
00001c  b91d              CBNZ     r5,|L6.38|
00001e  206e              MOVS     r0,#0x6e              ;578
000020  7030              STRB     r0,[r6,#0]            ;578
000022  2000              MOVS     r0,#0                 ;579
000024  e7f7              B        |L6.22|
                  |L6.38|
000026  488d              LDR      r0,|L6.604|
000028  7800              LDRB     r0,[r0,#0]            ;582  ; OSIntNesting
00002a  2800              CMP      r0,#0                 ;582
00002c  dd03              BLE      |L6.54|
00002e  2002              MOVS     r0,#2                 ;583
000030  7030              STRB     r0,[r6,#0]            ;583
000032  2000              MOVS     r0,#0                 ;584
000034  e7ef              B        |L6.22|
                  |L6.54|
000036  488a              LDR      r0,|L6.608|
000038  7800              LDRB     r0,[r0,#0]            ;586  ; OSLockNesting
00003a  2800              CMP      r0,#0                 ;586
00003c  dd03              BLE      |L6.70|
00003e  200d              MOVS     r0,#0xd               ;587
000040  7030              STRB     r0,[r6,#0]            ;587
000042  2000              MOVS     r0,#0                 ;588
000044  e7e7              B        |L6.22|
                  |L6.70|
000046  7828              LDRB     r0,[r5,#0]            ;590
000048  2805              CMP      r0,#5                 ;590
00004a  d003              BEQ      |L6.84|
00004c  2001              MOVS     r0,#1                 ;591
00004e  7030              STRB     r0,[r6,#0]            ;591
000050  2000              MOVS     r0,#0                 ;592
000052  e7e0              B        |L6.22|
                  |L6.84|
000054  f0090b80          AND      r11,r9,#0x80          ;594
000058  f1bb0f00          CMP      r11,#0                ;595
00005c  d004              BEQ      |L6.104|
00005e  f0290980          BIC      r9,r9,#0x80           ;596
000062  f04f0801          MOV      r8,#1                 ;597
000066  e001              B        |L6.108|
                  |L6.104|
000068  f04f0800          MOV      r8,#0                 ;599
                  |L6.108|
00006c  f7fffffe          BL       OS_CPU_SR_Save
000070  9002              STR      r0,[sp,#8]            ;602
000072  f1b90f00          CMP      r9,#0                 ;603
000076  d04a              BEQ      |L6.270|
000078  f1b90f01          CMP      r9,#1                 ;603
00007c  d068              BEQ      |L6.336|
00007e  f1b90f02          CMP      r9,#2                 ;603
000082  d003              BEQ      |L6.140|
000084  f1b90f03          CMP      r9,#3                 ;603
000088  d176              BNE      |L6.376|
00008a  e020              B        |L6.206|
                  |L6.140|
00008c  8928              LDRH     r0,[r5,#8]            ;605
00008e  ea000407          AND      r4,r0,r7              ;605
000092  42bc              CMP      r4,r7                 ;606
000094  d10f              BNE      |L6.182|
000096  f1b80f01          CMP      r8,#1                 ;607
00009a  d102              BNE      |L6.162|
00009c  8928              LDRH     r0,[r5,#8]            ;608
00009e  43a0              BICS     r0,r0,r4              ;608
0000a0  8128              STRH     r0,[r5,#8]            ;608
                  |L6.162|
0000a2  4870              LDR      r0,|L6.612|
0000a4  6800              LDR      r0,[r0,#0]            ;610  ; OSTCBCur
0000a6  8504              STRH     r4,[r0,#0x28]         ;610
0000a8  9802              LDR      r0,[sp,#8]            ;611
0000aa  f7fffffe          BL       OS_CPU_SR_Restore
0000ae  2000              MOVS     r0,#0                 ;612
0000b0  7030              STRB     r0,[r6,#0]            ;612
0000b2  4620              MOV      r0,r4                 ;613
0000b4  e7af              B        |L6.22|
                  |L6.182|
0000b6  464b              MOV      r3,r9                 ;615
0000b8  463a              MOV      r2,r7                 ;615
0000ba  a904              ADD      r1,sp,#0x10           ;615
0000bc  4628              MOV      r0,r5                 ;615
0000be  f8cda000          STR      r10,[sp,#0]           ;615
0000c2  f7fffffe          BL       OS_FlagBlock
0000c6  9802              LDR      r0,[sp,#8]            ;616
0000c8  f7fffffe          BL       OS_CPU_SR_Restore
0000cc  e069              B        |L6.418|
                  |L6.206|
0000ce  8928              LDRH     r0,[r5,#8]            ;621
0000d0  ea000407          AND      r4,r0,r7              ;621
0000d4  b17c              CBZ      r4,|L6.246|
0000d6  f1b80f01          CMP      r8,#1                 ;623
0000da  d102              BNE      |L6.226|
0000dc  8928              LDRH     r0,[r5,#8]            ;624
0000de  43a0              BICS     r0,r0,r4              ;624
0000e0  8128              STRH     r0,[r5,#8]            ;624
                  |L6.226|
0000e2  4860              LDR      r0,|L6.612|
0000e4  6800              LDR      r0,[r0,#0]            ;626  ; OSTCBCur
0000e6  8504              STRH     r4,[r0,#0x28]         ;626
0000e8  9802              LDR      r0,[sp,#8]            ;627
0000ea  f7fffffe          BL       OS_CPU_SR_Restore
0000ee  2000              MOVS     r0,#0                 ;628
0000f0  7030              STRB     r0,[r6,#0]            ;628
0000f2  4620              MOV      r0,r4                 ;629
0000f4  e78f              B        |L6.22|
                  |L6.246|
0000f6  464b              MOV      r3,r9                 ;631
0000f8  463a              MOV      r2,r7                 ;631
0000fa  a904              ADD      r1,sp,#0x10           ;631
0000fc  4628              MOV      r0,r5                 ;631
0000fe  f8cda000          STR      r10,[sp,#0]           ;631
000102  f7fffffe          BL       OS_FlagBlock
000106  9802              LDR      r0,[sp,#8]            ;632
000108  f7fffffe          BL       OS_CPU_SR_Restore
00010c  e049              B        |L6.418|
                  |L6.270|
00010e  8928              LDRH     r0,[r5,#8]            ;638
000110  ea270400          BIC      r4,r7,r0              ;638
000114  42bc              CMP      r4,r7                 ;639
000116  d10f              BNE      |L6.312|
000118  f1b80f01          CMP      r8,#1                 ;640
00011c  d102              BNE      |L6.292|
00011e  8928              LDRH     r0,[r5,#8]            ;641
000120  4320              ORRS     r0,r0,r4              ;641
000122  8128              STRH     r0,[r5,#8]            ;641
                  |L6.292|
000124  484f              LDR      r0,|L6.612|
000126  6800              LDR      r0,[r0,#0]            ;643  ; OSTCBCur
000128  8504              STRH     r4,[r0,#0x28]         ;643
00012a  9802              LDR      r0,[sp,#8]            ;644
00012c  f7fffffe          BL       OS_CPU_SR_Restore
000130  2000              MOVS     r0,#0                 ;645
000132  7030              STRB     r0,[r6,#0]            ;645
000134  4620              MOV      r0,r4                 ;646
000136  e76e              B        |L6.22|
                  |L6.312|
000138  464b              MOV      r3,r9                 ;648
00013a  463a              MOV      r2,r7                 ;648
00013c  a904              ADD      r1,sp,#0x10           ;648
00013e  4628              MOV      r0,r5                 ;648
000140  f8cda000          STR      r10,[sp,#0]           ;648
000144  f7fffffe          BL       OS_FlagBlock
000148  9802              LDR      r0,[sp,#8]            ;649
00014a  f7fffffe          BL       OS_CPU_SR_Restore
00014e  e028              B        |L6.418|
                  |L6.336|
000150  8928              LDRH     r0,[r5,#8]            ;654
000152  ea270400          BIC      r4,r7,r0              ;654
000156  b184              CBZ      r4,|L6.378|
000158  f1b80f01          CMP      r8,#1                 ;656
00015c  d102              BNE      |L6.356|
00015e  8928              LDRH     r0,[r5,#8]            ;657
000160  4320              ORRS     r0,r0,r4              ;657
000162  8128              STRH     r0,[r5,#8]            ;657
                  |L6.356|
000164  483f              LDR      r0,|L6.612|
000166  6800              LDR      r0,[r0,#0]            ;659  ; OSTCBCur
000168  8504              STRH     r4,[r0,#0x28]         ;659
00016a  9802              LDR      r0,[sp,#8]            ;660
00016c  f7fffffe          BL       OS_CPU_SR_Restore
000170  2000              MOVS     r0,#0                 ;661
000172  7030              STRB     r0,[r6,#0]            ;661
000174  4620              MOV      r0,r4                 ;662
000176  e74e              B        |L6.22|
                  |L6.376|
000178  e00b              B        |L6.402|
                  |L6.378|
00017a  464b              MOV      r3,r9                 ;664
00017c  463a              MOV      r2,r7                 ;664
00017e  a904              ADD      r1,sp,#0x10           ;664
000180  4628              MOV      r0,r5                 ;664
000182  f8cda000          STR      r10,[sp,#0]           ;664
000186  f7fffffe          BL       OS_FlagBlock
00018a  9802              LDR      r0,[sp,#8]            ;665
00018c  f7fffffe          BL       OS_CPU_SR_Restore
000190  e007              B        |L6.418|
                  |L6.402|
000192  9802              LDR      r0,[sp,#8]            ;671
000194  f7fffffe          BL       OS_CPU_SR_Restore
000198  2400              MOVS     r4,#0                 ;672
00019a  206f              MOVS     r0,#0x6f              ;673
00019c  7030              STRB     r0,[r6,#0]            ;673
00019e  4620              MOV      r0,r4                 ;674
0001a0  e739              B        |L6.22|
                  |L6.418|
0001a2  bf00              NOP                            ;618
0001a4  f7fffffe          BL       OS_Sched
0001a8  f7fffffe          BL       OS_CPU_SR_Save
0001ac  9002              STR      r0,[sp,#8]            ;678
0001ae  482d              LDR      r0,|L6.612|
0001b0  6800              LDR      r0,[r0,#0]            ;679  ; OSTCBCur
0001b2  f890002d          LDRB     r0,[r0,#0x2d]         ;679
0001b6  b320              CBZ      r0,|L6.514|
0001b8  482a              LDR      r0,|L6.612|
0001ba  6800              LDR      r0,[r0,#0]            ;680  ; OSTCBCur
0001bc  f890002d          LDRB     r0,[r0,#0x2d]         ;680
0001c0  9003              STR      r0,[sp,#0xc]          ;680
0001c2  2000              MOVS     r0,#0                 ;681
0001c4  4927              LDR      r1,|L6.612|
0001c6  6809              LDR      r1,[r1,#0]            ;681  ; OSTCBCur
0001c8  f881002d          STRB     r0,[r1,#0x2d]         ;681
0001cc  a804              ADD      r0,sp,#0x10           ;682
0001ce  f7fffffe          BL       OS_FlagUnlink
0001d2  2000              MOVS     r0,#0                 ;683
0001d4  4923              LDR      r1,|L6.612|
0001d6  6809              LDR      r1,[r1,#0]            ;683  ; OSTCBCur
0001d8  f881002c          STRB     r0,[r1,#0x2c]         ;683
0001dc  9802              LDR      r0,[sp,#8]            ;684
0001de  f7fffffe          BL       OS_CPU_SR_Restore
0001e2  2400              MOVS     r4,#0                 ;685
0001e4  9803              LDR      r0,[sp,#0xc]          ;686
0001e6  2801              CMP      r0,#1                 ;686
0001e8  d002              BEQ      |L6.496|
0001ea  2802              CMP      r0,#2                 ;686
0001ec  d003              BEQ      |L6.502|
0001ee  bf00              NOP                            ;687
                  |L6.496|
0001f0  200a              MOVS     r0,#0xa               ;689
0001f2  7030              STRB     r0,[r6,#0]            ;689
0001f4  e002              B        |L6.508|
                  |L6.502|
0001f6  200e              MOVS     r0,#0xe               ;693
0001f8  7030              STRB     r0,[r6,#0]            ;693
0001fa  bf00              NOP                            ;694
                  |L6.508|
0001fc  bf00              NOP                            ;690
0001fe  4620              MOV      r0,r4                 ;696
000200  e709              B        |L6.22|
                  |L6.514|
000202  4818              LDR      r0,|L6.612|
000204  6800              LDR      r0,[r0,#0]            ;698  ; OSTCBCur
000206  8d04              LDRH     r4,[r0,#0x28]         ;698
000208  f1b80f01          CMP      r8,#1                 ;699
00020c  d11e              BNE      |L6.588|
00020e  f1b90f00          CMP      r9,#0                 ;700
000212  d00e              BEQ      |L6.562|
000214  f1b90f01          CMP      r9,#1                 ;700
000218  d00c              BEQ      |L6.564|
00021a  f1b90f02          CMP      r9,#2                 ;700
00021e  d003              BEQ      |L6.552|
000220  f1b90f03          CMP      r9,#3                 ;700
000224  d10a              BNE      |L6.572|
000226  e000              B        |L6.554|
                  |L6.552|
000228  bf00              NOP                            ;702
                  |L6.554|
00022a  8928              LDRH     r0,[r5,#8]            ;703
00022c  43a0              BICS     r0,r0,r4              ;703
00022e  8128              STRH     r0,[r5,#8]            ;703
000230  e00b              B        |L6.586|
                  |L6.562|
000232  bf00              NOP                            ;708
                  |L6.564|
000234  8928              LDRH     r0,[r5,#8]            ;709
000236  4320              ORRS     r0,r0,r4              ;709
000238  8128              STRH     r0,[r5,#8]            ;709
00023a  e006              B        |L6.586|
                  |L6.572|
00023c  9802              LDR      r0,[sp,#8]            ;713
00023e  f7fffffe          BL       OS_CPU_SR_Restore
000242  206f              MOVS     r0,#0x6f              ;714
000244  7030              STRB     r0,[r6,#0]            ;714
000246  2000              MOVS     r0,#0                 ;715
000248  e6e5              B        |L6.22|
                  |L6.586|
00024a  bf00              NOP                            ;704
                  |L6.588|
00024c  9802              LDR      r0,[sp,#8]            ;718
00024e  f7fffffe          BL       OS_CPU_SR_Restore
000252  2000              MOVS     r0,#0                 ;719
000254  7030              STRB     r0,[r6,#0]            ;719
000256  4620              MOV      r0,r4                 ;720
000258  e6dd              B        |L6.22|
;;;722    /*$PAGE*/
                          ENDP

00025a  0000              DCW      0x0000
                  |L6.604|
                          DCD      OSIntNesting
                  |L6.608|
                          DCD      OSLockNesting
                  |L6.612|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;737    
;;;738    OS_FLAGS  OSFlagPendGetFlagsRdy (void)
000000  b570              PUSH     {r4-r6,lr}
;;;739    {
;;;740        OS_FLAGS      flags;
;;;741    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;742        OS_CPU_SR     cpu_sr = 0;
000002  2500              MOVS     r5,#0
;;;743    #endif
;;;744    
;;;745    
;;;746    
;;;747        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;748        flags = OSTCBCur->OSTCBFlagsRdy;
00000a  4804              LDR      r0,|L7.28|
00000c  6800              LDR      r0,[r0,#0]  ; OSTCBCur
00000e  8d04              LDRH     r4,[r0,#0x28]
;;;749        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;750        return (flags);
000016  4620              MOV      r0,r4
;;;751    }
000018  bd70              POP      {r4-r6,pc}
;;;752    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=1

                  OSFlagPost PROC
;;;794    */
;;;795    OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;796    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;797        OS_FLAG_NODE *pnode;
;;;798        BOOLEAN       sched;
;;;799        OS_FLAGS      flags_cur;
;;;800        OS_FLAGS      flags_rdy;
;;;801        BOOLEAN       rdy;
;;;802    #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
;;;803        OS_CPU_SR     cpu_sr = 0;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;804    #endif
;;;805    
;;;806    
;;;807    
;;;808    #if OS_ARG_CHK_EN > 0
;;;809        if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
000010  b90e              CBNZ     r6,|L8.22|
                  |L8.18|
;;;810            return ((OS_FLAGS)0);
;;;811        }
;;;812        if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
;;;813            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;814            return ((OS_FLAGS)0);
;;;815        }
;;;816    #endif
;;;817        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
;;;818            *perr = OS_ERR_EVENT_TYPE;
;;;819            return ((OS_FLAGS)0);
;;;820        }
;;;821        /*$PAGE*/
;;;822        OS_ENTER_CRITICAL();
;;;823        switch (opt) {
;;;824        case OS_FLAG_CLR:
;;;825            pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
;;;826            break;
;;;827    
;;;828        case OS_FLAG_SET:
;;;829            pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
;;;830            break;
;;;831    
;;;832        default:
;;;833            OS_EXIT_CRITICAL();                     /* INVALID option                                 */
;;;834            *perr = OS_ERR_FLAG_INVALID_OPT;
;;;835            return ((OS_FLAGS)0);
;;;836        }
;;;837        sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
;;;838        pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;839        while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
;;;840            switch (pnode->OSFlagNodeWaitType) {
;;;841            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
;;;842                flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;843                if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;844                    rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;845                    if (rdy == OS_TRUE) {
;;;846                        sched = OS_TRUE;                     /* When done we will reschedule          */
;;;847                    }
;;;848                }
;;;849                break;
;;;850    
;;;851            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
;;;852                flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;853                if (flags_rdy != (OS_FLAGS)0) {
;;;854                    rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;855                    if (rdy == OS_TRUE) {
;;;856                        sched = OS_TRUE;                     /* When done we will reschedule          */
;;;857                    }
;;;858                }
;;;859                break;
;;;860    
;;;861    #if OS_FLAG_WAIT_CLR_EN > 0
;;;862            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
;;;863                flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;864                if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;865                    rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;866                    if (rdy == OS_TRUE) {
;;;867                        sched = OS_TRUE;                     /* When done we will reschedule          */
;;;868                    }
;;;869                }
;;;870                break;
;;;871    
;;;872            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
;;;873                flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;874                if (flags_rdy != (OS_FLAGS)0) {
;;;875                    rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;876                    if (rdy == OS_TRUE) {
;;;877                        sched = OS_TRUE;                     /* When done we will reschedule          */
;;;878                    }
;;;879                }
;;;880                break;
;;;881    #endif
;;;882            default:
;;;883                OS_EXIT_CRITICAL();
;;;884                *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;885                return ((OS_FLAGS)0);
;;;886            }
;;;887            pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
;;;888        }
;;;889        OS_EXIT_CRITICAL();
;;;890        if (sched == OS_TRUE) {
;;;891            OS_Sched();
;;;892        }
;;;893        OS_ENTER_CRITICAL();
;;;894        flags_cur = pgrp->OSFlagFlags;
;;;895        OS_EXIT_CRITICAL();
;;;896        *perr     = OS_ERR_NONE;
;;;897        return (flags_cur);
;;;898    }
000012  e8bd9ffc          POP      {r2-r12,pc}
                  |L8.22|
000016  b91c              CBNZ     r4,|L8.32|
000018  206e              MOVS     r0,#0x6e              ;813
00001a  7030              STRB     r0,[r6,#0]            ;813
00001c  2000              MOVS     r0,#0                 ;814
00001e  e7f8              B        |L8.18|
                  |L8.32|
000020  7820              LDRB     r0,[r4,#0]            ;817
000022  2805              CMP      r0,#5                 ;817
000024  d003              BEQ      |L8.46|
000026  2001              MOVS     r0,#1                 ;818
000028  7030              STRB     r0,[r6,#0]            ;818
00002a  2000              MOVS     r0,#0                 ;819
00002c  e7f1              B        |L8.18|
                  |L8.46|
00002e  f7fffffe          BL       OS_CPU_SR_Save
000032  9000              STR      r0,[sp,#0]            ;822
000034  f1ba0f00          CMP      r10,#0                ;823
000038  d003              BEQ      |L8.66|
00003a  f1ba0f01          CMP      r10,#1                ;823
00003e  d10a              BNE      |L8.86|
000040  e004              B        |L8.76|
                  |L8.66|
000042  8920              LDRH     r0,[r4,#8]            ;825
000044  ea200009          BIC      r0,r0,r9              ;825
000048  8120              STRH     r0,[r4,#8]            ;825
00004a  e00b              B        |L8.100|
                  |L8.76|
00004c  8920              LDRH     r0,[r4,#8]            ;829
00004e  ea400009          ORR      r0,r0,r9              ;829
000052  8120              STRH     r0,[r4,#8]            ;829
000054  e006              B        |L8.100|
                  |L8.86|
000056  9800              LDR      r0,[sp,#0]            ;833
000058  f7fffffe          BL       OS_CPU_SR_Restore
00005c  2071              MOVS     r0,#0x71              ;834
00005e  7030              STRB     r0,[r6,#0]            ;834
000060  2000              MOVS     r0,#0                 ;835
000062  e7d6              B        |L8.18|
                  |L8.100|
000064  bf00              NOP                            ;826
000066  f04f0b00          MOV      r11,#0                ;837
00006a  6865              LDR      r5,[r4,#4]            ;838
00006c  e055              B        |L8.282|
                  |L8.110|
00006e  7ca8              LDRB     r0,[r5,#0x12]         ;840
000070  b340              CBZ      r0,|L8.196|
000072  2801              CMP      r0,#1                 ;840
000074  d038              BEQ      |L8.232|
000076  2802              CMP      r0,#2                 ;840
000078  d002              BEQ      |L8.128|
00007a  2803              CMP      r0,#3                 ;840
00007c  d144              BNE      |L8.264|
00007e  e011              B        |L8.164|
                  |L8.128|
000080  8920              LDRH     r0,[r4,#8]            ;842
000082  8a29              LDRH     r1,[r5,#0x10]         ;842
000084  ea000701          AND      r7,r0,r1              ;842
000088  8a28              LDRH     r0,[r5,#0x10]         ;843
00008a  42b8              CMP      r0,r7                 ;843
00008c  d109              BNE      |L8.162|
00008e  4639              MOV      r1,r7                 ;844
000090  4628              MOV      r0,r5                 ;844
000092  f7fffffe          BL       OS_FlagTaskRdy
000096  4680              MOV      r8,r0                 ;844
000098  f1b80f01          CMP      r8,#1                 ;845
00009c  d101              BNE      |L8.162|
00009e  f04f0b01          MOV      r11,#1                ;846
                  |L8.162|
0000a2  e038              B        |L8.278|
                  |L8.164|
0000a4  8920              LDRH     r0,[r4,#8]            ;852
0000a6  8a29              LDRH     r1,[r5,#0x10]         ;852
0000a8  ea000701          AND      r7,r0,r1              ;852
0000ac  b14f              CBZ      r7,|L8.194|
0000ae  4639              MOV      r1,r7                 ;854
0000b0  4628              MOV      r0,r5                 ;854
0000b2  f7fffffe          BL       OS_FlagTaskRdy
0000b6  4680              MOV      r8,r0                 ;854
0000b8  f1b80f01          CMP      r8,#1                 ;855
0000bc  d101              BNE      |L8.194|
0000be  f04f0b01          MOV      r11,#1                ;856
                  |L8.194|
0000c2  e028              B        |L8.278|
                  |L8.196|
0000c4  8a28              LDRH     r0,[r5,#0x10]         ;863
0000c6  8921              LDRH     r1,[r4,#8]            ;863
0000c8  ea200701          BIC      r7,r0,r1              ;863
0000cc  8a28              LDRH     r0,[r5,#0x10]         ;864
0000ce  42b8              CMP      r0,r7                 ;864
0000d0  d109              BNE      |L8.230|
0000d2  4639              MOV      r1,r7                 ;865
0000d4  4628              MOV      r0,r5                 ;865
0000d6  f7fffffe          BL       OS_FlagTaskRdy
0000da  4680              MOV      r8,r0                 ;865
0000dc  f1b80f01          CMP      r8,#1                 ;866
0000e0  d101              BNE      |L8.230|
0000e2  f04f0b01          MOV      r11,#1                ;867
                  |L8.230|
0000e6  e016              B        |L8.278|
                  |L8.232|
0000e8  8a28              LDRH     r0,[r5,#0x10]         ;873
0000ea  8921              LDRH     r1,[r4,#8]            ;873
0000ec  ea200701          BIC      r7,r0,r1              ;873
0000f0  b14f              CBZ      r7,|L8.262|
0000f2  4639              MOV      r1,r7                 ;875
0000f4  4628              MOV      r0,r5                 ;875
0000f6  f7fffffe          BL       OS_FlagTaskRdy
0000fa  4680              MOV      r8,r0                 ;875
0000fc  f1b80f01          CMP      r8,#1                 ;876
000100  d101              BNE      |L8.262|
000102  f04f0b01          MOV      r11,#1                ;877
                  |L8.262|
000106  e006              B        |L8.278|
                  |L8.264|
000108  9800              LDR      r0,[sp,#0]            ;883
00010a  f7fffffe          BL       OS_CPU_SR_Restore
00010e  206f              MOVS     r0,#0x6f              ;884
000110  7030              STRB     r0,[r6,#0]            ;884
000112  2000              MOVS     r0,#0                 ;885
000114  e77d              B        |L8.18|
                  |L8.278|
000116  bf00              NOP                            ;849
000118  682d              LDR      r5,[r5,#0]            ;887
                  |L8.282|
00011a  2d00              CMP      r5,#0                 ;839
00011c  d1a7              BNE      |L8.110|
00011e  9800              LDR      r0,[sp,#0]            ;889
000120  f7fffffe          BL       OS_CPU_SR_Restore
000124  f1bb0f01          CMP      r11,#1                ;890
000128  d101              BNE      |L8.302|
00012a  f7fffffe          BL       OS_Sched
                  |L8.302|
00012e  f7fffffe          BL       OS_CPU_SR_Save
000132  9000              STR      r0,[sp,#0]            ;893
000134  8920              LDRH     r0,[r4,#8]            ;894
000136  9001              STR      r0,[sp,#4]            ;894
000138  9800              LDR      r0,[sp,#0]            ;895
00013a  f7fffffe          BL       OS_CPU_SR_Restore
00013e  2000              MOVS     r0,#0                 ;896
000140  7030              STRB     r0,[r6,#0]            ;896
000142  9801              LDR      r0,[sp,#4]            ;897
000144  e765              B        |L8.18|
;;;899    /*$PAGE*/
                          ENDP


                          AREA ||i.OSFlagQuery||, CODE, READONLY, ALIGN=1

                  OSFlagQuery PROC
;;;919    #if OS_FLAG_QUERY_EN > 0
;;;920    OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;921    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;922        OS_FLAGS   flags;
;;;923    #if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
;;;924        OS_CPU_SR  cpu_sr = 0;
000008  2700              MOVS     r7,#0
;;;925    #endif
;;;926    
;;;927    
;;;928    
;;;929    #if OS_ARG_CHK_EN > 0
;;;930        if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
00000a  b914              CBNZ     r4,|L9.18|
;;;931            return ((OS_FLAGS)0);
00000c  2000              MOVS     r0,#0
                  |L9.14|
;;;932        }
;;;933        if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
;;;934            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;935            return ((OS_FLAGS)0);
;;;936        }
;;;937    #endif
;;;938        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
;;;939            *perr = OS_ERR_EVENT_TYPE;
;;;940            return ((OS_FLAGS)0);
;;;941        }
;;;942        OS_ENTER_CRITICAL();
;;;943        flags = pgrp->OSFlagFlags;
;;;944        OS_EXIT_CRITICAL();
;;;945        *perr = OS_ERR_NONE;
;;;946        return (flags);                               /* Return the current value of the event flags       */
;;;947    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L9.18|
000012  b91d              CBNZ     r5,|L9.28|
000014  206e              MOVS     r0,#0x6e              ;934
000016  7020              STRB     r0,[r4,#0]            ;934
000018  2000              MOVS     r0,#0                 ;935
00001a  e7f8              B        |L9.14|
                  |L9.28|
00001c  7828              LDRB     r0,[r5,#0]            ;938
00001e  2805              CMP      r0,#5                 ;938
000020  d003              BEQ      |L9.42|
000022  2001              MOVS     r0,#1                 ;939
000024  7020              STRB     r0,[r4,#0]            ;939
000026  2000              MOVS     r0,#0                 ;940
000028  e7f1              B        |L9.14|
                  |L9.42|
00002a  f7fffffe          BL       OS_CPU_SR_Save
00002e  4607              MOV      r7,r0                 ;942
000030  892e              LDRH     r6,[r5,#8]            ;943
000032  4638              MOV      r0,r7                 ;944
000034  f7fffffe          BL       OS_CPU_SR_Restore
000038  2000              MOVS     r0,#0                 ;945
00003a  7020              STRB     r0,[r4,#0]            ;945
00003c  4630              MOV      r0,r6                 ;946
00003e  e7e6              B        |L9.14|
;;;948    #endif
                          ENDP


                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;987    
;;;988    static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
000000  b5f0              PUSH     {r4-r7,lr}
;;;989    {
000002  4614              MOV      r4,r2
000004  9e05              LDR      r6,[sp,#0x14]
;;;990        OS_FLAG_NODE  *pnode_next;
;;;991        INT8U          y;
;;;992    
;;;993    
;;;994        OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
000006  4f24              LDR      r7,|L10.152|
000008  683f              LDR      r7,[r7,#0]  ; OSTCBCur
00000a  f897702c          LDRB     r7,[r7,#0x2c]
00000e  f0470720          ORR      r7,r7,#0x20
000012  f8dfc084          LDR      r12,|L10.152|
000016  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
00001a  f88c702c          STRB     r7,[r12,#0x2c]
;;;995        OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
00001e  2700              MOVS     r7,#0
000020  f8dfc074          LDR      r12,|L10.152|
000024  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000028  f88c702d          STRB     r7,[r12,#0x2d]
;;;996        OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002c  4f1a              LDR      r7,|L10.152|
00002e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000030  857e              STRH     r6,[r7,#0x2a]
;;;997    #if OS_TASK_DEL_EN > 0
;;;998        OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
000032  4f19              LDR      r7,|L10.152|
000034  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000036  6279              STR      r1,[r7,#0x24]
;;;999    #endif
;;;1000       pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
000038  820c              STRH     r4,[r1,#0x10]
;;;1001       pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
00003a  748b              STRB     r3,[r1,#0x12]
;;;1002       pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00003c  4f16              LDR      r7,|L10.152|
00003e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000040  608f              STR      r7,[r1,#8]
;;;1003       pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000042  6847              LDR      r7,[r0,#4]
000044  600f              STR      r7,[r1,#0]
;;;1004       pnode->OSFlagNodePrev     = (void *)0;
000046  2700              MOVS     r7,#0
000048  604f              STR      r7,[r1,#4]
;;;1005       pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
00004a  60c8              STR      r0,[r1,#0xc]
;;;1006       pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00004c  6845              LDR      r5,[r0,#4]
;;;1007       if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
00004e  b105              CBZ      r5,|L10.82|
;;;1008           pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000050  6069              STR      r1,[r5,#4]
                  |L10.82|
;;;1009       }
;;;1010       pgrp->OSFlagWaitList = (void *)pnode;
000052  6041              STR      r1,[r0,#4]
;;;1011   
;;;1012       y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000054  4f10              LDR      r7,|L10.152|
000056  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000058  f8972030          LDRB     r2,[r7,#0x30]
;;;1013       OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
00005c  4f0f              LDR      r7,|L10.156|
00005e  5cbf              LDRB     r7,[r7,r2]
000060  f8dfc034          LDR      r12,|L10.152|
000064  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000068  f89cc031          LDRB     r12,[r12,#0x31]
00006c  ea27070c          BIC      r7,r7,r12
000070  f8dfc028          LDR      r12,|L10.156|
000074  f80c7002          STRB     r7,[r12,r2]
;;;1014       if (OSRdyTbl[y] == 0x00) {
000078  4667              MOV      r7,r12
00007a  5cbf              LDRB     r7,[r7,r2]
00007c  b95f              CBNZ     r7,|L10.150|
;;;1015           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
00007e  4f06              LDR      r7,|L10.152|
000080  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000082  f897c032          LDRB     r12,[r7,#0x32]
000086  4f06              LDR      r7,|L10.160|
000088  783f              LDRB     r7,[r7,#0]  ; OSRdyGrp
00008a  ea27070c          BIC      r7,r7,r12
00008e  f8dfc010          LDR      r12,|L10.160|
000092  f88c7000          STRB     r7,[r12,#0]
                  |L10.150|
;;;1016       }
;;;1017   }
000096  bdf0              POP      {r4-r7,pc}
;;;1018   
                          ENDP

                  |L10.152|
                          DCD      OSTCBCur
                  |L10.156|
                          DCD      OSRdyTbl
                  |L10.160|
                          DCD      OSRdyGrp

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;1034   
;;;1035   void  OS_FlagInit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1036   {
;;;1037   #if OS_MAX_FLAGS == 1
;;;1038       OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
;;;1039       OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;1040       OSFlagFreeList->OSFlagWaitList = (void *)0;
;;;1041       OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
;;;1042   #if OS_FLAG_NAME_SIZE > 1
;;;1043       OSFlagFreeList->OSFlagName[0]  = '?';
;;;1044       OSFlagFreeList->OSFlagName[1]  = OS_ASCII_NUL;
;;;1045   #endif
;;;1046   #endif
;;;1047   
;;;1048   #if OS_MAX_FLAGS >= 2
;;;1049       INT16U       i;
;;;1050       OS_FLAG_GRP *pgrp1;
;;;1051       OS_FLAG_GRP *pgrp2;
;;;1052   
;;;1053   
;;;1054       OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
000002  218c              MOVS     r1,#0x8c
000004  480f              LDR      r0,|L11.68|
000006  f7fffffe          BL       OS_MemClr
;;;1055       pgrp1 = &OSFlagTbl[0];
00000a  4c0e              LDR      r4,|L11.68|
;;;1056       pgrp2 = &OSFlagTbl[1];
00000c  f104061c          ADD      r6,r4,#0x1c
;;;1057       for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
000010  2500              MOVS     r5,#0
000012  e00a              B        |L11.42|
                  |L11.20|
;;;1058           pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000014  2000              MOVS     r0,#0
000016  7020              STRB     r0,[r4,#0]
;;;1059           pgrp1->OSFlagWaitList = (void *)pgrp2;
000018  6066              STR      r6,[r4,#4]
;;;1060   #if OS_FLAG_NAME_SIZE > 1
;;;1061           pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
00001a  203f              MOVS     r0,#0x3f
00001c  72a0              STRB     r0,[r4,#0xa]
;;;1062           pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
00001e  2100              MOVS     r1,#0
000020  72e1              STRB     r1,[r4,#0xb]
;;;1063   #endif
;;;1064           pgrp1++;
000022  341c              ADDS     r4,r4,#0x1c
;;;1065           pgrp2++;
000024  361c              ADDS     r6,r6,#0x1c
000026  1c68              ADDS     r0,r5,#1              ;1057
000028  b285              UXTH     r5,r0                 ;1057
                  |L11.42|
00002a  2d04              CMP      r5,#4                 ;1057
00002c  dbf2              BLT      |L11.20|
;;;1066       }
;;;1067       pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002e  2000              MOVS     r0,#0
000030  7020              STRB     r0,[r4,#0]
;;;1068       pgrp1->OSFlagWaitList = (void *)0;
000032  6060              STR      r0,[r4,#4]
;;;1069   #if OS_FLAG_NAME_SIZE > 1
;;;1070       pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
000034  203f              MOVS     r0,#0x3f
000036  72a0              STRB     r0,[r4,#0xa]
;;;1071       pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
000038  2100              MOVS     r1,#0
00003a  72e1              STRB     r1,[r4,#0xb]
;;;1072   #endif
;;;1073       OSFlagFreeList        = &OSFlagTbl[0];
00003c  4801              LDR      r0,|L11.68|
00003e  4902              LDR      r1,|L11.72|
000040  6008              STR      r0,[r1,#0]  ; OSFlagFreeList
;;;1074   #endif
;;;1075   }
000042  bd70              POP      {r4-r6,pc}
;;;1076   
                          ENDP

                  |L11.68|
                          DCD      OSFlagTbl
                  |L11.72|
                          DCD      OSFlagFreeList

                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_FlagTaskRdy PROC
;;;1100   
;;;1101   static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1102   {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;1103       OS_TCB   *ptcb;
;;;1104       BOOLEAN   sched;
;;;1105   
;;;1106   
;;;1107       ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000006  68b4              LDR      r4,[r6,#8]
;;;1108       ptcb->OSTCBDly       = 0;
000008  2000              MOVS     r0,#0
00000a  f1040428          ADD      r4,r4,#0x28
00000e  8060              STRH     r0,[r4,#2]
;;;1109       ptcb->OSTCBFlagsRdy  = flags_rdy;
000010  8027              STRH     r7,[r4,#0]
;;;1110       ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
000012  7920              LDRB     r0,[r4,#4]
000014  f0200020          BIC      r0,r0,#0x20
000018  7120              STRB     r0,[r4,#4]
;;;1111       ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
00001a  f04f0000          MOV      r0,#0
00001e  7160              STRB     r0,[r4,#5]
;;;1112       if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000020  7920              LDRB     r0,[r4,#4]
000022  f1a40428          SUB      r4,r4,#0x28
000026  b9a8              CBNZ     r0,|L12.84|
;;;1113           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000028  f1040430          ADD      r4,r4,#0x30
00002c  78a0              LDRB     r0,[r4,#2]
00002e  490c              LDR      r1,|L12.96|
000030  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000032  ea400001          ORR      r0,r0,r1
000036  490a              LDR      r1,|L12.96|
000038  7008              STRB     r0,[r1,#0]
;;;1114           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00003a  7820              LDRB     r0,[r4,#0]
00003c  4909              LDR      r1,|L12.100|
00003e  5c08              LDRB     r0,[r1,r0]
000040  7861              LDRB     r1,[r4,#1]
000042  ea400001          ORR      r0,r0,r1
000046  f8141930          LDRB     r1,[r4],#-0x30
00004a  4a06              LDR      r2,|L12.100|
00004c  5450              STRB     r0,[r2,r1]
;;;1115           sched                   = OS_TRUE;
00004e  f04f0501          MOV      r5,#1
000052  e000              B        |L12.86|
                  |L12.84|
;;;1116       } else {
;;;1117           sched                   = OS_FALSE;
000054  2500              MOVS     r5,#0
                  |L12.86|
;;;1118       }
;;;1119       OS_FlagUnlink(pnode);
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       OS_FlagUnlink
;;;1120       return (sched);
00005c  4628              MOV      r0,r5
;;;1121   }
00005e  bdf0              POP      {r4-r7,pc}
;;;1122   
                          ENDP

                  |L12.96|
                          DCD      OSRdyGrp
                  |L12.100|
                          DCD      OSRdyTbl

                          AREA ||i.OS_FlagUnlink||, CODE, READONLY, ALIGN=1

                  OS_FlagUnlink PROC
;;;1144   
;;;1145   void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
000000  b530              PUSH     {r4,r5,lr}
;;;1146   {
000002  4601              MOV      r1,r0
;;;1147   #if OS_TASK_DEL_EN > 0
;;;1148       OS_TCB       *ptcb;
;;;1149   #endif
;;;1150       OS_FLAG_GRP  *pgrp;
;;;1151       OS_FLAG_NODE *pnode_prev;
;;;1152       OS_FLAG_NODE *pnode_next;
;;;1153   
;;;1154   
;;;1155       pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000004  684a              LDR      r2,[r1,#4]
;;;1156       pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000006  6808              LDR      r0,[r1,#0]
;;;1157       if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
000008  b92a              CBNZ     r2,|L13.22|
;;;1158           pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00000a  68cc              LDR      r4,[r1,#0xc]
;;;1159           pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00000c  6060              STR      r0,[r4,#4]
;;;1160           if (pnode_next != (OS_FLAG_NODE *)0) {
00000e  b128              CBZ      r0,|L13.28|
;;;1161               pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
000010  2500              MOVS     r5,#0
000012  6045              STR      r5,[r0,#4]
000014  e002              B        |L13.28|
                  |L13.22|
;;;1162           }
;;;1163       } else {                                                    /* No,  A node somewhere in the list   */
;;;1164           pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
000016  6010              STR      r0,[r2,#0]
;;;1165           if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
000018  b100              CBZ      r0,|L13.28|
;;;1166               pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00001a  6042              STR      r2,[r0,#4]
                  |L13.28|
;;;1167           }
;;;1168       }
;;;1169   #if OS_TASK_DEL_EN > 0
;;;1170       ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
00001c  688b              LDR      r3,[r1,#8]
;;;1171       ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00001e  2500              MOVS     r5,#0
000020  625d              STR      r5,[r3,#0x24]
;;;1172   #endif
;;;1173   }
000022  bd30              POP      {r4,r5,pc}
;;;1174   #endif
                          ENDP

