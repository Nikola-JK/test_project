; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_sem.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_sem.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\os_sem.crf Source\uCOS-II\Source\os_sem.c]
                          THUMB

                          AREA ||i.OSSemAccept||, CODE, READONLY, ALIGN=1

                  OSSemAccept PROC
;;;48     #if OS_SEM_ACCEPT_EN > 0
;;;49     INT16U  OSSemAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51         INT16U     cnt;
;;;52     #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;53         OS_CPU_SR  cpu_sr = 0;
000004  2600              MOVS     r6,#0
;;;54     #endif
;;;55     
;;;56     
;;;57     
;;;58     #if OS_ARG_CHK_EN > 0
;;;59         if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
000006  b90c              CBNZ     r4,|L1.12|
;;;60             return (0);
000008  2000              MOVS     r0,#0
                  |L1.10|
;;;61         }
;;;62     #endif
;;;63         if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
;;;64             return (0);
;;;65         }
;;;66         OS_ENTER_CRITICAL();
;;;67         cnt = pevent->OSEventCnt;
;;;68         if (cnt > 0) {                                    /* See if resource is available                  */
;;;69             pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
;;;70         }
;;;71         OS_EXIT_CRITICAL();
;;;72         return (cnt);                                     /* Return semaphore count                        */
;;;73     }
00000a  bd70              POP      {r4-r6,pc}
                  |L1.12|
00000c  7820              LDRB     r0,[r4,#0]            ;63
00000e  2803              CMP      r0,#3                 ;63
000010  d001              BEQ      |L1.22|
000012  2000              MOVS     r0,#0                 ;64
000014  e7f9              B        |L1.10|
                  |L1.22|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4606              MOV      r6,r0                 ;66
00001c  8925              LDRH     r5,[r4,#8]            ;67
00001e  2d00              CMP      r5,#0                 ;68
000020  dd02              BLE      |L1.40|
000022  8920              LDRH     r0,[r4,#8]            ;69
000024  1e40              SUBS     r0,r0,#1              ;69
000026  8120              STRH     r0,[r4,#8]            ;69
                  |L1.40|
000028  4630              MOV      r0,r6                 ;71
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  4628              MOV      r0,r5                 ;72
000030  e7eb              B        |L1.10|
;;;74     #endif
                          ENDP


                          AREA ||i.OSSemCreate||, CODE, READONLY, ALIGN=2

                  OSSemCreate PROC
;;;93     
;;;94     OS_EVENT  *OSSemCreate (INT16U cnt)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
000002  4605              MOV      r5,r0
;;;96         OS_EVENT  *pevent;
;;;97     #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;98         OS_CPU_SR  cpu_sr = 0;
000004  2600              MOVS     r6,#0
;;;99     #endif
;;;100    
;;;101    
;;;102    
;;;103        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
000006  4812              LDR      r0,|L2.80|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000a  2800              CMP      r0,#0
00000c  dd01              BLE      |L2.18|
;;;104            return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;105        }
;;;106        OS_ENTER_CRITICAL();
;;;107        pevent = OSEventFreeList;                              /* Get next free event control block        */
;;;108        if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
;;;109            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;110        }
;;;111        OS_EXIT_CRITICAL();
;;;112        if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
;;;113            pevent->OSEventType    = OS_EVENT_TYPE_SEM;
;;;114            pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
;;;115            pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
;;;116    #if OS_EVENT_NAME_SIZE > 1
;;;117            pevent->OSEventName[0] = '?';                      /* Unknown name                             */
;;;118            pevent->OSEventName[1] = OS_ASCII_NUL;
;;;119    #endif
;;;120            OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
;;;121        }
;;;122        return (pevent);
;;;123    }
000010  bd70              POP      {r4-r6,pc}
                  |L2.18|
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0                 ;106
000018  480e              LDR      r0,|L2.84|
00001a  6804              LDR      r4,[r0,#0]            ;107  ; OSEventFreeList
00001c  6800              LDR      r0,[r0,#0]            ;108  ; OSEventFreeList
00001e  b120              CBZ      r0,|L2.42|
000020  480c              LDR      r0,|L2.84|
000022  6800              LDR      r0,[r0,#0]            ;109  ; OSEventFreeList
000024  6840              LDR      r0,[r0,#4]            ;109
000026  490b              LDR      r1,|L2.84|
000028  6008              STR      r0,[r1,#0]            ;109  ; OSEventFreeList
                  |L2.42|
00002a  4630              MOV      r0,r6                 ;111
00002c  f7fffffe          BL       OS_CPU_SR_Restore
000030  b15c              CBZ      r4,|L2.74|
000032  2003              MOVS     r0,#3                 ;113
000034  7020              STRB     r0,[r4,#0]            ;113
000036  8125              STRH     r5,[r4,#8]            ;114
000038  2000              MOVS     r0,#0                 ;115
00003a  6060              STR      r0,[r4,#4]            ;115
00003c  203f              MOVS     r0,#0x3f              ;117
00003e  74e0              STRB     r0,[r4,#0x13]         ;117
000040  2100              MOVS     r1,#0                 ;118
000042  7521              STRB     r1,[r4,#0x14]         ;118
000044  4620              MOV      r0,r4                 ;120
000046  f7fffffe          BL       OS_EventWaitListInit
                  |L2.74|
00004a  4620              MOV      r0,r4                 ;122
00004c  e7e0              B        |L2.16|
;;;124    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      OSIntNesting
                  |L2.84|
                          DCD      OSEventFreeList

                          AREA ||i.OSSemDel||, CODE, READONLY, ALIGN=2

                  OSSemDel PROC
;;;163    #if OS_SEM_DEL_EN > 0
;;;164    OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;165    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;166        BOOLEAN    tasks_waiting;
;;;167        OS_EVENT  *pevent_return;
;;;168    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;169        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0900          MOV      r9,#0
;;;170    #endif
;;;171    
;;;172    
;;;173    
;;;174    #if OS_ARG_CHK_EN > 0
;;;175        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
00000e  b915              CBNZ     r5,|L3.22|
;;;176            return (pevent);
000010  4620              MOV      r0,r4
                  |L3.18|
;;;177        }
;;;178        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
;;;179            *perr = OS_ERR_PEVENT_NULL;
;;;180            return (pevent);
;;;181        }
;;;182    #endif
;;;183        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
;;;184            *perr = OS_ERR_EVENT_TYPE;
;;;185            return (pevent);
;;;186        }
;;;187        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
;;;188            *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
;;;189            return (pevent);
;;;190        }
;;;191        OS_ENTER_CRITICAL();
;;;192        if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
;;;193            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;194        } else {
;;;195            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;196        }
;;;197        switch (opt) {
;;;198        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
;;;199            if (tasks_waiting == OS_FALSE) {
;;;200    #if OS_EVENT_NAME_SIZE > 1
;;;201                pevent->OSEventName[0] = '?';             /* Unknown name                             */
;;;202                pevent->OSEventName[1] = OS_ASCII_NUL;
;;;203    #endif
;;;204                pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;205                pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
;;;206                pevent->OSEventCnt     = 0;
;;;207                OSEventFreeList        = pevent;          /* Get next free event control block        */
;;;208                OS_EXIT_CRITICAL();
;;;209                *perr                  = OS_ERR_NONE;
;;;210                pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
;;;211            } else {
;;;212                OS_EXIT_CRITICAL();
;;;213                *perr                  = OS_ERR_TASK_WAITING;
;;;214                pevent_return          = pevent;
;;;215            }
;;;216            break;
;;;217    
;;;218        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
;;;219            while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
;;;220                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;221            }
;;;222    #if OS_EVENT_NAME_SIZE > 1
;;;223            pevent->OSEventName[0] = '?';                 /* Unknown name                             */
;;;224            pevent->OSEventName[1] = OS_ASCII_NUL;
;;;225    #endif
;;;226            pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;227            pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
;;;228            pevent->OSEventCnt     = 0;
;;;229            OSEventFreeList        = pevent;              /* Get next free event control block        */
;;;230            OS_EXIT_CRITICAL();
;;;231            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;232                OS_Sched();                               /* Find highest priority task ready to run  */
;;;233            }
;;;234            *perr                  = OS_ERR_NONE;
;;;235            pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
;;;236            break;
;;;237    
;;;238        default:
;;;239            OS_EXIT_CRITICAL();
;;;240            *perr                  = OS_ERR_INVALID_OPT;
;;;241            pevent_return          = pevent;
;;;242            break;
;;;243        }
;;;244        return (pevent_return);
;;;245    }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L3.22|
000016  b91c              CBNZ     r4,|L3.32|
000018  2004              MOVS     r0,#4                 ;179
00001a  7028              STRB     r0,[r5,#0]            ;179
00001c  4620              MOV      r0,r4                 ;180
00001e  e7f8              B        |L3.18|
                  |L3.32|
000020  7820              LDRB     r0,[r4,#0]            ;183
000022  2803              CMP      r0,#3                 ;183
000024  d003              BEQ      |L3.46|
000026  2001              MOVS     r0,#1                 ;184
000028  7028              STRB     r0,[r5,#0]            ;184
00002a  4620              MOV      r0,r4                 ;185
00002c  e7f1              B        |L3.18|
                  |L3.46|
00002e  482f              LDR      r0,|L3.236|
000030  7800              LDRB     r0,[r0,#0]            ;187  ; OSIntNesting
000032  2800              CMP      r0,#0                 ;187
000034  dd03              BLE      |L3.62|
000036  200f              MOVS     r0,#0xf               ;188
000038  7028              STRB     r0,[r5,#0]            ;188
00003a  4620              MOV      r0,r4                 ;189
00003c  e7e9              B        |L3.18|
                  |L3.62|
00003e  f7fffffe          BL       OS_CPU_SR_Save
000042  4681              MOV      r9,r0                 ;191
000044  7aa0              LDRB     r0,[r4,#0xa]          ;192
000046  b108              CBZ      r0,|L3.76|
000048  2701              MOVS     r7,#1                 ;193
00004a  e000              B        |L3.78|
                  |L3.76|
00004c  2700              MOVS     r7,#0                 ;195
                  |L3.78|
00004e  f1b80f00          CMP      r8,#0                 ;197
000052  d003              BEQ      |L3.92|
000054  f1b80f01          CMP      r8,#1                 ;197
000058  d13e              BNE      |L3.216|
00005a  e01b              B        |L3.148|
                  |L3.92|
00005c  b99f              CBNZ     r7,|L3.134|
00005e  203f              MOVS     r0,#0x3f              ;201
000060  74e0              STRB     r0,[r4,#0x13]         ;201
000062  2100              MOVS     r1,#0                 ;202
000064  7521              STRB     r1,[r4,#0x14]         ;202
000066  2000              MOVS     r0,#0                 ;204
000068  7020              STRB     r0,[r4,#0]            ;204
00006a  4821              LDR      r0,|L3.240|
00006c  6800              LDR      r0,[r0,#0]            ;205  ; OSEventFreeList
00006e  6060              STR      r0,[r4,#4]            ;205
000070  2000              MOVS     r0,#0                 ;206
000072  8120              STRH     r0,[r4,#8]            ;206
000074  481e              LDR      r0,|L3.240|
000076  6004              STR      r4,[r0,#0]            ;207  ; OSEventFreeList
000078  4648              MOV      r0,r9                 ;208
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  2000              MOVS     r0,#0                 ;209
000080  7028              STRB     r0,[r5,#0]            ;209
000082  2600              MOVS     r6,#0                 ;210
000084  e005              B        |L3.146|
                  |L3.134|
000086  4648              MOV      r0,r9                 ;212
000088  f7fffffe          BL       OS_CPU_SR_Restore
00008c  2049              MOVS     r0,#0x49              ;213
00008e  7028              STRB     r0,[r5,#0]            ;213
000090  4626              MOV      r6,r4                 ;214
                  |L3.146|
000092  e028              B        |L3.230|
                  |L3.148|
000094  e005              B        |L3.162|
                  |L3.150|
000096  2300              MOVS     r3,#0                 ;220
000098  2201              MOVS     r2,#1                 ;220
00009a  4619              MOV      r1,r3                 ;220
00009c  4620              MOV      r0,r4                 ;220
00009e  f7fffffe          BL       OS_EventTaskRdy
                  |L3.162|
0000a2  7aa0              LDRB     r0,[r4,#0xa]          ;219
0000a4  2800              CMP      r0,#0                 ;219
0000a6  d1f6              BNE      |L3.150|
0000a8  203f              MOVS     r0,#0x3f              ;223
0000aa  74e0              STRB     r0,[r4,#0x13]         ;223
0000ac  2100              MOVS     r1,#0                 ;224
0000ae  7521              STRB     r1,[r4,#0x14]         ;224
0000b0  2000              MOVS     r0,#0                 ;226
0000b2  7020              STRB     r0,[r4,#0]            ;226
0000b4  480e              LDR      r0,|L3.240|
0000b6  6800              LDR      r0,[r0,#0]            ;227  ; OSEventFreeList
0000b8  6060              STR      r0,[r4,#4]            ;227
0000ba  2000              MOVS     r0,#0                 ;228
0000bc  8120              STRH     r0,[r4,#8]            ;228
0000be  480c              LDR      r0,|L3.240|
0000c0  6004              STR      r4,[r0,#0]            ;229  ; OSEventFreeList
0000c2  4648              MOV      r0,r9                 ;230
0000c4  f7fffffe          BL       OS_CPU_SR_Restore
0000c8  2f01              CMP      r7,#1                 ;231
0000ca  d101              BNE      |L3.208|
0000cc  f7fffffe          BL       OS_Sched
                  |L3.208|
0000d0  2000              MOVS     r0,#0                 ;234
0000d2  7028              STRB     r0,[r5,#0]            ;234
0000d4  2600              MOVS     r6,#0                 ;235
0000d6  e006              B        |L3.230|
                  |L3.216|
0000d8  4648              MOV      r0,r9                 ;239
0000da  f7fffffe          BL       OS_CPU_SR_Restore
0000de  2007              MOVS     r0,#7                 ;240
0000e0  7028              STRB     r0,[r5,#0]            ;240
0000e2  4626              MOV      r6,r4                 ;241
0000e4  bf00              NOP                            ;242
                  |L3.230|
0000e6  bf00              NOP                            ;216
0000e8  4630              MOV      r0,r6                 ;244
0000ea  e792              B        |L3.18|
;;;246    #endif
                          ENDP

                  |L3.236|
                          DCD      OSIntNesting
                  |L3.240|
                          DCD      OSEventFreeList

                          AREA ||i.OSSemPend||, CODE, READONLY, ALIGN=2

                  OSSemPend PROC
;;;280    
;;;281    void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;282    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;283        INT8U      pend_stat;
;;;284    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;285        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0800          MOV      r8,#0
;;;286    #endif
;;;287    
;;;288    
;;;289    
;;;290    #if OS_ARG_CHK_EN > 0
;;;291        if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
00000e  b90c              CBNZ     r4,|L4.20|
                  |L4.16|
;;;292            return;
;;;293        }
;;;294        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;295            *perr = OS_ERR_PEVENT_NULL;
;;;296            return;
;;;297        }
;;;298    #endif
;;;299        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
;;;300            *perr = OS_ERR_EVENT_TYPE;
;;;301            return;
;;;302        }
;;;303         if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
;;;304            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
;;;305            return;
;;;306        }
;;;307        if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
;;;308            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
;;;309            return;
;;;310        }
;;;311        OS_ENTER_CRITICAL();
;;;312        if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
;;;313            pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
;;;314            OS_EXIT_CRITICAL();
;;;315            *perr = OS_ERR_NONE;
;;;316            return;
;;;317        }
;;;318        /* Otherwise, must wait until event occurs       */
;;;319        OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
;;;320        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;321        OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
;;;322        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;323        OS_EXIT_CRITICAL();
;;;324        OS_Sched();                                       /* Find next highest priority task ready         */
;;;325        OS_ENTER_CRITICAL();
;;;326        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) { /* See if we timed-out or aborted                */
;;;327            pend_stat = OSTCBCur->OSTCBStatPend;
;;;328            OS_EventTOAbort(pevent);
;;;329            OS_EXIT_CRITICAL();
;;;330            switch (pend_stat) {
;;;331            case OS_STAT_PEND_TO:
;;;332            default:
;;;333                *perr = OS_ERR_TIMEOUT;              /* Indicate that didn't get event within TO      */
;;;334                break;
;;;335    
;;;336            case OS_STAT_PEND_ABORT:
;;;337                *perr = OS_ERR_PEND_ABORT;           /* Indicate that we aborted                      */
;;;338                break;
;;;339            }
;;;340            return;
;;;341        }
;;;342        OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
;;;343        OS_EXIT_CRITICAL();
;;;344        *perr = OS_ERR_NONE;
;;;345    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L4.20|
000014  b915              CBNZ     r5,|L4.28|
000016  2004              MOVS     r0,#4                 ;295
000018  7020              STRB     r0,[r4,#0]            ;295
00001a  e7f9              B        |L4.16|
                  |L4.28|
00001c  7828              LDRB     r0,[r5,#0]            ;299
00001e  2803              CMP      r0,#3                 ;299
000020  d002              BEQ      |L4.40|
000022  2001              MOVS     r0,#1                 ;300
000024  7020              STRB     r0,[r4,#0]            ;300
000026  e7f3              B        |L4.16|
                  |L4.40|
000028  4830              LDR      r0,|L4.236|
00002a  7800              LDRB     r0,[r0,#0]            ;303  ; OSIntNesting
00002c  2800              CMP      r0,#0                 ;303
00002e  dd02              BLE      |L4.54|
000030  2002              MOVS     r0,#2                 ;304
000032  7020              STRB     r0,[r4,#0]            ;304
000034  e7ec              B        |L4.16|
                  |L4.54|
000036  482e              LDR      r0,|L4.240|
000038  7800              LDRB     r0,[r0,#0]            ;307  ; OSLockNesting
00003a  2800              CMP      r0,#0                 ;307
00003c  dd02              BLE      |L4.68|
00003e  200d              MOVS     r0,#0xd               ;308
000040  7020              STRB     r0,[r4,#0]            ;308
000042  e7e5              B        |L4.16|
                  |L4.68|
000044  f7fffffe          BL       OS_CPU_SR_Save
000048  4680              MOV      r8,r0                 ;311
00004a  8928              LDRH     r0,[r5,#8]            ;312
00004c  2800              CMP      r0,#0                 ;312
00004e  dd08              BLE      |L4.98|
000050  8928              LDRH     r0,[r5,#8]            ;313
000052  1e40              SUBS     r0,r0,#1              ;313
000054  8128              STRH     r0,[r5,#8]            ;313
000056  4640              MOV      r0,r8                 ;314
000058  f7fffffe          BL       OS_CPU_SR_Restore
00005c  2000              MOVS     r0,#0                 ;315
00005e  7020              STRB     r0,[r4,#0]            ;315
000060  e7d6              B        |L4.16|
                  |L4.98|
000062  4824              LDR      r0,|L4.244|
000064  6800              LDR      r0,[r0,#0]            ;319  ; OSTCBCur
000066  f890002c          LDRB     r0,[r0,#0x2c]         ;319
00006a  f0400001          ORR      r0,r0,#1              ;319
00006e  4921              LDR      r1,|L4.244|
000070  6809              LDR      r1,[r1,#0]            ;319  ; OSTCBCur
000072  f881002c          STRB     r0,[r1,#0x2c]         ;319
000076  2000              MOVS     r0,#0                 ;320
000078  491e              LDR      r1,|L4.244|
00007a  6809              LDR      r1,[r1,#0]            ;320  ; OSTCBCur
00007c  f881002d          STRB     r0,[r1,#0x2d]         ;320
000080  481c              LDR      r0,|L4.244|
000082  6800              LDR      r0,[r0,#0]            ;321  ; OSTCBCur
000084  8546              STRH     r6,[r0,#0x2a]         ;321
000086  4628              MOV      r0,r5                 ;322
000088  f7fffffe          BL       OS_EventTaskWait
00008c  4640              MOV      r0,r8                 ;323
00008e  f7fffffe          BL       OS_CPU_SR_Restore
000092  f7fffffe          BL       OS_Sched
000096  f7fffffe          BL       OS_CPU_SR_Save
00009a  4680              MOV      r8,r0                 ;325
00009c  4815              LDR      r0,|L4.244|
00009e  6800              LDR      r0,[r0,#0]            ;326  ; OSTCBCur
0000a0  f890002d          LDRB     r0,[r0,#0x2d]         ;326
0000a4  b1b0              CBZ      r0,|L4.212|
0000a6  4813              LDR      r0,|L4.244|
0000a8  6800              LDR      r0,[r0,#0]            ;327  ; OSTCBCur
0000aa  f890702d          LDRB     r7,[r0,#0x2d]         ;327
0000ae  4628              MOV      r0,r5                 ;328
0000b0  f7fffffe          BL       OS_EventTOAbort
0000b4  4640              MOV      r0,r8                 ;329
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  2f01              CMP      r7,#1                 ;330
0000bc  d002              BEQ      |L4.196|
0000be  2f02              CMP      r7,#2                 ;330
0000c0  d003              BEQ      |L4.202|
0000c2  bf00              NOP                            ;331
                  |L4.196|
0000c4  200a              MOVS     r0,#0xa               ;333
0000c6  7020              STRB     r0,[r4,#0]            ;333
0000c8  e002              B        |L4.208|
                  |L4.202|
0000ca  200e              MOVS     r0,#0xe               ;337
0000cc  7020              STRB     r0,[r4,#0]            ;337
0000ce  bf00              NOP                            ;338
                  |L4.208|
0000d0  bf00              NOP                            ;334
0000d2  e79d              B        |L4.16|
                  |L4.212|
0000d4  2000              MOVS     r0,#0                 ;342
0000d6  4907              LDR      r1,|L4.244|
0000d8  6809              LDR      r1,[r1,#0]            ;342  ; OSTCBCur
0000da  61c8              STR      r0,[r1,#0x1c]         ;342
0000dc  4640              MOV      r0,r8                 ;343
0000de  f7fffffe          BL       OS_CPU_SR_Restore
0000e2  2000              MOVS     r0,#0                 ;344
0000e4  7020              STRB     r0,[r4,#0]            ;344
0000e6  bf00              NOP      
0000e8  e792              B        |L4.16|
;;;346    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L4.236|
                          DCD      OSIntNesting
                  |L4.240|
                          DCD      OSLockNesting
                  |L4.244|
                          DCD      OSTCBCur

                          AREA ||i.OSSemPendAbort||, CODE, READONLY, ALIGN=1

                  OSSemPendAbort PROC
;;;381    #if OS_SEM_PEND_ABORT_EN > 0
;;;382    INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;383    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;384        INT8U      nbr_tasks;
;;;385    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;386        OS_CPU_SR  cpu_sr = 0;
00000a  f04f0800          MOV      r8,#0
;;;387    #endif
;;;388    
;;;389    
;;;390    
;;;391    #if OS_ARG_CHK_EN > 0
;;;392        if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
00000e  b914              CBNZ     r4,|L5.22|
;;;393            return (0);
000010  2000              MOVS     r0,#0
                  |L5.18|
;;;394        }
;;;395        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;396            *perr = OS_ERR_PEVENT_NULL;
;;;397            return (0);
;;;398        }
;;;399    #endif
;;;400        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
;;;401            *perr = OS_ERR_EVENT_TYPE;
;;;402            return (0);
;;;403        }
;;;404        OS_ENTER_CRITICAL();
;;;405        if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
;;;406            nbr_tasks = 0;
;;;407            switch (opt) {
;;;408            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
;;;409                while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
;;;410                    (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;411                    nbr_tasks++;
;;;412                }
;;;413                break;
;;;414    
;;;415            case OS_PEND_OPT_NONE:                    /* No,  ready HPT       waiting on semaphore     */
;;;416            default:
;;;417                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;418                nbr_tasks++;
;;;419                break;
;;;420            }
;;;421            OS_EXIT_CRITICAL();
;;;422            OS_Sched();                                   /* Find HPT ready to run                         */
;;;423            *perr = OS_ERR_PEND_ABORT;
;;;424            return (nbr_tasks);
;;;425        }
;;;426        OS_EXIT_CRITICAL();
;;;427        *perr = OS_ERR_NONE;
;;;428        return (0);                                       /* No tasks waiting on semaphore                 */
;;;429    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L5.22|
000016  b91d              CBNZ     r5,|L5.32|
000018  2004              MOVS     r0,#4                 ;396
00001a  7020              STRB     r0,[r4,#0]            ;396
00001c  2000              MOVS     r0,#0                 ;397
00001e  e7f8              B        |L5.18|
                  |L5.32|
000020  7828              LDRB     r0,[r5,#0]            ;400
000022  2803              CMP      r0,#3                 ;400
000024  d003              BEQ      |L5.46|
000026  2001              MOVS     r0,#1                 ;401
000028  7020              STRB     r0,[r4,#0]            ;401
00002a  2000              MOVS     r0,#0                 ;402
00002c  e7f1              B        |L5.18|
                  |L5.46|
00002e  f7fffffe          BL       OS_CPU_SR_Save
000032  4680              MOV      r8,r0                 ;404
000034  7aa8              LDRB     r0,[r5,#0xa]          ;405
000036  b320              CBZ      r0,|L5.130|
000038  2600              MOVS     r6,#0                 ;406
00003a  b17f              CBZ      r7,|L5.92|
00003c  2f01              CMP      r7,#1                 ;407
00003e  d10c              BNE      |L5.90|
000040  e007              B        |L5.82|
                  |L5.66|
000042  2302              MOVS     r3,#2                 ;410
000044  2201              MOVS     r2,#1                 ;410
000046  2100              MOVS     r1,#0                 ;410
000048  4628              MOV      r0,r5                 ;410
00004a  f7fffffe          BL       OS_EventTaskRdy
00004e  1c70              ADDS     r0,r6,#1              ;411
000050  b2c6              UXTB     r6,r0                 ;411
                  |L5.82|
000052  7aa8              LDRB     r0,[r5,#0xa]          ;409
000054  2800              CMP      r0,#0                 ;409
000056  d1f4              BNE      |L5.66|
000058  e009              B        |L5.110|
                  |L5.90|
00005a  bf00              NOP                            ;415
                  |L5.92|
00005c  2302              MOVS     r3,#2                 ;417
00005e  2201              MOVS     r2,#1                 ;417
000060  2100              MOVS     r1,#0                 ;417
000062  4628              MOV      r0,r5                 ;417
000064  f7fffffe          BL       OS_EventTaskRdy
000068  1c70              ADDS     r0,r6,#1              ;418
00006a  b2c6              UXTB     r6,r0                 ;418
00006c  bf00              NOP                            ;419
                  |L5.110|
00006e  bf00              NOP                            ;413
000070  4640              MOV      r0,r8                 ;421
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  f7fffffe          BL       OS_Sched
00007a  200e              MOVS     r0,#0xe               ;423
00007c  7020              STRB     r0,[r4,#0]            ;423
00007e  4630              MOV      r0,r6                 ;424
000080  e7c7              B        |L5.18|
                  |L5.130|
000082  4640              MOV      r0,r8                 ;426
000084  f7fffffe          BL       OS_CPU_SR_Restore
000088  2000              MOVS     r0,#0                 ;427
00008a  7020              STRB     r0,[r4,#0]            ;427
00008c  bf00              NOP                            ;428
00008e  e7c0              B        |L5.18|
;;;430    #endif
                          ENDP


                          AREA ||i.OSSemPost||, CODE, READONLY, ALIGN=1

                  OSSemPost PROC
;;;450    
;;;451    INT8U  OSSemPost (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;452    {
000002  4604              MOV      r4,r0
;;;453    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;454        OS_CPU_SR  cpu_sr = 0;
000004  2500              MOVS     r5,#0
;;;455    #endif
;;;456    
;;;457    
;;;458    
;;;459    #if OS_ARG_CHK_EN > 0
;;;460        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
000006  b90c              CBNZ     r4,|L6.12|
;;;461            return (OS_ERR_PEVENT_NULL);
000008  2004              MOVS     r0,#4
                  |L6.10|
;;;462        }
;;;463    #endif
;;;464        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
;;;465            return (OS_ERR_EVENT_TYPE);
;;;466        }
;;;467        OS_ENTER_CRITICAL();
;;;468        if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
;;;469            /* Ready HPT waiting on event                    */
;;;470            (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;471            OS_EXIT_CRITICAL();
;;;472            OS_Sched();                                   /* Find HPT ready to run                         */
;;;473            return (OS_ERR_NONE);
;;;474        }
;;;475        if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
;;;476            pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
;;;477            OS_EXIT_CRITICAL();
;;;478            return (OS_ERR_NONE);
;;;479        }
;;;480        OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
;;;481        return (OS_ERR_SEM_OVF);
;;;482    }
00000a  bd70              POP      {r4-r6,pc}
                  |L6.12|
00000c  7820              LDRB     r0,[r4,#0]            ;464
00000e  2803              CMP      r0,#3                 ;464
000010  d001              BEQ      |L6.22|
000012  2001              MOVS     r0,#1                 ;465
000014  e7f9              B        |L6.10|
                  |L6.22|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4605              MOV      r5,r0                 ;467
00001c  7aa0              LDRB     r0,[r4,#0xa]          ;468
00001e  b160              CBZ      r0,|L6.58|
000020  2300              MOVS     r3,#0                 ;470
000022  2201              MOVS     r2,#1                 ;470
000024  4619              MOV      r1,r3                 ;470
000026  4620              MOV      r0,r4                 ;470
000028  f7fffffe          BL       OS_EventTaskRdy
00002c  4628              MOV      r0,r5                 ;471
00002e  f7fffffe          BL       OS_CPU_SR_Restore
000032  f7fffffe          BL       OS_Sched
000036  2000              MOVS     r0,#0                 ;473
000038  e7e7              B        |L6.10|
                  |L6.58|
00003a  8920              LDRH     r0,[r4,#8]            ;475
00003c  f64f71ff          MOV      r1,#0xffff            ;475
000040  4288              CMP      r0,r1                 ;475
000042  d207              BCS      |L6.84|
000044  8920              LDRH     r0,[r4,#8]            ;476
000046  1c40              ADDS     r0,r0,#1              ;476
000048  8120              STRH     r0,[r4,#8]            ;476
00004a  4628              MOV      r0,r5                 ;477
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  2000              MOVS     r0,#0                 ;478
000052  e7da              B        |L6.10|
                  |L6.84|
000054  4628              MOV      r0,r5                 ;480
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  2032              MOVS     r0,#0x32              ;481
00005c  e7d5              B        |L6.10|
;;;483    
                          ENDP


                          AREA ||i.OSSemQuery||, CODE, READONLY, ALIGN=1

                  OSSemQuery PROC
;;;504    #if OS_SEM_QUERY_EN > 0
;;;505    INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;506    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;507    #if OS_LOWEST_PRIO <= 63
;;;508        INT8U     *psrc;
;;;509        INT8U     *pdest;
;;;510    #else
;;;511        INT16U    *psrc;
;;;512        INT16U    *pdest;
;;;513    #endif
;;;514        INT8U      i;
;;;515    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;516        OS_CPU_SR  cpu_sr = 0;
000008  f04f0900          MOV      r9,#0
;;;517    #endif
;;;518    
;;;519    
;;;520    
;;;521    #if OS_ARG_CHK_EN > 0
;;;522        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
00000c  b914              CBNZ     r4,|L7.20|
;;;523            return (OS_ERR_PEVENT_NULL);
00000e  2004              MOVS     r0,#4
                  |L7.16|
;;;524        }
;;;525        if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
;;;526            return (OS_ERR_PDATA_NULL);
;;;527        }
;;;528    #endif
;;;529        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
;;;530            return (OS_ERR_EVENT_TYPE);
;;;531        }
;;;532        OS_ENTER_CRITICAL();
;;;533        p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
;;;534        psrc                   = &pevent->OSEventTbl[0];
;;;535        pdest                  = &p_sem_data->OSEventTbl[0];
;;;536        for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
;;;537            *pdest++ = *psrc++;
;;;538        }
;;;539        p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
;;;540        OS_EXIT_CRITICAL();
;;;541        return (OS_ERR_NONE);
;;;542    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L7.20|
000014  b90d              CBNZ     r5,|L7.26|
000016  2009              MOVS     r0,#9                 ;526
000018  e7fa              B        |L7.16|
                  |L7.26|
00001a  7820              LDRB     r0,[r4,#0]            ;529
00001c  2803              CMP      r0,#3                 ;529
00001e  d001              BEQ      |L7.36|
000020  2001              MOVS     r0,#1                 ;530
000022  e7f5              B        |L7.16|
                  |L7.36|
000024  f7fffffe          BL       OS_CPU_SR_Save
000028  4681              MOV      r9,r0                 ;532
00002a  7aa0              LDRB     r0,[r4,#0xa]          ;533
00002c  72a8              STRB     r0,[r5,#0xa]          ;533
00002e  f104070b          ADD      r7,r4,#0xb            ;534
000032  1cae              ADDS     r6,r5,#2              ;535
000034  f04f0800          MOV      r8,#0                 ;536
000038  e007              B        |L7.74|
                  |L7.58|
00003a  f8170b01          LDRB     r0,[r7],#1            ;537
00003e  f8060b01          STRB     r0,[r6],#1            ;537
000042  f1080001          ADD      r0,r8,#1              ;536
000046  f00008ff          AND      r8,r0,#0xff           ;536
                  |L7.74|
00004a  f1b80f08          CMP      r8,#8                 ;536
00004e  dbf4              BLT      |L7.58|
000050  8920              LDRH     r0,[r4,#8]            ;539
000052  8028              STRH     r0,[r5,#0]            ;539
000054  4648              MOV      r0,r9                 ;540
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  2000              MOVS     r0,#0                 ;541
00005c  e7d8              B        |L7.16|
;;;543    #endif                                                     /* OS_SEM_QUERY_EN                          */
                          ENDP


                          AREA ||i.OSSemSet||, CODE, READONLY, ALIGN=1

                  OSSemSet PROC
;;;570    #if OS_SEM_SET_EN > 0
;;;571    void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;572    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;573    #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
;;;574        OS_CPU_SR  cpu_sr = 0;
00000a  2700              MOVS     r7,#0
;;;575    #endif
;;;576    
;;;577    
;;;578    
;;;579    #if OS_ARG_CHK_EN > 0
;;;580        if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
00000c  b90d              CBNZ     r5,|L8.18|
                  |L8.14|
;;;581            return;
;;;582        }
;;;583        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
;;;584            *perr = OS_ERR_PEVENT_NULL;
;;;585            return;
;;;586        }
;;;587    #endif
;;;588        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
;;;589            *perr = OS_ERR_EVENT_TYPE;
;;;590            return;
;;;591        }
;;;592        OS_ENTER_CRITICAL();
;;;593        *perr = OS_ERR_NONE;
;;;594        if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
;;;595            pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
;;;596        } else {                                          /* No                                            */
;;;597            if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
;;;598                pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
;;;599            } else {
;;;600                *perr              = OS_ERR_TASK_WAITING;
;;;601            }
;;;602        }
;;;603        OS_EXIT_CRITICAL();
;;;604    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L8.18|
000012  b914              CBNZ     r4,|L8.26|
000014  2004              MOVS     r0,#4                 ;584
000016  7028              STRB     r0,[r5,#0]            ;584
000018  e7f9              B        |L8.14|
                  |L8.26|
00001a  7820              LDRB     r0,[r4,#0]            ;588
00001c  2803              CMP      r0,#3                 ;588
00001e  d002              BEQ      |L8.38|
000020  2001              MOVS     r0,#1                 ;589
000022  7028              STRB     r0,[r5,#0]            ;589
000024  e7f3              B        |L8.14|
                  |L8.38|
000026  f7fffffe          BL       OS_CPU_SR_Save
00002a  4607              MOV      r7,r0                 ;592
00002c  2000              MOVS     r0,#0                 ;593
00002e  7028              STRB     r0,[r5,#0]            ;593
000030  8920              LDRH     r0,[r4,#8]            ;594
000032  2800              CMP      r0,#0                 ;594
000034  dd01              BLE      |L8.58|
000036  8126              STRH     r6,[r4,#8]            ;595
000038  e005              B        |L8.70|
                  |L8.58|
00003a  7aa0              LDRB     r0,[r4,#0xa]          ;597
00003c  b908              CBNZ     r0,|L8.66|
00003e  8126              STRH     r6,[r4,#8]            ;598
000040  e001              B        |L8.70|
                  |L8.66|
000042  2049              MOVS     r0,#0x49              ;600
000044  7028              STRB     r0,[r5,#0]            ;600
                  |L8.70|
000046  4638              MOV      r0,r7                 ;603
000048  f7fffffe          BL       OS_CPU_SR_Restore
00004c  bf00              NOP      
00004e  e7de              B        |L8.14|
;;;605    #endif
                          ENDP

