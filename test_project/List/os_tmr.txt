; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_tmr.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_tmr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\os_tmr.crf Source\uCOS-II\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;112    #if OS_TMR_EN > 0
;;;113    OS_TMR  *OSTmrCreate (INT32U           dly,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;114                          INT32U           period,
;;;115                          INT8U            opt,
;;;116                          OS_TMR_CALLBACK  callback,
;;;117                          void            *callback_arg,
;;;118                          INT8U           *pname,
;;;119                          INT8U           *perr)
;;;120    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
00000c  e9dd950b          LDRD     r9,r5,[sp,#0x2c]
;;;121        OS_TMR   *ptmr;
;;;122    #if OS_TMR_CFG_NAME_SIZE > 0
;;;123        INT8U     len;
;;;124    #endif
;;;125    
;;;126    
;;;127    #if OS_ARG_CHK_EN > 0
;;;128        if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
000010  b915              CBNZ     r5,|L1.24|
;;;129            return ((OS_TMR *)0);
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;130        }
;;;131        switch (opt) {
;;;132        case OS_TMR_OPT_PERIODIC:
;;;133            if (period == 0) {
;;;134                *perr = OS_ERR_TMR_INVALID_PERIOD;
;;;135                return ((OS_TMR *)0);
;;;136            }
;;;137            break;
;;;138    
;;;139        case OS_TMR_OPT_ONE_SHOT:
;;;140            if (dly == 0) {
;;;141                *perr = OS_ERR_TMR_INVALID_DLY;
;;;142                return ((OS_TMR *)0);
;;;143            }
;;;144            break;
;;;145    
;;;146        default:
;;;147            *perr = OS_ERR_TMR_INVALID_OPT;
;;;148            return ((OS_TMR *)0);
;;;149        }
;;;150    #endif
;;;151        if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
;;;152            *perr  = OS_ERR_TMR_ISR;
;;;153            return ((OS_TMR *)0);
;;;154        }
;;;155        OSTmr_Lock();
;;;156        ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
;;;157        if (ptmr == (OS_TMR *)0) {
;;;158            OSTmr_Unlock();
;;;159            *perr = OS_ERR_TMR_NON_AVAIL;
;;;160            return ((OS_TMR *)0);
;;;161        }
;;;162        ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
;;;163        ptmr->OSTmrDly         = dly;
;;;164        ptmr->OSTmrPeriod      = period;
;;;165        ptmr->OSTmrOpt         = opt;
;;;166        ptmr->OSTmrCallback    = callback;
;;;167        ptmr->OSTmrCallbackArg = callback_arg;
;;;168    #if OS_TMR_CFG_NAME_SIZE > 0
;;;169        if (pname !=(INT8U *)0) {
;;;170            len = OS_StrLen(pname);                             /* Copy timer name                                        */
;;;171            if (len < OS_TMR_CFG_NAME_SIZE) {
;;;172                (void)OS_StrCopy(ptmr->OSTmrName, pname);
;;;173            } else {
;;;174    #if OS_TMR_CFG_NAME_SIZE > 1
;;;175                ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
;;;176                ptmr->OSTmrName[1] = OS_ASCII_NUL;
;;;177    #endif
;;;178                *perr              = OS_ERR_TMR_NAME_TOO_LONG;
;;;179                OSTmr_Unlock();
;;;180                return (ptmr);
;;;181            }
;;;182        }
;;;183    #endif
;;;184        OSTmr_Unlock();
;;;185        *perr = OS_ERR_NONE;
;;;186        return (ptmr);
;;;187    }
000014  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.24|
000018  f1b80f01          CMP      r8,#1                 ;131
00001c  d008              BEQ      |L1.48|
00001e  f1b80f02          CMP      r8,#2                 ;131
000022  d10b              BNE      |L1.60|
000024  b91f              CBNZ     r7,|L1.46|
000026  2083              MOVS     r0,#0x83              ;134
000028  7028              STRB     r0,[r5,#0]            ;134
00002a  2000              MOVS     r0,#0                 ;135
00002c  e7f2              B        |L1.20|
                  |L1.46|
00002e  e009              B        |L1.68|
                  |L1.48|
000030  b91e              CBNZ     r6,|L1.58|
000032  2082              MOVS     r0,#0x82              ;141
000034  7028              STRB     r0,[r5,#0]            ;141
000036  2000              MOVS     r0,#0                 ;142
000038  e7ec              B        |L1.20|
                  |L1.58|
00003a  e003              B        |L1.68|
                  |L1.60|
00003c  2084              MOVS     r0,#0x84              ;147
00003e  7028              STRB     r0,[r5,#0]            ;147
000040  2000              MOVS     r0,#0                 ;148
000042  e7e7              B        |L1.20|
                  |L1.68|
000044  bf00              NOP                            ;137
000046  4820              LDR      r0,|L1.200|
000048  7800              LDRB     r0,[r0,#0]            ;151  ; OSIntNesting
00004a  2800              CMP      r0,#0                 ;151
00004c  dd03              BLE      |L1.86|
00004e  208b              MOVS     r0,#0x8b              ;152
000050  7028              STRB     r0,[r5,#0]            ;152
000052  2000              MOVS     r0,#0                 ;153
000054  e7de              B        |L1.20|
                  |L1.86|
000056  f7fffffe          BL       OSTmr_Lock
00005a  f7fffffe          BL       OSTmr_Alloc
00005e  4604              MOV      r4,r0                 ;156
000060  b92c              CBNZ     r4,|L1.110|
000062  f7fffffe          BL       OSTmr_Unlock
000066  2086              MOVS     r0,#0x86              ;159
000068  7028              STRB     r0,[r5,#0]            ;159
00006a  2000              MOVS     r0,#0                 ;160
00006c  e7d2              B        |L1.20|
                  |L1.110|
00006e  2001              MOVS     r0,#1                 ;162
000070  f8840031          STRB     r0,[r4,#0x31]         ;162
000074  61a6              STR      r6,[r4,#0x18]         ;163
000076  61e7              STR      r7,[r4,#0x1c]         ;164
000078  f8848030          STRB     r8,[r4,#0x30]         ;165
00007c  f8c4b004          STR      r11,[r4,#4]           ;166
000080  980a              LDR      r0,[sp,#0x28]         ;167
000082  60a0              STR      r0,[r4,#8]            ;167
000084  f1b90f00          CMP      r9,#0                 ;169
000088  d018              BEQ      |L1.188|
00008a  4648              MOV      r0,r9                 ;170
00008c  f7fffffe          BL       OS_StrLen
000090  4682              MOV      r10,r0                ;170
000092  f1ba0f10          CMP      r10,#0x10             ;171
000096  da05              BGE      |L1.164|
000098  4649              MOV      r1,r9                 ;172
00009a  f1040020          ADD      r0,r4,#0x20           ;172
00009e  f7fffffe          BL       OS_StrCopy
0000a2  e00b              B        |L1.188|
                  |L1.164|
0000a4  2023              MOVS     r0,#0x23              ;175
0000a6  f8840020          STRB     r0,[r4,#0x20]         ;175
0000aa  2100              MOVS     r1,#0                 ;176
0000ac  2021              MOVS     r0,#0x21              ;176
0000ae  5501              STRB     r1,[r0,r4]            ;176
0000b0  208c              MOVS     r0,#0x8c              ;178
0000b2  7028              STRB     r0,[r5,#0]            ;178
0000b4  f7fffffe          BL       OSTmr_Unlock
0000b8  4620              MOV      r0,r4                 ;180
0000ba  e7ab              B        |L1.20|
                  |L1.188|
0000bc  f7fffffe          BL       OSTmr_Unlock
0000c0  2000              MOVS     r0,#0                 ;185
0000c2  7028              STRB     r0,[r5,#0]            ;185
0000c4  4620              MOV      r0,r4                 ;186
0000c6  e7a5              B        |L1.20|
;;;188    #endif
                          ENDP

                  |L1.200|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrDel||, CODE, READONLY, ALIGN=2

                  OSTmrDel PROC
;;;212    #if OS_TMR_EN > 0
;;;213    BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;214                       INT8U   *perr)
;;;215    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;216    #if OS_ARG_CHK_EN > 0
;;;217        if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
000006  b90c              CBNZ     r4,|L2.12|
;;;218            return (OS_FALSE);
000008  2000              MOVS     r0,#0
                  |L2.10|
;;;219        }
;;;220        if (ptmr == (OS_TMR *)0) {
;;;221            *perr = OS_ERR_TMR_INVALID;
;;;222            return (OS_FALSE);
;;;223        }
;;;224    #endif
;;;225        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
;;;226            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;227            return (OS_FALSE);
;;;228        }
;;;229        if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
;;;230            *perr  = OS_ERR_TMR_ISR;
;;;231            return (OS_FALSE);
;;;232        }
;;;233        OSTmr_Lock();
;;;234        switch (ptmr->OSTmrState) {
;;;235        case OS_TMR_STATE_RUNNING:
;;;236            OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
;;;237            OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;238            OSTmr_Unlock();
;;;239            *perr = OS_ERR_NONE;
;;;240            return (OS_TRUE);
;;;241    
;;;242        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
;;;243        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
;;;244            OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;245            OSTmr_Unlock();
;;;246            *perr = OS_ERR_NONE;
;;;247            return (OS_TRUE);
;;;248    
;;;249        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
;;;250            OSTmr_Unlock();
;;;251            *perr = OS_ERR_TMR_INACTIVE;
;;;252            return (OS_FALSE);
;;;253    
;;;254        default:
;;;255            OSTmr_Unlock();
;;;256            *perr = OS_ERR_TMR_INVALID_STATE;
;;;257            return (OS_FALSE);
;;;258        }
;;;259    }
00000a  bd70              POP      {r4-r6,pc}
                  |L2.12|
00000c  b91d              CBNZ     r5,|L2.22|
00000e  208a              MOVS     r0,#0x8a              ;221
000010  7020              STRB     r0,[r4,#0]            ;221
000012  2000              MOVS     r0,#0                 ;222
000014  e7f9              B        |L2.10|
                  |L2.22|
000016  7828              LDRB     r0,[r5,#0]            ;225
000018  2864              CMP      r0,#0x64              ;225
00001a  d003              BEQ      |L2.36|
00001c  2089              MOVS     r0,#0x89              ;226
00001e  7020              STRB     r0,[r4,#0]            ;226
000020  2000              MOVS     r0,#0                 ;227
000022  e7f2              B        |L2.10|
                  |L2.36|
000024  481a              LDR      r0,|L2.144|
000026  7800              LDRB     r0,[r0,#0]            ;229  ; OSIntNesting
000028  2800              CMP      r0,#0                 ;229
00002a  dd03              BLE      |L2.52|
00002c  208b              MOVS     r0,#0x8b              ;230
00002e  7020              STRB     r0,[r4,#0]            ;230
000030  2000              MOVS     r0,#0                 ;231
000032  e7ea              B        |L2.10|
                  |L2.52|
000034  f7fffffe          BL       OSTmr_Lock
000038  f8950031          LDRB     r0,[r5,#0x31]         ;234
00003c  b1d8              CBZ      r0,|L2.118|
00003e  2801              CMP      r0,#1                 ;234
000040  d00f              BEQ      |L2.98|
000042  2802              CMP      r0,#2                 ;234
000044  d00e              BEQ      |L2.100|
000046  2803              CMP      r0,#3                 ;234
000048  d11b              BNE      |L2.130|
00004a  4628              MOV      r0,r5                 ;236
00004c  f7fffffe          BL       OSTmr_Unlink
000050  4628              MOV      r0,r5                 ;237
000052  f7fffffe          BL       OSTmr_Free
000056  f7fffffe          BL       OSTmr_Unlock
00005a  2000              MOVS     r0,#0                 ;239
00005c  7020              STRB     r0,[r4,#0]            ;239
00005e  2001              MOVS     r0,#1                 ;240
000060  e7d3              B        |L2.10|
                  |L2.98|
000062  bf00              NOP                            ;243
                  |L2.100|
000064  4628              MOV      r0,r5                 ;244
000066  f7fffffe          BL       OSTmr_Free
00006a  f7fffffe          BL       OSTmr_Unlock
00006e  2000              MOVS     r0,#0                 ;246
000070  7020              STRB     r0,[r4,#0]            ;246
000072  2001              MOVS     r0,#1                 ;247
000074  e7c9              B        |L2.10|
                  |L2.118|
000076  f7fffffe          BL       OSTmr_Unlock
00007a  2087              MOVS     r0,#0x87              ;251
00007c  7020              STRB     r0,[r4,#0]            ;251
00007e  2000              MOVS     r0,#0                 ;252
000080  e7c3              B        |L2.10|
                  |L2.130|
000082  f7fffffe          BL       OSTmr_Unlock
000086  208d              MOVS     r0,#0x8d              ;256
000088  7020              STRB     r0,[r4,#0]            ;256
00008a  2000              MOVS     r0,#0                 ;257
00008c  e7bd              B        |L2.10|
;;;260    #endif
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrNameGet||, CODE, READONLY, ALIGN=2

                  OSTmrNameGet PROC
;;;287    #if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
;;;288    INT8U  OSTmrNameGet (OS_TMR  *ptmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;289                         INT8U   *pdest,
;;;290                         INT8U   *perr)
;;;291    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;292        INT8U  len;
;;;293    
;;;294    
;;;295    #if OS_ARG_CHK_EN > 0
;;;296        if (perr == (INT8U *)0) {
00000a  b914              CBNZ     r4,|L3.18|
;;;297            return (0);
00000c  2000              MOVS     r0,#0
                  |L3.14|
;;;298        }
;;;299        if (pdest == (INT8U *)0) {
;;;300            *perr = OS_ERR_TMR_INVALID_DEST;
;;;301            return (0);
;;;302        }
;;;303        if (ptmr == (OS_TMR *)0) {
;;;304            *perr = OS_ERR_TMR_INVALID;
;;;305            return (0);
;;;306        }
;;;307    #endif
;;;308        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
;;;309            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;310            return (0);
;;;311        }
;;;312        if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
;;;313            *perr = OS_ERR_NAME_GET_ISR;
;;;314            return (0);
;;;315        }
;;;316        OSTmr_Lock();
;;;317        switch (ptmr->OSTmrState) {
;;;318        case OS_TMR_STATE_RUNNING:
;;;319        case OS_TMR_STATE_STOPPED:
;;;320        case OS_TMR_STATE_COMPLETED:
;;;321            len   = OS_StrCopy(pdest, ptmr->OSTmrName);
;;;322            OSTmr_Unlock();
;;;323            *perr = OS_ERR_NONE;
;;;324            return (len);
;;;325    
;;;326        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
;;;327            OSTmr_Unlock();
;;;328            *perr = OS_ERR_TMR_INACTIVE;
;;;329            return (0);
;;;330    
;;;331        default:
;;;332            OSTmr_Unlock();
;;;333            *perr = OS_ERR_TMR_INVALID_STATE;
;;;334            return (0);
;;;335        }
;;;336    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L3.18|
000012  b91e              CBNZ     r6,|L3.28|
000014  2088              MOVS     r0,#0x88              ;300
000016  7020              STRB     r0,[r4,#0]            ;300
000018  2000              MOVS     r0,#0                 ;301
00001a  e7f8              B        |L3.14|
                  |L3.28|
00001c  b91d              CBNZ     r5,|L3.38|
00001e  208a              MOVS     r0,#0x8a              ;304
000020  7020              STRB     r0,[r4,#0]            ;304
000022  2000              MOVS     r0,#0                 ;305
000024  e7f3              B        |L3.14|
                  |L3.38|
000026  7828              LDRB     r0,[r5,#0]            ;308
000028  2864              CMP      r0,#0x64              ;308
00002a  d003              BEQ      |L3.52|
00002c  2089              MOVS     r0,#0x89              ;309
00002e  7020              STRB     r0,[r4,#0]            ;309
000030  2000              MOVS     r0,#0                 ;310
000032  e7ec              B        |L3.14|
                  |L3.52|
000034  4816              LDR      r0,|L3.144|
000036  7800              LDRB     r0,[r0,#0]            ;312  ; OSIntNesting
000038  2800              CMP      r0,#0                 ;312
00003a  dd03              BLE      |L3.68|
00003c  2011              MOVS     r0,#0x11              ;313
00003e  7020              STRB     r0,[r4,#0]            ;313
000040  2000              MOVS     r0,#0                 ;314
000042  e7e4              B        |L3.14|
                  |L3.68|
000044  f7fffffe          BL       OSTmr_Lock
000048  f8950031          LDRB     r0,[r5,#0x31]         ;317
00004c  b198              CBZ      r0,|L3.118|
00004e  2801              CMP      r0,#1                 ;317
000050  d004              BEQ      |L3.92|
000052  2802              CMP      r0,#2                 ;317
000054  d003              BEQ      |L3.94|
000056  2803              CMP      r0,#3                 ;317
000058  d113              BNE      |L3.130|
00005a  bf00              NOP                            ;319
                  |L3.92|
00005c  bf00              NOP                            ;320
                  |L3.94|
00005e  f1050120          ADD      r1,r5,#0x20           ;321
000062  4630              MOV      r0,r6                 ;321
000064  f7fffffe          BL       OS_StrCopy
000068  4607              MOV      r7,r0                 ;321
00006a  f7fffffe          BL       OSTmr_Unlock
00006e  2000              MOVS     r0,#0                 ;323
000070  7020              STRB     r0,[r4,#0]            ;323
000072  4638              MOV      r0,r7                 ;324
000074  e7cb              B        |L3.14|
                  |L3.118|
000076  f7fffffe          BL       OSTmr_Unlock
00007a  2087              MOVS     r0,#0x87              ;328
00007c  7020              STRB     r0,[r4,#0]            ;328
00007e  2000              MOVS     r0,#0                 ;329
000080  e7c5              B        |L3.14|
                  |L3.130|
000082  f7fffffe          BL       OSTmr_Unlock
000086  208d              MOVS     r0,#0x8d              ;333
000088  7020              STRB     r0,[r4,#0]            ;333
00008a  2000              MOVS     r0,#0                 ;334
00008c  e7bf              B        |L3.14|
;;;337    #endif
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;362    #if OS_TMR_EN > 0
;;;363    INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;364                            INT8U   *perr)
;;;365    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;366        INT32U  remain;
;;;367    
;;;368    
;;;369    #if OS_ARG_CHK_EN > 0
;;;370        if (perr == (INT8U *)0) {
000006  b90c              CBNZ     r4,|L4.12|
;;;371            return (0);
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;372        }
;;;373        if (ptmr == (OS_TMR *)0) {
;;;374            *perr = OS_ERR_TMR_INVALID;
;;;375            return (0);
;;;376        }
;;;377    #endif
;;;378        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
;;;379            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;380            return (0);
;;;381        }
;;;382        if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
;;;383            *perr = OS_ERR_TMR_ISR;
;;;384            return (0);
;;;385        }
;;;386        OSTmr_Lock();
;;;387        switch (ptmr->OSTmrState) {
;;;388        case OS_TMR_STATE_RUNNING:
;;;389            remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
;;;390            OSTmr_Unlock();
;;;391            *perr  = OS_ERR_NONE;
;;;392            return (remain);
;;;393    
;;;394        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
;;;395            switch (ptmr->OSTmrOpt) {
;;;396            case OS_TMR_OPT_PERIODIC:
;;;397                if (ptmr->OSTmrDly == 0) {
;;;398                    remain = ptmr->OSTmrPeriod;
;;;399                } else {
;;;400                    remain = ptmr->OSTmrDly;
;;;401                }
;;;402                OSTmr_Unlock();
;;;403                *perr  = OS_ERR_NONE;
;;;404                break;
;;;405    
;;;406            case OS_TMR_OPT_ONE_SHOT:
;;;407            default:
;;;408                remain = ptmr->OSTmrDly;
;;;409                OSTmr_Unlock();
;;;410                *perr  = OS_ERR_NONE;
;;;411                break;
;;;412            }
;;;413            return (remain);
;;;414    
;;;415        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
;;;416            OSTmr_Unlock();
;;;417            *perr = OS_ERR_NONE;
;;;418            return (0);
;;;419    
;;;420        case OS_TMR_STATE_UNUSED:
;;;421            OSTmr_Unlock();
;;;422            *perr = OS_ERR_TMR_INACTIVE;
;;;423            return (0);
;;;424    
;;;425        default:
;;;426            OSTmr_Unlock();
;;;427            *perr = OS_ERR_TMR_INVALID_STATE;
;;;428            return (0);
;;;429        }
;;;430    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  b91d              CBNZ     r5,|L4.22|
00000e  208a              MOVS     r0,#0x8a              ;374
000010  7020              STRB     r0,[r4,#0]            ;374
000012  2000              MOVS     r0,#0                 ;375
000014  e7f9              B        |L4.10|
                  |L4.22|
000016  7828              LDRB     r0,[r5,#0]            ;378
000018  2864              CMP      r0,#0x64              ;378
00001a  d003              BEQ      |L4.36|
00001c  2089              MOVS     r0,#0x89              ;379
00001e  7020              STRB     r0,[r4,#0]            ;379
000020  2000              MOVS     r0,#0                 ;380
000022  e7f2              B        |L4.10|
                  |L4.36|
000024  4823              LDR      r0,|L4.180|
000026  7800              LDRB     r0,[r0,#0]            ;382  ; OSIntNesting
000028  2800              CMP      r0,#0                 ;382
00002a  dd03              BLE      |L4.52|
00002c  208b              MOVS     r0,#0x8b              ;383
00002e  7020              STRB     r0,[r4,#0]            ;383
000030  2000              MOVS     r0,#0                 ;384
000032  e7ea              B        |L4.10|
                  |L4.52|
000034  f7fffffe          BL       OSTmr_Lock
000038  f8950031          LDRB     r0,[r5,#0x31]         ;387
00003c  b370              CBZ      r0,|L4.156|
00003e  2801              CMP      r0,#1                 ;387
000040  d00d              BEQ      |L4.94|
000042  2802              CMP      r0,#2                 ;387
000044  d025              BEQ      |L4.146|
000046  2803              CMP      r0,#3                 ;387
000048  d12e              BNE      |L4.168|
00004a  491b              LDR      r1,|L4.184|
00004c  6968              LDR      r0,[r5,#0x14]         ;389
00004e  6809              LDR      r1,[r1,#0]            ;389  ; OSTmrTime
000050  1a46              SUBS     r6,r0,r1              ;389
000052  f7fffffe          BL       OSTmr_Unlock
000056  2000              MOVS     r0,#0                 ;391
000058  7020              STRB     r0,[r4,#0]            ;391
00005a  4630              MOV      r0,r6                 ;392
00005c  e7d5              B        |L4.10|
                  |L4.94|
00005e  f8950030          LDRB     r0,[r5,#0x30]         ;395
000062  2801              CMP      r0,#1                 ;395
000064  d00c              BEQ      |L4.128|
000066  2802              CMP      r0,#2                 ;395
000068  d109              BNE      |L4.126|
00006a  69a8              LDR      r0,[r5,#0x18]         ;397
00006c  b908              CBNZ     r0,|L4.114|
00006e  69ee              LDR      r6,[r5,#0x1c]         ;398
000070  e000              B        |L4.116|
                  |L4.114|
000072  69ae              LDR      r6,[r5,#0x18]         ;400
                  |L4.116|
000074  f7fffffe          BL       OSTmr_Unlock
000078  2000              MOVS     r0,#0                 ;403
00007a  7020              STRB     r0,[r4,#0]            ;403
00007c  e006              B        |L4.140|
                  |L4.126|
00007e  bf00              NOP                            ;406
                  |L4.128|
000080  69ae              LDR      r6,[r5,#0x18]         ;408
000082  f7fffffe          BL       OSTmr_Unlock
000086  2000              MOVS     r0,#0                 ;410
000088  7020              STRB     r0,[r4,#0]            ;410
00008a  bf00              NOP                            ;411
                  |L4.140|
00008c  bf00              NOP                            ;404
00008e  4630              MOV      r0,r6                 ;413
000090  e7bb              B        |L4.10|
                  |L4.146|
000092  f7fffffe          BL       OSTmr_Unlock
000096  2000              MOVS     r0,#0                 ;417
000098  7020              STRB     r0,[r4,#0]            ;417
00009a  e7b6              B        |L4.10|
                  |L4.156|
00009c  f7fffffe          BL       OSTmr_Unlock
0000a0  2087              MOVS     r0,#0x87              ;422
0000a2  7020              STRB     r0,[r4,#0]            ;422
0000a4  2000              MOVS     r0,#0                 ;423
0000a6  e7b0              B        |L4.10|
                  |L4.168|
0000a8  f7fffffe          BL       OSTmr_Unlock
0000ac  208d              MOVS     r0,#0x8d              ;427
0000ae  7020              STRB     r0,[r4,#0]            ;427
0000b0  2000              MOVS     r0,#0                 ;428
0000b2  e7aa              B        |L4.10|
;;;431    #endif
                          ENDP

                  |L4.180|
                          DCD      OSIntNesting
                  |L4.184|
                          DCD      OSTmrTime

                          AREA ||i.OSTmrSignal||, CODE, READONLY, ALIGN=2

                  OSTmrSignal PROC
;;;710    #if OS_TMR_EN > 0
;;;711    INT8U  OSTmrSignal (void)
000000  b510              PUSH     {r4,lr}
;;;712    {
;;;713        INT8U  err;
;;;714    
;;;715    
;;;716        err = OSSemPost(OSTmrSemSignal);
000002  4803              LDR      r0,|L5.16|
000004  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
000006  f7fffffe          BL       OSSemPost
00000a  4604              MOV      r4,r0
;;;717        return (err);
00000c  4620              MOV      r0,r4
;;;718    }
00000e  bd10              POP      {r4,pc}
;;;719    #endif
                          ENDP

                  |L5.16|
                          DCD      OSTmrSemSignal

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;524    #if OS_TMR_EN > 0
;;;525    BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;526                         INT8U    *perr)
;;;527    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;528    #if OS_ARG_CHK_EN > 0
;;;529        if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
000006  b90c              CBNZ     r4,|L6.12|
;;;530            return (OS_FALSE);
000008  2000              MOVS     r0,#0
                  |L6.10|
;;;531        }
;;;532        if (ptmr == (OS_TMR *)0) {
;;;533            *perr = OS_ERR_TMR_INVALID;
;;;534            return (OS_FALSE);
;;;535        }
;;;536    #endif
;;;537        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
;;;538            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;539            return (OS_FALSE);
;;;540        }
;;;541        if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
;;;542            *perr  = OS_ERR_TMR_ISR;
;;;543            return (OS_FALSE);
;;;544        }
;;;545        OSTmr_Lock();
;;;546        switch (ptmr->OSTmrState) {
;;;547        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;548            OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
;;;549            OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;550            OSTmr_Unlock();
;;;551            *perr = OS_ERR_NONE;
;;;552            return (OS_TRUE);
;;;553    
;;;554        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;555        case OS_TMR_STATE_COMPLETED:
;;;556            OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;557            OSTmr_Unlock();
;;;558            *perr = OS_ERR_NONE;
;;;559            return (OS_TRUE);
;;;560    
;;;561        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;562            OSTmr_Unlock();
;;;563            *perr = OS_ERR_TMR_INACTIVE;
;;;564            return (OS_FALSE);
;;;565    
;;;566        default:
;;;567            OSTmr_Unlock();
;;;568            *perr = OS_ERR_TMR_INVALID_STATE;
;;;569            return (OS_FALSE);
;;;570        }
;;;571    }
00000a  bd70              POP      {r4-r6,pc}
                  |L6.12|
00000c  b91d              CBNZ     r5,|L6.22|
00000e  208a              MOVS     r0,#0x8a              ;533
000010  7020              STRB     r0,[r4,#0]            ;533
000012  2000              MOVS     r0,#0                 ;534
000014  e7f9              B        |L6.10|
                  |L6.22|
000016  7828              LDRB     r0,[r5,#0]            ;537
000018  2864              CMP      r0,#0x64              ;537
00001a  d003              BEQ      |L6.36|
00001c  2089              MOVS     r0,#0x89              ;538
00001e  7020              STRB     r0,[r4,#0]            ;538
000020  2000              MOVS     r0,#0                 ;539
000022  e7f2              B        |L6.10|
                  |L6.36|
000024  481b              LDR      r0,|L6.148|
000026  7800              LDRB     r0,[r0,#0]            ;541  ; OSIntNesting
000028  2800              CMP      r0,#0                 ;541
00002a  dd03              BLE      |L6.52|
00002c  208b              MOVS     r0,#0x8b              ;542
00002e  7020              STRB     r0,[r4,#0]            ;542
000030  2000              MOVS     r0,#0                 ;543
000032  e7ea              B        |L6.10|
                  |L6.52|
000034  f7fffffe          BL       OSTmr_Lock
000038  f8950031          LDRB     r0,[r5,#0x31]         ;546
00003c  b1e8              CBZ      r0,|L6.122|
00003e  2801              CMP      r0,#1                 ;546
000040  d010              BEQ      |L6.100|
000042  2802              CMP      r0,#2                 ;546
000044  d00f              BEQ      |L6.102|
000046  2803              CMP      r0,#3                 ;546
000048  d11d              BNE      |L6.134|
00004a  4628              MOV      r0,r5                 ;548
00004c  f7fffffe          BL       OSTmr_Unlink
000050  2100              MOVS     r1,#0                 ;549
000052  4628              MOV      r0,r5                 ;549
000054  f7fffffe          BL       OSTmr_Link
000058  f7fffffe          BL       OSTmr_Unlock
00005c  2000              MOVS     r0,#0                 ;551
00005e  7020              STRB     r0,[r4,#0]            ;551
000060  2001              MOVS     r0,#1                 ;552
000062  e7d2              B        |L6.10|
                  |L6.100|
000064  bf00              NOP                            ;555
                  |L6.102|
000066  2100              MOVS     r1,#0                 ;556
000068  4628              MOV      r0,r5                 ;556
00006a  f7fffffe          BL       OSTmr_Link
00006e  f7fffffe          BL       OSTmr_Unlock
000072  2000              MOVS     r0,#0                 ;558
000074  7020              STRB     r0,[r4,#0]            ;558
000076  2001              MOVS     r0,#1                 ;559
000078  e7c7              B        |L6.10|
                  |L6.122|
00007a  f7fffffe          BL       OSTmr_Unlock
00007e  2087              MOVS     r0,#0x87              ;563
000080  7020              STRB     r0,[r4,#0]            ;563
000082  2000              MOVS     r0,#0                 ;564
000084  e7c1              B        |L6.10|
                  |L6.134|
000086  f7fffffe          BL       OSTmr_Unlock
00008a  208d              MOVS     r0,#0x8d              ;568
00008c  7020              STRB     r0,[r4,#0]            ;568
00008e  2000              MOVS     r0,#0                 ;569
000090  e7bb              B        |L6.10|
;;;572    #endif
                          ENDP

000092  0000              DCW      0x0000
                  |L6.148|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;459    #if OS_TMR_EN > 0
;;;460    INT8U  OSTmrStateGet (OS_TMR  *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;461                          INT8U   *perr)
;;;462    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;463        INT8U  state;
;;;464    
;;;465    
;;;466    #if OS_ARG_CHK_EN > 0
;;;467        if (perr == (INT8U *)0) {
000006  b90c              CBNZ     r4,|L7.12|
;;;468            return (0);
000008  2000              MOVS     r0,#0
                  |L7.10|
;;;469        }
;;;470        if (ptmr == (OS_TMR *)0) {
;;;471            *perr = OS_ERR_TMR_INVALID;
;;;472            return (0);
;;;473        }
;;;474    #endif
;;;475        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
;;;476            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;477            return (0);
;;;478        }
;;;479        if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
;;;480            *perr = OS_ERR_TMR_ISR;
;;;481            return (0);
;;;482        }
;;;483        OSTmr_Lock();
;;;484        state = ptmr->OSTmrState;
;;;485        switch (state) {
;;;486        case OS_TMR_STATE_UNUSED:
;;;487        case OS_TMR_STATE_STOPPED:
;;;488        case OS_TMR_STATE_COMPLETED:
;;;489        case OS_TMR_STATE_RUNNING:
;;;490            *perr = OS_ERR_NONE;
;;;491            break;
;;;492    
;;;493        default:
;;;494            *perr = OS_ERR_TMR_INVALID_STATE;
;;;495            break;
;;;496        }
;;;497        OSTmr_Unlock();
;;;498        return (state);
;;;499    }
00000a  bd70              POP      {r4-r6,pc}
                  |L7.12|
00000c  b91d              CBNZ     r5,|L7.22|
00000e  208a              MOVS     r0,#0x8a              ;471
000010  7020              STRB     r0,[r4,#0]            ;471
000012  2000              MOVS     r0,#0                 ;472
000014  e7f9              B        |L7.10|
                  |L7.22|
000016  7828              LDRB     r0,[r5,#0]            ;475
000018  2864              CMP      r0,#0x64              ;475
00001a  d003              BEQ      |L7.36|
00001c  2089              MOVS     r0,#0x89              ;476
00001e  7020              STRB     r0,[r4,#0]            ;476
000020  2000              MOVS     r0,#0                 ;477
000022  e7f2              B        |L7.10|
                  |L7.36|
000024  4810              LDR      r0,|L7.104|
000026  7800              LDRB     r0,[r0,#0]            ;479  ; OSIntNesting
000028  2800              CMP      r0,#0                 ;479
00002a  dd03              BLE      |L7.52|
00002c  208b              MOVS     r0,#0x8b              ;480
00002e  7020              STRB     r0,[r4,#0]            ;480
000030  2000              MOVS     r0,#0                 ;481
000032  e7ea              B        |L7.10|
                  |L7.52|
000034  f7fffffe          BL       OSTmr_Lock
000038  f8956031          LDRB     r6,[r5,#0x31]         ;484
00003c  b136              CBZ      r6,|L7.76|
00003e  2e01              CMP      r6,#1                 ;485
000040  d005              BEQ      |L7.78|
000042  2e02              CMP      r6,#2                 ;485
000044  d004              BEQ      |L7.80|
000046  2e03              CMP      r6,#3                 ;485
000048  d106              BNE      |L7.88|
00004a  e002              B        |L7.82|
                  |L7.76|
00004c  bf00              NOP                            ;487
                  |L7.78|
00004e  bf00              NOP                            ;488
                  |L7.80|
000050  bf00              NOP                            ;489
                  |L7.82|
000052  2000              MOVS     r0,#0                 ;490
000054  7020              STRB     r0,[r4,#0]            ;490
000056  e002              B        |L7.94|
                  |L7.88|
000058  208d              MOVS     r0,#0x8d              ;494
00005a  7020              STRB     r0,[r4,#0]            ;494
00005c  bf00              NOP                            ;495
                  |L7.94|
00005e  bf00              NOP                            ;491
000060  f7fffffe          BL       OSTmr_Unlock
000064  4630              MOV      r0,r6                 ;498
000066  e7d0              B        |L7.10|
;;;500    #endif
                          ENDP

                  |L7.104|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;611    #if OS_TMR_EN > 0
;;;612    BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;613                        INT8U    opt,
;;;614                        void    *callback_arg,
;;;615                        INT8U   *perr)
;;;616    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;617        OS_TMR_CALLBACK  pfnct;
;;;618    
;;;619    
;;;620    #if OS_ARG_CHK_EN > 0
;;;621        if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
00000c  b914              CBNZ     r4,|L8.20|
;;;622            return (OS_FALSE);
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;623        }
;;;624        if (ptmr == (OS_TMR *)0) {
;;;625            *perr = OS_ERR_TMR_INVALID;
;;;626            return (OS_FALSE);
;;;627        }
;;;628    #endif
;;;629        if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
;;;630            *perr = OS_ERR_TMR_INVALID_TYPE;
;;;631            return (OS_FALSE);
;;;632        }
;;;633        if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
;;;634            *perr  = OS_ERR_TMR_ISR;
;;;635            return (OS_FALSE);
;;;636        }
;;;637        OSTmr_Lock();
;;;638        switch (ptmr->OSTmrState) {
;;;639        case OS_TMR_STATE_RUNNING:
;;;640            OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
;;;641            *perr = OS_ERR_NONE;
;;;642            switch (opt) {
;;;643            case OS_TMR_OPT_CALLBACK:
;;;644                pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;645                if (pfnct != (OS_TMR_CALLBACK)0) {
;;;646                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
;;;647                } else {
;;;648                    *perr = OS_ERR_TMR_NO_CALLBACK;
;;;649                }
;;;650                break;
;;;651    
;;;652            case OS_TMR_OPT_CALLBACK_ARG:
;;;653                pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;654                if (pfnct != (OS_TMR_CALLBACK)0) {
;;;655                    (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
;;;656                } else {
;;;657                    *perr = OS_ERR_TMR_NO_CALLBACK;
;;;658                }
;;;659                break;
;;;660    
;;;661            case OS_TMR_OPT_NONE:
;;;662                break;
;;;663    
;;;664            default:
;;;665                *perr = OS_ERR_TMR_INVALID_OPT;
;;;666                break;
;;;667            }
;;;668            OSTmr_Unlock();
;;;669            return (OS_TRUE);
;;;670    
;;;671        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
;;;672        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
;;;673            OSTmr_Unlock();
;;;674            *perr = OS_ERR_TMR_STOPPED;
;;;675            return (OS_TRUE);
;;;676    
;;;677        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
;;;678            OSTmr_Unlock();
;;;679            *perr = OS_ERR_TMR_INACTIVE;
;;;680            return (OS_FALSE);
;;;681    
;;;682        default:
;;;683            OSTmr_Unlock();
;;;684            *perr = OS_ERR_TMR_INVALID_STATE;
;;;685            return (OS_FALSE);
;;;686        }
;;;687    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L8.20|
000014  b91d              CBNZ     r5,|L8.30|
000016  208a              MOVS     r0,#0x8a              ;625
000018  7020              STRB     r0,[r4,#0]            ;625
00001a  2000              MOVS     r0,#0                 ;626
00001c  e7f8              B        |L8.16|
                  |L8.30|
00001e  7828              LDRB     r0,[r5,#0]            ;629
000020  2864              CMP      r0,#0x64              ;629
000022  d003              BEQ      |L8.44|
000024  2089              MOVS     r0,#0x89              ;630
000026  7020              STRB     r0,[r4,#0]            ;630
000028  2000              MOVS     r0,#0                 ;631
00002a  e7f1              B        |L8.16|
                  |L8.44|
00002c  4826              LDR      r0,|L8.200|
00002e  7800              LDRB     r0,[r0,#0]            ;633  ; OSIntNesting
000030  2800              CMP      r0,#0                 ;633
000032  dd03              BLE      |L8.60|
000034  208b              MOVS     r0,#0x8b              ;634
000036  7020              STRB     r0,[r4,#0]            ;634
000038  2000              MOVS     r0,#0                 ;635
00003a  e7e9              B        |L8.16|
                  |L8.60|
00003c  f7fffffe          BL       OSTmr_Lock
000040  f8950031          LDRB     r0,[r5,#0x31]         ;638
000044  b390              CBZ      r0,|L8.172|
000046  2801              CMP      r0,#1                 ;638
000048  d02a              BEQ      |L8.160|
00004a  2802              CMP      r0,#2                 ;638
00004c  d027              BEQ      |L8.158|
00004e  2803              CMP      r0,#3                 ;638
000050  d133              BNE      |L8.186|
000052  4628              MOV      r0,r5                 ;640
000054  f7fffffe          BL       OSTmr_Unlink
000058  2000              MOVS     r0,#0                 ;641
00005a  7020              STRB     r0,[r4,#0]            ;641
00005c  b1b7              CBZ      r7,|L8.140|
00005e  2f03              CMP      r7,#3                 ;642
000060  d002              BEQ      |L8.104|
000062  2f04              CMP      r7,#4                 ;642
000064  d113              BNE      |L8.142|
000066  e008              B        |L8.122|
                  |L8.104|
000068  686e              LDR      r6,[r5,#4]            ;644
00006a  b11e              CBZ      r6,|L8.116|
00006c  4628              MOV      r0,r5                 ;646
00006e  68a9              LDR      r1,[r5,#8]            ;646
000070  47b0              BLX      r6                    ;646
000072  e001              B        |L8.120|
                  |L8.116|
000074  208f              MOVS     r0,#0x8f              ;648
000076  7020              STRB     r0,[r4,#0]            ;648
                  |L8.120|
000078  e00c              B        |L8.148|
                  |L8.122|
00007a  686e              LDR      r6,[r5,#4]            ;653
00007c  b11e              CBZ      r6,|L8.134|
00007e  4641              MOV      r1,r8                 ;655
000080  4628              MOV      r0,r5                 ;655
000082  47b0              BLX      r6                    ;655
000084  e001              B        |L8.138|
                  |L8.134|
000086  208f              MOVS     r0,#0x8f              ;657
000088  7020              STRB     r0,[r4,#0]            ;657
                  |L8.138|
00008a  e003              B        |L8.148|
                  |L8.140|
00008c  e002              B        |L8.148|
                  |L8.142|
00008e  2084              MOVS     r0,#0x84              ;665
000090  7020              STRB     r0,[r4,#0]            ;665
000092  bf00              NOP                            ;666
                  |L8.148|
000094  bf00              NOP                            ;650
000096  f7fffffe          BL       OSTmr_Unlock
00009a  2001              MOVS     r0,#1                 ;669
00009c  e7b8              B        |L8.16|
                  |L8.158|
00009e  bf00              NOP                            ;672
                  |L8.160|
0000a0  f7fffffe          BL       OSTmr_Unlock
0000a4  208e              MOVS     r0,#0x8e              ;674
0000a6  7020              STRB     r0,[r4,#0]            ;674
0000a8  2001              MOVS     r0,#1                 ;675
0000aa  e7b1              B        |L8.16|
                  |L8.172|
0000ac  e7ff              B        |L8.174|
                  |L8.174|
0000ae  f7fffffe          BL       OSTmr_Unlock
0000b2  2087              MOVS     r0,#0x87              ;679
0000b4  7020              STRB     r0,[r4,#0]            ;679
0000b6  2000              MOVS     r0,#0                 ;680
0000b8  e7aa              B        |L8.16|
                  |L8.186|
0000ba  f7fffffe          BL       OSTmr_Unlock
0000be  208d              MOVS     r0,#0x8d              ;684
0000c0  7020              STRB     r0,[r4,#0]            ;684
0000c2  2000              MOVS     r0,#0                 ;685
0000c4  e7a4              B        |L8.16|
;;;688    #endif
                          ENDP

0000c6  0000              DCW      0x0000
                  |L8.200|
                          DCD      OSIntNesting

                          AREA ||i.OSTmr_Alloc||, CODE, READONLY, ALIGN=2

                  OSTmr_Alloc PROC
;;;734    #if OS_TMR_EN > 0
;;;735    static  OS_TMR  *OSTmr_Alloc (void)
000000  480c              LDR      r0,|L9.52|
;;;736    {
;;;737        OS_TMR *ptmr;
;;;738    
;;;739    
;;;740        if (OSTmrFreeList == (OS_TMR *)0) {
000002  6800              LDR      r0,[r0,#0]  ; OSTmrFreeList
000004  b908              CBNZ     r0,|L9.10|
;;;741            return ((OS_TMR *)0);
000006  2000              MOVS     r0,#0
                  |L9.8|
;;;742        }
;;;743        ptmr            = (OS_TMR *)OSTmrFreeList;
;;;744        OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
;;;745        ptmr->OSTmrNext = (OS_TCB *)0;
;;;746        ptmr->OSTmrPrev = (OS_TCB *)0;
;;;747        OSTmrUsed++;
;;;748        OSTmrFree--;
;;;749        return (ptmr);
;;;750    }
000008  4770              BX       lr
                  |L9.10|
00000a  480a              LDR      r0,|L9.52|
00000c  6801              LDR      r1,[r0,#0]            ;743  ; OSTmrFreeList
00000e  4a09              LDR      r2,|L9.52|
000010  68c8              LDR      r0,[r1,#0xc]          ;744
000012  6010              STR      r0,[r2,#0]            ;744  ; OSTmrFreeList
000014  2000              MOVS     r0,#0                 ;745
000016  60c8              STR      r0,[r1,#0xc]          ;745
000018  6108              STR      r0,[r1,#0x10]         ;746
00001a  4807              LDR      r0,|L9.56|
00001c  8800              LDRH     r0,[r0,#0]            ;747  ; OSTmrUsed
00001e  1c40              ADDS     r0,r0,#1              ;747
000020  4a05              LDR      r2,|L9.56|
000022  8010              STRH     r0,[r2,#0]            ;747
000024  4805              LDR      r0,|L9.60|
000026  8800              LDRH     r0,[r0,#0]            ;748  ; OSTmrFree
000028  1e40              SUBS     r0,r0,#1              ;748
00002a  4a04              LDR      r2,|L9.60|
00002c  8010              STRH     r0,[r2,#0]            ;748
00002e  4608              MOV      r0,r1                 ;749
000030  e7ea              B        |L9.8|
;;;751    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      OSTmrFreeList
                  |L9.56|
                          DCD      OSTmrUsed
                  |L9.60|
                          DCD      OSTmrFree

                          AREA ||i.OSTmr_Free||, CODE, READONLY, ALIGN=2

                  OSTmr_Free PROC
;;;766    #if OS_TMR_EN > 0
;;;767    static  void  OSTmr_Free (OS_TMR *ptmr)
000000  2100              MOVS     r1,#0
;;;768    {
;;;769        ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
000002  f8801031          STRB     r1,[r0,#0x31]
;;;770        ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
000006  f8801030          STRB     r1,[r0,#0x30]
;;;771        ptmr->OSTmrPeriod      = 0;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;772        ptmr->OSTmrMatch       = 0;
00000c  6141              STR      r1,[r0,#0x14]
;;;773        ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
00000e  6041              STR      r1,[r0,#4]
;;;774        ptmr->OSTmrCallbackArg = (void *)0;
000010  6081              STR      r1,[r0,#8]
;;;775    #if OS_TMR_CFG_NAME_SIZE > 1
;;;776        ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
000012  213f              MOVS     r1,#0x3f
000014  f8801020          STRB     r1,[r0,#0x20]
;;;777        ptmr->OSTmrName[1]     = OS_ASCII_NUL;
000018  2200              MOVS     r2,#0
00001a  2121              MOVS     r1,#0x21
00001c  540a              STRB     r2,[r1,r0]
;;;778    #endif
;;;779    
;;;780        ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
00001e  2100              MOVS     r1,#0
000020  6101              STR      r1,[r0,#0x10]
;;;781        ptmr->OSTmrNext        = OSTmrFreeList;
000022  4908              LDR      r1,|L10.68|
000024  6809              LDR      r1,[r1,#0]  ; OSTmrFreeList
000026  60c1              STR      r1,[r0,#0xc]
;;;782        OSTmrFreeList          = ptmr;
000028  4906              LDR      r1,|L10.68|
00002a  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;783    
;;;784        OSTmrUsed--;                                       /* Update timer object statistics                              */
00002c  4906              LDR      r1,|L10.72|
00002e  8809              LDRH     r1,[r1,#0]  ; OSTmrUsed
000030  1e49              SUBS     r1,r1,#1
000032  4a05              LDR      r2,|L10.72|
000034  8011              STRH     r1,[r2,#0]
;;;785        OSTmrFree++;
000036  4905              LDR      r1,|L10.76|
000038  8809              LDRH     r1,[r1,#0]  ; OSTmrFree
00003a  1c49              ADDS     r1,r1,#1
00003c  4a03              LDR      r2,|L10.76|
00003e  8011              STRH     r1,[r2,#0]
;;;786    }
000040  4770              BX       lr
;;;787    #endif
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      OSTmrFreeList
                  |L10.72|
                          DCD      OSTmrUsed
                  |L10.76|
                          DCD      OSTmrFree

                          AREA ||i.OSTmr_Init||, CODE, READONLY, ALIGN=2

                  OSTmr_Init PROC
;;;803    #if OS_TMR_EN > 0
;;;804    void  OSTmr_Init (void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;805    {
;;;806    #if OS_EVENT_NAME_SIZE > 10
;;;807        INT8U    err;
;;;808    #endif
;;;809        INT16U   i;
;;;810        OS_TMR  *ptmr1;
;;;811        OS_TMR  *ptmr2;
;;;812    
;;;813    
;;;814        OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
000002  f44f7150          MOV      r1,#0x340
000006  4827              LDR      r0,|L11.164|
000008  f7fffffe          BL       OS_MemClr
;;;815        OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
00000c  2140              MOVS     r1,#0x40
00000e  4826              LDR      r0,|L11.168|
000010  f7fffffe          BL       OS_MemClr
;;;816    
;;;817        ptmr1 = &OSTmrTbl[0];
000014  4c23              LDR      r4,|L11.164|
;;;818        ptmr2 = &OSTmrTbl[1];
000016  f1040634          ADD      r6,r4,#0x34
;;;819        for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
00001a  2500              MOVS     r5,#0
00001c  e00f              B        |L11.62|
                  |L11.30|
;;;820            ptmr1->OSTmrType    = OS_TMR_TYPE;
00001e  2064              MOVS     r0,#0x64
000020  7020              STRB     r0,[r4,#0]
;;;821            ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000022  2000              MOVS     r0,#0
000024  f8840031          STRB     r0,[r4,#0x31]
;;;822            ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
000028  60e6              STR      r6,[r4,#0xc]
;;;823    #if OS_TMR_CFG_NAME_SIZE > 1
;;;824            ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
00002a  203f              MOVS     r0,#0x3f
00002c  f8840020          STRB     r0,[r4,#0x20]
;;;825            ptmr1->OSTmrName[1] = OS_ASCII_NUL;
000030  2100              MOVS     r1,#0
000032  2021              MOVS     r0,#0x21
000034  5501              STRB     r1,[r0,r4]
;;;826    #endif
;;;827            ptmr1++;
000036  3434              ADDS     r4,r4,#0x34
;;;828            ptmr2++;
000038  3634              ADDS     r6,r6,#0x34
00003a  1c68              ADDS     r0,r5,#1              ;819
00003c  b285              UXTH     r5,r0                 ;819
                  |L11.62|
00003e  2d0f              CMP      r5,#0xf               ;819
000040  dbed              BLT      |L11.30|
;;;829        }
;;;830        ptmr1->OSTmrType    = OS_TMR_TYPE;
000042  2064              MOVS     r0,#0x64
000044  7020              STRB     r0,[r4,#0]
;;;831        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
000046  2000              MOVS     r0,#0
000048  f8840031          STRB     r0,[r4,#0x31]
;;;832        ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
00004c  60e0              STR      r0,[r4,#0xc]
;;;833    #if OS_TMR_CFG_NAME_SIZE > 1
;;;834        ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
00004e  203f              MOVS     r0,#0x3f
000050  f8840020          STRB     r0,[r4,#0x20]
;;;835        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
000054  2100              MOVS     r1,#0
000056  2021              MOVS     r0,#0x21
000058  5501              STRB     r1,[r0,r4]
;;;836    #endif
;;;837        OSTmrTime           = 0;
00005a  2000              MOVS     r0,#0
00005c  4913              LDR      r1,|L11.172|
00005e  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;838        OSTmrUsed           = 0;
000060  4913              LDR      r1,|L11.176|
000062  8008              STRH     r0,[r1,#0]
;;;839        OSTmrFree           = OS_TMR_CFG_MAX;
000064  2010              MOVS     r0,#0x10
000066  4913              LDR      r1,|L11.180|
000068  8008              STRH     r0,[r1,#0]
;;;840        OSTmrFreeList       = &OSTmrTbl[0];
00006a  480e              LDR      r0,|L11.164|
00006c  4912              LDR      r1,|L11.184|
00006e  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;841        OSTmrSem            = OSSemCreate(1);
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       OSSemCreate
000076  4911              LDR      r1,|L11.188|
000078  6008              STR      r0,[r1,#0]  ; OSTmrSem
;;;842        OSTmrSemSignal      = OSSemCreate(0);
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       OSSemCreate
000080  490f              LDR      r1,|L11.192|
000082  6008              STR      r0,[r1,#0]  ; OSTmrSemSignal
;;;843    
;;;844    #if OS_EVENT_NAME_SIZE > 18
;;;845        OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
;;;846    #else
;;;847    #if OS_EVENT_NAME_SIZE > 10
;;;848        OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
000084  466a              MOV      r2,sp
000086  a10f              ADR      r1,|L11.196|
000088  480c              LDR      r0,|L11.188|
00008a  6800              LDR      r0,[r0,#0]  ; OSTmrSem
00008c  f7fffffe          BL       OSEventNameSet
;;;849    #endif
;;;850    #endif
;;;851    
;;;852    #if OS_EVENT_NAME_SIZE > 18
;;;853        OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
;;;854    #else
;;;855    #if OS_EVENT_NAME_SIZE > 10
;;;856        OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
000090  466a              MOV      r2,sp
000092  a10f              ADR      r1,|L11.208|
000094  480a              LDR      r0,|L11.192|
000096  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
000098  f7fffffe          BL       OSEventNameSet
;;;857    #endif
;;;858    #endif
;;;859    
;;;860        OSTmr_InitTask();
00009c  f7fffffe          BL       OSTmr_InitTask
;;;861    }
0000a0  bdf8              POP      {r3-r7,pc}
;;;862    #endif
                          ENDP

0000a2  0000              DCW      0x0000
                  |L11.164|
                          DCD      OSTmrTbl
                  |L11.168|
                          DCD      OSTmrWheelTbl
                  |L11.172|
                          DCD      OSTmrTime
                  |L11.176|
                          DCD      OSTmrUsed
                  |L11.180|
                          DCD      OSTmrFree
                  |L11.184|
                          DCD      OSTmrFreeList
                  |L11.188|
                          DCD      OSTmrSem
                  |L11.192|
                          DCD      OSTmrSemSignal
                  |L11.196|
0000c4  4f532d54          DCB      "OS-TmrLock",0
0000c8  6d724c6f
0000cc  636b00  
0000cf  00                DCB      0
                  |L11.208|
0000d0  4f532d54          DCB      "OS-TmrSig",0
0000d4  6d725369
0000d8  6700    
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.OSTmr_InitTask||, CODE, READONLY, ALIGN=2

                  OSTmr_InitTask PROC
;;;877    #if OS_TMR_EN > 0
;;;878    static  void  OSTmr_InitTask (void)
000000  b500              PUSH     {lr}
;;;879    {
000002  b087              SUB      sp,sp,#0x1c
;;;880    #if OS_TASK_NAME_SIZE > 6
;;;881        INT8U  err;
;;;882    #endif
;;;883    
;;;884    
;;;885    #if OS_TASK_CREATE_EXT_EN > 0
;;;886    #if OS_STK_GROWTH == 1
;;;887        (void)OSTaskCreateExt(OSTmr_Task,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L12.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fd          MOV      r0,#0xfffd
000018  233d              MOVS     r3,#0x3d
00001a  4a07              LDR      r2,|L12.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L12.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;888                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;889                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],         /* Set Top-Of-Stack                        */
;;;890                              OS_TASK_TMR_PRIO,
;;;891                              OS_TASK_TMR_ID,
;;;892                              &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
;;;893                              OS_TASK_TMR_STK_SIZE,
;;;894                              (void *)0,                                       /* No TCB extension                        */
;;;895                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;896    #else
;;;897        (void)OSTaskCreateExt(OSTmr_Task,
;;;898                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;899                              &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
;;;900                              OS_TASK_TMR_PRIO,
;;;901                              OS_TASK_TMR_ID,
;;;902                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],         /* Set Bottom-Of-Stack                     */
;;;903                              OS_TASK_TMR_STK_SIZE,
;;;904                              (void *)0,                                       /* No TCB extension                        */
;;;905                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;906    #endif
;;;907    #else
;;;908    #if OS_STK_GROWTH == 1
;;;909        (void)OSTaskCreate(OSTmr_Task,
;;;910                           (void *)0,
;;;911                           &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1],
;;;912                           OS_TASK_TMR_PRIO);
;;;913    #else
;;;914        (void)OSTaskCreate(OSTmr_Task,
;;;915                           (void *)0,
;;;916                           &OSTmrTaskStk[0],
;;;917                           OS_TASK_TMR_PRIO);
;;;918    #endif
;;;919    #endif
;;;920    
;;;921    #if OS_TASK_NAME_SIZE > 12
;;;922        OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L12.64|
000028  203d              MOVS     r0,#0x3d
00002a  f7fffffe          BL       OSTaskNameSet
;;;923    #else
;;;924    #if OS_TASK_NAME_SIZE > 6
;;;925        OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
;;;926    #endif
;;;927    #endif
;;;928    }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;929    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      OSTmrTaskStk
                  |L12.56|
                          DCD      OSTmrTaskStk+0x1fc
                  |L12.60|
                          DCD      OSTmr_Task
                  |L12.64|
000040  75432f4f          DCB      "uC/OS-II Tmr",0
000044  532d4949
000048  20546d72
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OSTmr_Link||, CODE, READONLY, ALIGN=2

                  OSTmr_Link PROC
;;;949    #if OS_TMR_EN > 0
;;;950    static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
000000  b570              PUSH     {r4-r6,lr}
;;;951    {
000002  460b              MOV      r3,r1
;;;952        OS_TMR       *ptmr1;
;;;953        OS_TMR_WHEEL *pspoke;
;;;954        INT16U        spoke;
;;;955    
;;;956    
;;;957        ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
000004  2503              MOVS     r5,#3
000006  f8805031          STRB     r5,[r0,#0x31]
;;;958        if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
00000a  2b01              CMP      r3,#1
00000c  d105              BNE      |L13.26|
;;;959            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00000e  4e15              LDR      r6,|L13.100|
000010  69c5              LDR      r5,[r0,#0x1c]
000012  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000014  4435              ADD      r5,r5,r6
000016  6145              STR      r5,[r0,#0x14]
000018  e00c              B        |L13.52|
                  |L13.26|
;;;960        } else {
;;;961            if (ptmr->OSTmrDly == 0) {
00001a  6985              LDR      r5,[r0,#0x18]
00001c  b92d              CBNZ     r5,|L13.42|
;;;962                ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00001e  4e11              LDR      r6,|L13.100|
000020  69c5              LDR      r5,[r0,#0x1c]
000022  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000024  4435              ADD      r5,r5,r6
000026  6145              STR      r5,[r0,#0x14]
000028  e004              B        |L13.52|
                  |L13.42|
;;;963            } else {
;;;964                ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
00002a  4e0e              LDR      r6,|L13.100|
00002c  6985              LDR      r5,[r0,#0x18]
00002e  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000030  4435              ADD      r5,r5,r6
000032  6145              STR      r5,[r0,#0x14]
                  |L13.52|
;;;965            }
;;;966        }
;;;967        spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000034  7d05              LDRB     r5,[r0,#0x14]
000036  f0050407          AND      r4,r5,#7
;;;968        pspoke = &OSTmrWheelTbl[spoke];
00003a  4d0b              LDR      r5,|L13.104|
00003c  eb0501c4          ADD      r1,r5,r4,LSL #3
;;;969    
;;;970        if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
000040  680d              LDR      r5,[r1,#0]
000042  b92d              CBNZ     r5,|L13.80|
;;;971            pspoke->OSTmrFirst   = ptmr;
000044  6008              STR      r0,[r1,#0]
;;;972            ptmr->OSTmrNext      = (OS_TMR *)0;
000046  2500              MOVS     r5,#0
000048  60c5              STR      r5,[r0,#0xc]
;;;973            pspoke->OSTmrEntries = 1;
00004a  2501              MOVS     r5,#1
00004c  808d              STRH     r5,[r1,#4]
00004e  e006              B        |L13.94|
                  |L13.80|
;;;974        } else {
;;;975            ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
000050  680a              LDR      r2,[r1,#0]
;;;976            pspoke->OSTmrFirst   = ptmr;
000052  6008              STR      r0,[r1,#0]
;;;977            ptmr->OSTmrNext      = (void *)ptmr1;
000054  60c2              STR      r2,[r0,#0xc]
;;;978            ptmr1->OSTmrPrev     = (void *)ptmr;
000056  6110              STR      r0,[r2,#0x10]
;;;979            pspoke->OSTmrEntries++;
000058  888d              LDRH     r5,[r1,#4]
00005a  1c6d              ADDS     r5,r5,#1
00005c  808d              STRH     r5,[r1,#4]
                  |L13.94|
;;;980        }
;;;981        ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
00005e  2500              MOVS     r5,#0
000060  6105              STR      r5,[r0,#0x10]
;;;982    }
000062  bd70              POP      {r4-r6,pc}
;;;983    #endif
                          ENDP

                  |L13.100|
                          DCD      OSTmrTime
                  |L13.104|
                          DCD      OSTmrWheelTbl

                          AREA ||i.OSTmr_Lock||, CODE, READONLY, ALIGN=2

                  OSTmr_Lock PROC
;;;1044   #if OS_TMR_EN > 0
;;;1045   static  void  OSTmr_Lock (void)
000000  b508              PUSH     {r3,lr}
;;;1046   {
;;;1047       INT8U  err;
;;;1048   
;;;1049   
;;;1050       OSSemPend(OSTmrSem, 0, &err);
000002  466a              MOV      r2,sp
000004  2100              MOVS     r1,#0
000006  4802              LDR      r0,|L14.16|
000008  6800              LDR      r0,[r0,#0]  ; OSTmrSem
00000a  f7fffffe          BL       OSSemPend
;;;1051       (void)err;
;;;1052   }
00000e  bd08              POP      {r3,pc}
;;;1053   #endif
                          ENDP

                  |L14.16|
                          DCD      OSTmrSem

                          AREA ||i.OSTmr_Task||, CODE, READONLY, ALIGN=2

                  OSTmr_Task PROC
;;;1077   #if OS_TMR_EN > 0
;;;1078   static  void  OSTmr_Task (void *p_arg)
000000  b508              PUSH     {r3,lr}
;;;1079   {
;;;1080       INT8U            err;
;;;1081       OS_TMR          *ptmr;
;;;1082       OS_TMR          *ptmr_next;
;;;1083       OS_TMR_CALLBACK  pfnct;
;;;1084       OS_TMR_WHEEL    *pspoke;
;;;1085       INT16U           spoke;
;;;1086   
;;;1087   
;;;1088       (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
;;;1089       for (;;) {
000002  bf00              NOP      
                  |L15.4|
;;;1090           OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
000004  466a              MOV      r2,sp
000006  2100              MOVS     r1,#0
000008  4819              LDR      r0,|L15.112|
00000a  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
00000c  f7fffffe          BL       OSSemPend
;;;1091           OSTmr_Lock();
000010  f7fffffe          BL       OSTmr_Lock
;;;1092           OSTmrTime++;                                             /* Increment the current time                        */
000014  4817              LDR      r0,|L15.116|
000016  6800              LDR      r0,[r0,#0]  ; OSTmrTime
000018  1c40              ADDS     r0,r0,#1
00001a  4916              LDR      r1,|L15.116|
00001c  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;1093           spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
00001e  4608              MOV      r0,r1
000020  7800              LDRB     r0,[r0,#0]  ; OSTmrTime
000022  f0000807          AND      r8,r0,#7
;;;1094           pspoke = &OSTmrWheelTbl[spoke];
000026  4814              LDR      r0,|L15.120|
000028  eb0007c8          ADD      r7,r0,r8,LSL #3
;;;1095           ptmr   = pspoke->OSTmrFirst;
00002c  683c              LDR      r4,[r7,#0]
;;;1096           while (ptmr != (OS_TMR *)0) {
00002e  e01a              B        |L15.102|
                  |L15.48|
;;;1097               ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
000030  68e6              LDR      r6,[r4,#0xc]
;;;1098               /* ... timer could get unlinked from the wheel.      */
;;;1099               if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
000032  4910              LDR      r1,|L15.116|
000034  6960              LDR      r0,[r4,#0x14]
000036  6809              LDR      r1,[r1,#0]  ; OSTmrTime
000038  4288              CMP      r0,r1
00003a  d113              BNE      |L15.100|
;;;1100                   pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
00003c  6865              LDR      r5,[r4,#4]
;;;1101                   if (pfnct != (OS_TMR_CALLBACK)0) {
00003e  b115              CBZ      r5,|L15.70|
;;;1102                       (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
000040  4620              MOV      r0,r4
000042  68a1              LDR      r1,[r4,#8]
000044  47a8              BLX      r5
                  |L15.70|
;;;1103                   }
;;;1104                   OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       OSTmr_Unlink
;;;1105                   if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
00004c  f8940030          LDRB     r0,[r4,#0x30]
000050  2802              CMP      r0,#2
000052  d104              BNE      |L15.94|
;;;1106                       OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
000054  2101              MOVS     r1,#1
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       OSTmr_Link
00005c  e002              B        |L15.100|
                  |L15.94|
;;;1107                   } else {
;;;1108                       ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
00005e  2002              MOVS     r0,#2
000060  f8840031          STRB     r0,[r4,#0x31]
                  |L15.100|
;;;1109                   }
;;;1110               }
;;;1111               ptmr = ptmr_next;
000064  4634              MOV      r4,r6
                  |L15.102|
000066  2c00              CMP      r4,#0                 ;1096
000068  d1e2              BNE      |L15.48|
;;;1112           }
;;;1113           OSTmr_Unlock();
00006a  f7fffffe          BL       OSTmr_Unlock
00006e  e7c9              B        |L15.4|
;;;1114       }
;;;1115   }
;;;1116   #endif
                          ENDP

                  |L15.112|
                          DCD      OSTmrSemSignal
                  |L15.116|
                          DCD      OSTmrTime
                  |L15.120|
                          DCD      OSTmrWheelTbl

                          AREA ||i.OSTmr_Unlink||, CODE, READONLY, ALIGN=2

                  OSTmr_Unlink PROC
;;;998    #if OS_TMR_EN > 0
;;;999    static  void  OSTmr_Unlink (OS_TMR *ptmr)
000000  b530              PUSH     {r4,r5,lr}
;;;1000   {
;;;1001       OS_TMR        *ptmr1;
;;;1002       OS_TMR        *ptmr2;
;;;1003       OS_TMR_WHEEL  *pspoke;
;;;1004       INT16U         spoke;
;;;1005   
;;;1006   
;;;1007       spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000002  7d05              LDRB     r5,[r0,#0x14]
000004  f0050407          AND      r4,r5,#7
;;;1008       pspoke = &OSTmrWheelTbl[spoke];
000008  4d0d              LDR      r5,|L16.64|
00000a  eb0503c4          ADD      r3,r5,r4,LSL #3
;;;1009   
;;;1010       if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
00000e  681d              LDR      r5,[r3,#0]
000010  4285              CMP      r5,r0
000012  d105              BNE      |L16.32|
;;;1011           ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
000014  68c1              LDR      r1,[r0,#0xc]
;;;1012           pspoke->OSTmrFirst = (void *)ptmr1;
000016  6019              STR      r1,[r3,#0]
;;;1013           if (ptmr1 != (OS_TMR *)0) {
000018  b139              CBZ      r1,|L16.42|
;;;1014               ptmr1->OSTmrPrev = (void *)0;
00001a  2500              MOVS     r5,#0
00001c  610d              STR      r5,[r1,#0x10]
00001e  e004              B        |L16.42|
                  |L16.32|
;;;1015           }
;;;1016       } else {
;;;1017           ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
000020  6901              LDR      r1,[r0,#0x10]
;;;1018           ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
000022  68c2              LDR      r2,[r0,#0xc]
;;;1019           ptmr1->OSTmrNext = ptmr2;
000024  60ca              STR      r2,[r1,#0xc]
;;;1020           if (ptmr2 != (OS_TMR *)0) {
000026  b102              CBZ      r2,|L16.42|
;;;1021               ptmr2->OSTmrPrev = (void *)ptmr1;
000028  6111              STR      r1,[r2,#0x10]
                  |L16.42|
;;;1022           }
;;;1023       }
;;;1024       ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00002a  2501              MOVS     r5,#1
00002c  f8805031          STRB     r5,[r0,#0x31]
;;;1025       ptmr->OSTmrNext  = (void *)0;
000030  2500              MOVS     r5,#0
000032  60c5              STR      r5,[r0,#0xc]
;;;1026       ptmr->OSTmrPrev  = (void *)0;
000034  6105              STR      r5,[r0,#0x10]
;;;1027       pspoke->OSTmrEntries--;
000036  889d              LDRH     r5,[r3,#4]
000038  1e6d              SUBS     r5,r5,#1
00003a  809d              STRH     r5,[r3,#4]
;;;1028   }
00003c  bd30              POP      {r4,r5,pc}
;;;1029   #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L16.64|
                          DCD      OSTmrWheelTbl

                          AREA ||i.OSTmr_Unlock||, CODE, READONLY, ALIGN=2

                  OSTmr_Unlock PROC
;;;1057   #if OS_TMR_EN > 0
;;;1058   static  void  OSTmr_Unlock (void)
000000  b510              PUSH     {r4,lr}
;;;1059   {
;;;1060       (void)OSSemPost(OSTmrSem);
000002  4802              LDR      r0,|L17.12|
000004  6800              LDR      r0,[r0,#0]  ; OSTmrSem
000006  f7fffffe          BL       OSSemPost
;;;1061   }
00000a  bd10              POP      {r4,pc}
;;;1062   #endif
                          ENDP

                  |L17.12|
                          DCD      OSTmrSem
