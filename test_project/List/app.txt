; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\app.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\app.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\app.crf Source\APP\app.c]
                          THUMB

                          AREA ||i.ADC_Configuration||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;422    }
;;;423    static void ADC_Configuration(void)
000000  b500              PUSH     {lr}
;;;424    {
000002  b091              SUB      sp,sp,#0x44
;;;425        GPIO_InitTypeDef GPIO_InitStructure;
;;;426        ADC_InitTypeDef ADC_InitStructure;
;;;427        DMA_InitTypeDef   DMA_InitStructure;
;;;428        /* Enable DMA1 clock */
;;;429        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;430        /* 使能 ADC1 and GPIOC clock */
;;;431        RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  f44f7004          MOV      r0,#0x210
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;432        /* 配置为模拟输入(ADC Channel 0,1) */
;;;433        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;   
000016  2070              MOVS     r0,#0x70
000018  f8ad0040          STRH     r0,[sp,#0x40]
;;;434        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00001c  2000              MOVS     r0,#0
00001e  f88d0043          STRB     r0,[sp,#0x43]
;;;435        GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  a910              ADD      r1,sp,#0x40
000024  4846              LDR      r0,|L1.320|
000026  f7fffffe          BL       GPIO_Init
;;;436        /* DMA1 channel1 configuration ---------------------------------------------*/
;;;437        DMA_DeInit(DMA1_Channel1);
00002a  4846              LDR      r0,|L1.324|
00002c  f7fffffe          BL       DMA_DeInit
;;;438        DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
000030  4845              LDR      r0,|L1.328|
000032  9000              STR      r0,[sp,#0]
;;;439        DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)ADC1ConvertedValue;
000034  4845              LDR      r0,|L1.332|
000036  9001              STR      r0,[sp,#4]
;;;440        DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000038  2000              MOVS     r0,#0
00003a  9002              STR      r0,[sp,#8]
;;;441        DMA_InitStructure.DMA_BufferSize = 4;
00003c  2004              MOVS     r0,#4
00003e  9003              STR      r0,[sp,#0xc]
;;;442        DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000040  2000              MOVS     r0,#0
000042  9004              STR      r0,[sp,#0x10]
;;;443        DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000044  2080              MOVS     r0,#0x80
000046  9005              STR      r0,[sp,#0x14]
;;;444        DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000048  0040              LSLS     r0,r0,#1
00004a  9006              STR      r0,[sp,#0x18]
;;;445        DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
00004c  0080              LSLS     r0,r0,#2
00004e  9007              STR      r0,[sp,#0x1c]
;;;446        DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000050  2020              MOVS     r0,#0x20
000052  9008              STR      r0,[sp,#0x20]
;;;447        DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000054  0200              LSLS     r0,r0,#8
000056  9009              STR      r0,[sp,#0x24]
;;;448        DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000058  2000              MOVS     r0,#0
00005a  900a              STR      r0,[sp,#0x28]
;;;449        DMA_Init(DMA1_Channel1, &DMA_InitStructure);
00005c  4669              MOV      r1,sp
00005e  4839              LDR      r0,|L1.324|
000060  f7fffffe          BL       DMA_Init
;;;450        /* Enable DMA1 channel1 */
;;;451        DMA_Cmd(DMA1_Channel1, ENABLE);
000064  2101              MOVS     r1,#1
000066  4837              LDR      r0,|L1.324|
000068  f7fffffe          BL       DMA_Cmd
;;;452        /* 配置ADC1 */
;;;453        ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
00006c  2000              MOVS     r0,#0
00006e  900b              STR      r0,[sp,#0x2c]
;;;454        ADC_InitStructure.ADC_ScanConvMode = ENABLE;
000070  2001              MOVS     r0,#1
000072  f88d0030          STRB     r0,[sp,#0x30]
;;;455        ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
000076  f88d0031          STRB     r0,[sp,#0x31]
;;;456        ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
00007a  f44f2060          MOV      r0,#0xe0000
00007e  900d              STR      r0,[sp,#0x34]
;;;457        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000080  2000              MOVS     r0,#0
000082  900e              STR      r0,[sp,#0x38]
;;;458        ADC_InitStructure.ADC_NbrOfChannel = 4;
000084  2004              MOVS     r0,#4
000086  f88d003c          STRB     r0,[sp,#0x3c]
;;;459        ADC_Init(ADC1, &ADC_InitStructure);
00008a  a90b              ADD      r1,sp,#0x2c
00008c  482e              LDR      r0,|L1.328|
00008e  384c              SUBS     r0,r0,#0x4c
000090  f7fffffe          BL       ADC_Init
;;;460        /* ADC1 regular channel configuration */
;;;461        ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_55Cycles5);		   /*电压通道*/
000094  2305              MOVS     r3,#5
000096  2201              MOVS     r2,#1
000098  2104              MOVS     r1,#4
00009a  482b              LDR      r0,|L1.328|
00009c  384c              SUBS     r0,r0,#0x4c
00009e  f7fffffe          BL       ADC_RegularChannelConfig
;;;462        ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 2, ADC_SampleTime_55Cycles5);		   /*温度通道*/
0000a2  2305              MOVS     r3,#5
0000a4  2202              MOVS     r2,#2
0000a6  4619              MOV      r1,r3
0000a8  4827              LDR      r0,|L1.328|
0000aa  384c              SUBS     r0,r0,#0x4c
0000ac  f7fffffe          BL       ADC_RegularChannelConfig
;;;463        ADC_RegularChannelConfig(ADC1, ADC_Channel_6, 3, ADC_SampleTime_55Cycles5);		  /*内阻电压通道*/
0000b0  2305              MOVS     r3,#5
0000b2  2203              MOVS     r2,#3
0000b4  2106              MOVS     r1,#6
0000b6  4824              LDR      r0,|L1.328|
0000b8  384c              SUBS     r0,r0,#0x4c
0000ba  f7fffffe          BL       ADC_RegularChannelConfig
;;;464        //ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 4, ADC_SampleTime_55Cycles5);		  /*内阻电流通道*/
;;;465        //	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 5, ADC_SampleTime_55Cycles5);		  /*电压采集通道*/
;;;466        //	ADC_RegularChannelConfig(ADC1, ADC_Channel_7, 6, ADC_SampleTime_55Cycles5);		  /*电流采集通道*/
;;;467        ADC_RegularChannelConfig(ADC1, ADC_Channel_17, 7, ADC_SampleTime_239Cycles5);	   /*内部参考电压*/
0000be  2307              MOVS     r3,#7
0000c0  461a              MOV      r2,r3
0000c2  2111              MOVS     r1,#0x11
0000c4  4820              LDR      r0,|L1.328|
0000c6  384c              SUBS     r0,r0,#0x4c
0000c8  f7fffffe          BL       ADC_RegularChannelConfig
;;;468        ADC_RegularChannelConfig(ADC1, ADC_Channel_16, 8, ADC_SampleTime_239Cycles5);	   /*片内温度传感器*/
0000cc  2307              MOVS     r3,#7
0000ce  2208              MOVS     r2,#8
0000d0  2110              MOVS     r1,#0x10
0000d2  481d              LDR      r0,|L1.328|
0000d4  384c              SUBS     r0,r0,#0x4c
0000d6  f7fffffe          BL       ADC_RegularChannelConfig
;;;469        /* Enable ADC1 DMA */
;;;470        ADC_DMACmd(ADC1, ENABLE);
0000da  2101              MOVS     r1,#1
0000dc  481a              LDR      r0,|L1.328|
0000de  384c              SUBS     r0,r0,#0x4c
0000e0  f7fffffe          BL       ADC_DMACmd
;;;471        /* Enable ADC1 */
;;;472        ADC_Cmd(ADC1, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  4818              LDR      r0,|L1.328|
0000e8  384c              SUBS     r0,r0,#0x4c
0000ea  f7fffffe          BL       ADC_Cmd
;;;473        /* Enable TempSensor and Vrefint channels: channel16 and Channel17 */
;;;474        ADC_TempSensorVrefintCmd(ENABLE);
0000ee  2001              MOVS     r0,#1
0000f0  f7fffffe          BL       ADC_TempSensorVrefintCmd
;;;475        /* Enable ADC1 reset calibaration register */
;;;476        ADC_ResetCalibration(ADC1);
0000f4  4814              LDR      r0,|L1.328|
0000f6  384c              SUBS     r0,r0,#0x4c
0000f8  f7fffffe          BL       ADC_ResetCalibration
;;;477    
;;;478        /* Check the end of ADC1 reset calibration register */
;;;479        while(ADC_GetResetCalibrationStatus(ADC1));
0000fc  bf00              NOP      
                  |L1.254|
0000fe  4812              LDR      r0,|L1.328|
000100  384c              SUBS     r0,r0,#0x4c
000102  f7fffffe          BL       ADC_GetResetCalibrationStatus
000106  2800              CMP      r0,#0
000108  d1f9              BNE      |L1.254|
;;;480    
;;;481        /* Start ADC1 calibaration */
;;;482        ADC_StartCalibration(ADC1);
00010a  480f              LDR      r0,|L1.328|
00010c  384c              SUBS     r0,r0,#0x4c
00010e  f7fffffe          BL       ADC_StartCalibration
;;;483    
;;;484        /* Check the end of ADC1 calibration */
;;;485        while(ADC_GetCalibrationStatus(ADC1));
000112  bf00              NOP      
                  |L1.276|
000114  480c              LDR      r0,|L1.328|
000116  384c              SUBS     r0,r0,#0x4c
000118  f7fffffe          BL       ADC_GetCalibrationStatus
00011c  2800              CMP      r0,#0
00011e  d1f9              BNE      |L1.276|
;;;486    
;;;487        /* Start ADC1 Software Conversion */
;;;488        ADC_SoftwareStartConvCmd(ADC1, ENABLE);
000120  2101              MOVS     r1,#1
000122  4809              LDR      r0,|L1.328|
000124  384c              SUBS     r0,r0,#0x4c
000126  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;489    
;;;490        /* Test on Channel 1 DMA1_FLAG_TC flag */
;;;491        while(!DMA_GetFlagStatus(DMA1_FLAG_TC1));
00012a  bf00              NOP      
                  |L1.300|
00012c  2002              MOVS     r0,#2
00012e  f7fffffe          BL       DMA_GetFlagStatus
000132  2800              CMP      r0,#0
000134  d0fa              BEQ      |L1.300|
;;;492    
;;;493        /* Clear Channel 1 DMA1_FLAG_TC flag */
;;;494        DMA_ClearFlag(DMA1_FLAG_TC1);
000136  2002              MOVS     r0,#2
000138  f7fffffe          BL       DMA_ClearFlag
;;;495    }
00013c  b011              ADD      sp,sp,#0x44
00013e  bd00              POP      {pc}
;;;496    
                          ENDP

                  |L1.320|
                          DCD      0x40010800
                  |L1.324|
                          DCD      0x40020008
                  |L1.328|
                          DCD      0x4001244c
                  |L1.332|
                          DCD      ADC1ConvertedValue

                          AREA ||i.AppTaskCom_485||, CODE, READONLY, ALIGN=2

                  AppTaskCom_485 PROC
;;;199    
;;;200    static  void  AppTaskCom_485(void *p_arg)
000000  b508              PUSH     {r3,lr}
;;;201    {
;;;202    	unsigned char *ComBuffer;
;;;203        INT8U err;	
;;;204    		char temp;
;;;205    		uint16_t i =0;
000002  bf00              NOP      
;;;206    		bool FLAG_485 = TRUE;
000004  bf00              NOP      
;;;207        while(DEF_TRUE) {
000006  e00e              B        |L2.38|
                  |L2.8|
;;;208    
;;;209    				/*待添加标志事件以实现超时功能*/
;;;210            ComBuffer = (unsigned char *)OSMboxPend(TxMbox, 0, &err);
000008  466a              MOV      r2,sp
00000a  2100              MOVS     r1,#0
00000c  4806              LDR      r0,|L2.40|
00000e  6800              LDR      r0,[r0,#0]  ; TxMbox
000010  f7fffffe          BL       OSMboxPend
000014  4604              MOV      r4,r0
;;;211    							
;;;212            if(err == OS_ERR_NONE) 
000016  f89d0000          LDRB     r0,[sp,#0]
00001a  b918              CBNZ     r0,|L2.36|
;;;213    				{
;;;214    					com(ComBuffer);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       ||com||
000022  e000              B        |L2.38|
                  |L2.36|
;;;215    					
;;;216    #if 0		//测试		
;;;217    					while(FLAG_485)
;;;218    					{
;;;219    							temp =  ComBuffer[i];
;;;220    							if(temp == 0XED)
;;;221    							{
;;;222    									USART_SendData(USART1, temp);
;;;223    									/* Loop until the end of transmission */
;;;224    									while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET) 
;;;225    									{
;;;226    									}
;;;227    									i = 0;
;;;228    									FLAG_485 = FALSE;
;;;229    							}
;;;230    							else				
;;;231    							{
;;;232    									USART_SendData(USART1, temp);
;;;233    									/* Loop until the end of transmission */
;;;234    									while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET) 
;;;235    									{
;;;236    									}
;;;237    									i++;
;;;238    							}
;;;239    					}
;;;240    					
;;;241    					FLAG_485 = TRUE;
;;;242    #endif					
;;;243            }
;;;244    
;;;245            /*通讯超时*/
;;;246            else if(err == OS_ERR_TIMEOUT) {
000024  bf00              NOP      
                  |L2.38|
000026  e7ef              B        |L2.8|
;;;247            }
;;;248        }
;;;249    }
;;;250    
                          ENDP

                  |L2.40|
                          DCD      TxMbox

                          AREA ||i.AppTaskCreate||, CODE, READONLY, ALIGN=2

                  AppTaskCreate PROC
;;;157    
;;;158    static  void  AppTaskCreate(void)
000000  b500              PUSH     {lr}
;;;159    {
000002  b087              SUB      sp,sp,#0x1c
;;;160        INT8U  err;
;;;161          OSTaskCreateExt(AppTaskUserif,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  f44f6280          MOV      r2,#0x400
00000c  4b1e              LDR      r3,|L3.136|
00000e  e9cd3201          STRD     r3,r2,[sp,#4]
000012  e9cd1003          STRD     r1,r0,[sp,#0xc]
000016  2009              MOVS     r0,#9
000018  4603              MOV      r3,r0
00001a  4a1c              LDR      r2,|L3.140|
00001c  9000              STR      r0,[sp,#0]
00001e  481c              LDR      r0,|L3.144|
000020  f7fffffe          BL       OSTaskCreateExt
;;;162        	             (void *)0,
;;;163        			     (OS_STK *)&AppTaskUserIFStk[APP_TASK_USER_IF_STK_SIZE-1],
;;;164        				 APP_TASK_USER_IF_PRIO,
;;;165        				 APP_TASK_USER_IF_PRIO,
;;;166        				 (OS_STK *)&AppTaskUserIFStk[0],
;;;167        				 APP_TASK_USER_IF_STK_SIZE,
;;;168        				 (void *)0,
;;;169        				 OS_TASK_OPT_STK_CHK|OS_TASK_OPT_STK_CLR);
;;;170    #if (OS_TASK_NAME_SIZE > 10)
;;;171        OSTaskNameSet(APP_TASK_USER_IF_PRIO, "UserIF", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a11b              ADR      r1,|L3.148|
000028  2009              MOVS     r0,#9
00002a  f7fffffe          BL       OSTaskNameSet
;;;172    #endif
;;;173        OSTaskCreateExt(AppTaskT_VSample,
00002e  2003              MOVS     r0,#3
000030  2100              MOVS     r1,#0
000032  f44f6280          MOV      r2,#0x400
000036  4b19              LDR      r3,|L3.156|
000038  e9cd3201          STRD     r3,r2,[sp,#4]
00003c  e9cd1003          STRD     r1,r0,[sp,#0xc]
000040  200a              MOVS     r0,#0xa
000042  4603              MOV      r3,r0
000044  4a16              LDR      r2,|L3.160|
000046  9000              STR      r0,[sp,#0]
000048  4816              LDR      r0,|L3.164|
00004a  f7fffffe          BL       OSTaskCreateExt
;;;174                        (void *)0,
;;;175                        (OS_STK *)&AppTaskT_VSampleStk[APP_TASK_T_V_SAMPLE_STK_SIZE - 1],
;;;176                        APP_TASK_T_V_SAMPLE_PRIO,
;;;177                        APP_TASK_T_V_SAMPLE_PRIO,
;;;178                        (OS_STK *)&AppTaskT_VSampleStk[0],
;;;179                        APP_TASK_T_V_SAMPLE_STK_SIZE,
;;;180                        (void *)0,
;;;181                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
;;;182    #if (OS_TASK_NAME_SIZE > 10)
;;;183        OSTaskNameSet(APP_TASK_T_V_SAMPLE_PRIO, "T_VSample", &err);
00004e  aa06              ADD      r2,sp,#0x18
000050  a115              ADR      r1,|L3.168|
000052  200a              MOVS     r0,#0xa
000054  f7fffffe          BL       OSTaskNameSet
;;;184    #endif
;;;185    
;;;186        OSTaskCreateExt(AppTaskCom_485,
000058  2003              MOVS     r0,#3
00005a  2100              MOVS     r1,#0
00005c  f44f7280          MOV      r2,#0x100
000060  4b14              LDR      r3,|L3.180|
000062  e9cd3201          STRD     r3,r2,[sp,#4]
000066  e9cd1003          STRD     r1,r0,[sp,#0xc]
00006a  2007              MOVS     r0,#7
00006c  4603              MOV      r3,r0
00006e  4a12              LDR      r2,|L3.184|
000070  9000              STR      r0,[sp,#0]
000072  4812              LDR      r0,|L3.188|
000074  f7fffffe          BL       OSTaskCreateExt
;;;187                        (void *)0,
;;;188                        (OS_STK *)&AppTaskCom_485Stk[APP_TASK_COM_485_STK_SIZE - 1],
;;;189                        APP_TASK_COM_485_PRIO,
;;;190                        APP_TASK_COM_485_PRIO,
;;;191                        (OS_STK *)&AppTaskCom_485Stk[0],
;;;192                        APP_TASK_COM_485_STK_SIZE,
;;;193                        (void *)0,
;;;194                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
;;;195    #if (OS_TASK_NAME_SIZE >12)
;;;196        OSTaskNameSet(APP_TASK_COM_485_PRIO, "Com_485", &err);
000078  aa06              ADD      r2,sp,#0x18
00007a  a111              ADR      r1,|L3.192|
00007c  2007              MOVS     r0,#7
00007e  f7fffffe          BL       OSTaskNameSet
;;;197    #endif
;;;198    }
000082  b007              ADD      sp,sp,#0x1c
000084  bd00              POP      {pc}
;;;199    
                          ENDP

000086  0000              DCW      0x0000
                  |L3.136|
                          DCD      AppTaskUserIFStk
                  |L3.140|
                          DCD      AppTaskUserIFStk+0xffc
                  |L3.144|
                          DCD      AppTaskUserif
                  |L3.148|
000094  55736572          DCB      "UserIF",0
000098  494600  
00009b  00                DCB      0
                  |L3.156|
                          DCD      AppTaskT_VSampleStk
                  |L3.160|
                          DCD      AppTaskT_VSampleStk+0xffc
                  |L3.164|
                          DCD      AppTaskT_VSample
                  |L3.168|
0000a8  545f5653          DCB      "T_VSample",0
0000ac  616d706c
0000b0  6500    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L3.180|
                          DCD      AppTaskCom_485Stk
                  |L3.184|
                          DCD      AppTaskCom_485Stk+0x3fc
                  |L3.188|
                          DCD      AppTaskCom_485
                  |L3.192|
0000c0  436f6d5f          DCB      "Com_485",0
0000c4  34383500

                          AREA ||i.AppTaskStart||, CODE, READONLY, ALIGN=2

                  AppTaskStart PROC
;;;110     
;;;111    static  void  AppTaskStart(void *p_arg)
000000  f7fffffe          BL       BSP_Init
;;;112    {
;;;113    		INT8U err;
;;;114    
;;;115    		(void)p_arg;
;;;116    		BSP_Init();                                    /* Initialize BSP functions   */
;;;117    		#if (OS_TASK_STAT_EN > 0)
;;;118    			OSStatInit();                                   /* Determine CPU                                  */
000004  f7fffffe          BL       OSStatInit
;;;119    		#endif
;;;120    		
;;;121    		TxMbox = OSMboxCreate((void *)0);							 /*创建串口通讯邮箱*/
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       OSMboxCreate
00000e  4918              LDR      r1,|L4.112|
000010  6008              STR      r0,[r1,#0]  ; TxMbox
;;;122    		DisMbox = OSMboxCreate((void *)0);							 /*显示屏的串口通讯邮箱*/
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       OSMboxCreate
000018  4916              LDR      r1,|L4.116|
00001a  6008              STR      r0,[r1,#0]  ; DisMbox
;;;123    		ParaMbox = OSMboxCreate((void *)0);	
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       OSMboxCreate
000022  4915              LDR      r1,|L4.120|
000024  6008              STR      r0,[r1,#0]  ; ParaMbox
;;;124    		
;;;125    		CalSem  = OSSemCreate(1);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       OSSemCreate
00002c  4913              LDR      r1,|L4.124|
00002e  6008              STR      r0,[r1,#0]  ; CalSem
;;;126    		DetectSem  = OSSemCreate(0);
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       OSSemCreate
000036  4912              LDR      r1,|L4.128|
000038  6008              STR      r0,[r1,#0]  ; DetectSem
;;;127    
;;;128    		AppTaskCreate();                                /* Create application tasks  */
00003a  f7fffffe          BL       AppTaskCreate
;;;129    		
;;;130    		
;;;131    		//将STM32的JTAG口JTDO、JTDI、JTCK配置成普通口，还需要拔掉JTAG才能用
;;;132    //		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
;;;133    //		GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable,ENABLE);                                          /* Create application tasks  */  
;;;134    		while(DEF_TRUE) 
00003e  e016              B        |L4.110|
                  |L4.64|
;;;135    		{			
;;;136    				OSTimeDlyHMSM(0,0,0,100);
000040  2364              MOVS     r3,#0x64
000042  2200              MOVS     r2,#0
000044  4611              MOV      r1,r2
000046  4610              MOV      r0,r2
000048  f7fffffe          BL       OSTimeDlyHMSM
;;;137    				if(FLAG_LED)
00004c  480d              LDR      r0,|L4.132|
00004e  7800              LDRB     r0,[r0,#0]  ; FLAG_LED
000050  b168              CBZ      r0,|L4.110|
;;;138    				{
;;;139    					LED1_ON;
000052  2110              MOVS     r1,#0x10
000054  480c              LDR      r0,|L4.136|
000056  f7fffffe          BL       GPIO_SetBits
;;;140    					OSTimeDlyHMSM(0,0,0,100);
00005a  2364              MOVS     r3,#0x64
00005c  2200              MOVS     r2,#0
00005e  4611              MOV      r1,r2
000060  4610              MOV      r0,r2
000062  f7fffffe          BL       OSTimeDlyHMSM
;;;141    					LED1_OFF;
000066  2110              MOVS     r1,#0x10
000068  4807              LDR      r0,|L4.136|
00006a  f7fffffe          BL       GPIO_ResetBits
                  |L4.110|
00006e  e7e7              B        |L4.64|
;;;142    				}
;;;143    		}
;;;144    }
;;;145    
                          ENDP

                  |L4.112|
                          DCD      TxMbox
                  |L4.116|
                          DCD      DisMbox
                  |L4.120|
                          DCD      ParaMbox
                  |L4.124|
                          DCD      CalSem
                  |L4.128|
                          DCD      DetectSem
                  |L4.132|
                          DCD      FLAG_LED
                  |L4.136|
                          DCD      0x40011800

                          AREA ||i.AppTaskT_VSample||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_f
                          REQUIRE _printf_fp_dec
                  AppTaskT_VSample PROC
;;;292    
;;;293    static void AppTaskT_VSample(void *pdata)
000000  f5ad6db8          SUB      sp,sp,#0x5c0
;;;294    {
;;;295    		INT8U err;
;;;296    		uint16_t i = 350;
000004  f44f75af          MOV      r5,#0x15e
;;;297    		uint16_t AD_V;
;;;298    		uint16_t AD_T;
;;;299    		uint16_t AD_r;
;;;300    		float V_value = 0.0;
000008  2000              MOVS     r0,#0
00000a  f8cd05b0          STR      r0,[sp,#0x5b0]
;;;301        float T_value = 0.0;
00000e  f8cd05ac          STR      r0,[sp,#0x5ac]
;;;302    		float r_value = 0.0;
000012  4682              MOV      r10,r0
;;;303    		float C_value = 0.0;		
000014  f8cd05a8          STR      r0,[sp,#0x5a8]
;;;304    		float r_AD[350];
;;;305    		float max = 0.0;
000018  900b              STR      r0,[sp,#0x2c]
;;;306    		float min = 0.0;
00001a  900a              STR      r0,[sp,#0x28]
;;;307    		uint32_t temp;
;;;308    		
;;;309    
;;;310    		
;;;311    		PWM_Config();					//PWM初始化
00001c  f7fffffe          BL       PWM_Config
;;;312        ADC_Configuration();	//ADC初始化
000020  f7fffffe          BL       ADC_Configuration
;;;313    		OSTimeDlyHMSM(0,0,3,0);	//上电稳定后才开始工作
000024  2300              MOVS     r3,#0
000026  2203              MOVS     r2,#3
000028  4619              MOV      r1,r3
00002a  4618              MOV      r0,r3
00002c  f7fffffe          BL       OSTimeDlyHMSM
;;;314    		
;;;315        while(DEF_TRUE) {
000030  e14a              B        |L5.712|
                  |L5.50|
;;;316    			
;;;317    			printf("ok");
000032  a0a6              ADR      r0,|L5.716|
000034  f7fffffe          BL       __2printf
;;;318    			OSSemPend(DetectSem,0,&err); //等待指令进行检测
000038  f50d62b7          ADD      r2,sp,#0x5b8
00003c  2100              MOVS     r1,#0
00003e  48a4              LDR      r0,|L5.720|
000040  6800              LDR      r0,[r0,#0]  ; DetectSem
000042  f7fffffe          BL       OSSemPend
;;;319    			
;;;320    			FLAG_LED = TRUE;//指示灯闪烁，指示采样过程
000046  2001              MOVS     r0,#1
000048  49a2              LDR      r1,|L5.724|
00004a  7008              STRB     r0,[r1,#0]
;;;321    			
;;;322    			//电压采样				
;;;323    			AD_V= (float)ADC1ConvertedValue[2]; //电压的AD码				
00004c  49a2              LDR      r1,|L5.728|
00004e  8888              LDRH     r0,[r1,#4]  ; ADC1ConvertedValue
000050  f7fffffe          BL       __aeabi_ui2f
000054  4607              MOV      r7,r0
000056  f7fffffe          BL       __aeabi_f2uiz
00005a  b286              UXTH     r6,r0
;;;324    			V_value = 	(float)AD_V/4096*3300*198/39		+72;//计算电压值
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       __aeabi_ui2f
000062  f04f418b          MOV      r1,#0x45800000
000066  9008              STR      r0,[sp,#0x20]
000068  f7fffffe          BL       __aeabi_fdiv
00006c  4683              MOV      r11,r0
00006e  499b              LDR      r1,|L5.732|
000070  f7fffffe          BL       __aeabi_fmul
000074  4680              MOV      r8,r0
000076  499a              LDR      r1,|L5.736|
000078  f7fffffe          BL       __aeabi_fmul
00007c  4999              LDR      r1,|L5.740|
00007e  9009              STR      r0,[sp,#0x24]
000080  f7fffffe          BL       __aeabi_fdiv
000084  4607              MOV      r7,r0
000086  4998              LDR      r1,|L5.744|
000088  f7fffffe          BL       __aeabi_fadd
00008c  f8cd05b0          STR      r0,[sp,#0x5b0]
;;;325    			printf("V_value= ,%f,",V_value/1000);	//打印
000090  4996              LDR      r1,|L5.748|
000092  f8dd05b0          LDR      r0,[sp,#0x5b0]
000096  f7fffffe          BL       __aeabi_fdiv
00009a  4683              MOV      r11,r0
00009c  f7fffffe          BL       __aeabi_f2d
0000a0  4607              MOV      r7,r0
0000a2  463a              MOV      r2,r7
0000a4  460b              MOV      r3,r1
0000a6  a092              ADR      r0,|L5.752|
0000a8  f7fffffe          BL       __2printf
;;;326    			
;;;327    			//温度采样
;;;328    			AD_T= (float)ADC1ConvertedValue[0]; //温度的AD码		
0000ac  498a              LDR      r1,|L5.728|
0000ae  8808              LDRH     r0,[r1,#0]  ; ADC1ConvertedValue
0000b0  f7fffffe          BL       __aeabi_ui2f
0000b4  4607              MOV      r7,r0
0000b6  f7fffffe          BL       __aeabi_f2uiz
0000ba  fa1ff980          UXTH     r9,r0
;;;329    			T_value = 1000*((float)AD_T/4096*3300*0.5-500)/10;//lm50传感器，先计算电压值,再算出温度公式：(V-500)/10
0000be  4648              MOV      r0,r9
0000c0  f7fffffe          BL       __aeabi_ui2f
0000c4  f04f418b          MOV      r1,#0x45800000
0000c8  9000              STR      r0,[sp,#0]
0000ca  f7fffffe          BL       __aeabi_fdiv
0000ce  4983              LDR      r1,|L5.732|
0000d0  9001              STR      r0,[sp,#4]
0000d2  f7fffffe          BL       __aeabi_fmul
0000d6  4683              MOV      r11,r0
0000d8  f7fffffe          BL       __aeabi_f2d
0000dc  4607              MOV      r7,r0
0000de  2200              MOVS     r2,#0
0000e0  4b87              LDR      r3,|L5.768|
0000e2  f7fffffe          BL       __aeabi_dmul
0000e6  2200              MOVS     r2,#0
0000e8  4b86              LDR      r3,|L5.772|
0000ea  e9cd0102          STRD     r0,r1,[sp,#8]
0000ee  f7fffffe          BL       __aeabi_dsub
0000f2  2200              MOVS     r2,#0
0000f4  4b84              LDR      r3,|L5.776|
0000f6  e9cd0104          STRD     r0,r1,[sp,#0x10]
0000fa  f7fffffe          BL       __aeabi_dmul
0000fe  2200              MOVS     r2,#0
000100  4b82              LDR      r3,|L5.780|
000102  e9cd0106          STRD     r0,r1,[sp,#0x18]
000106  f7fffffe          BL       __aeabi_ddiv
00010a  e9cd0108          STRD     r0,r1,[sp,#0x20]
00010e  f7fffffe          BL       __aeabi_d2f
000112  f8cd05ac          STR      r0,[sp,#0x5ac]
;;;330    			printf("T_value= ,%f,",T_value/1000);	//打印
000116  4975              LDR      r1,|L5.748|
000118  f8dd05ac          LDR      r0,[sp,#0x5ac]
00011c  f7fffffe          BL       __aeabi_fdiv
000120  4683              MOV      r11,r0
000122  f7fffffe          BL       __aeabi_f2d
000126  4607              MOV      r7,r0
000128  463a              MOV      r2,r7
00012a  460b              MOV      r3,r1
00012c  a078              ADR      r0,|L5.784|
00012e  f7fffffe          BL       __2printf
;;;331    			
;;;332    			//内阻采样
;;;333    			TIM_Cmd(TIM2, ENABLE);
000132  2101              MOVS     r1,#1
000134  0788              LSLS     r0,r1,#30
000136  f7fffffe          BL       TIM_Cmd
;;;334    			TIM_CtrlPWMOutputs(TIM2, ENABLE );
00013a  2101              MOVS     r1,#1
00013c  0788              LSLS     r0,r1,#30
00013e  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;335    			OSTimeDlyHMSM(0,0,0,500);//等待500ms使内阻检测波形稳定
000142  f44f73fa          MOV      r3,#0x1f4
000146  2200              MOVS     r2,#0
000148  4611              MOV      r1,r2
00014a  4610              MOV      r0,r2
00014c  f7fffffe          BL       OSTimeDlyHMSM
;;;336    		 	i = 350;//大约采集3个半周期波形
000150  f44f75af          MOV      r5,#0x15e
;;;337    		  while(i)
000154  e03a              B        |L5.460|
                  |L5.342|
;;;338    			{
;;;339    				OSTimeDlyHMSM(0,0,0,1);
000156  2301              MOVS     r3,#1
000158  2200              MOVS     r2,#0
00015a  4611              MOV      r1,r2
00015c  4610              MOV      r0,r2
00015e  f7fffffe          BL       OSTimeDlyHMSM
;;;340    				AD_r= (float)ADC1ConvertedValue[1]; //内阻波形的AD码
000162  495d              LDR      r1,|L5.728|
000164  8848              LDRH     r0,[r1,#2]  ; ADC1ConvertedValue
000166  f7fffffe          BL       __aeabi_ui2f
00016a  4607              MOV      r7,r0
00016c  f7fffffe          BL       __aeabi_f2uiz
000170  b280              UXTH     r0,r0
000172  f8cd05b4          STR      r0,[sp,#0x5b4]
;;;341    				AD_r = 	(float)AD_r/4096*3300*198/39   *4;//计算电压值，见原理图（39/198分压）
000176  f8dd05b4          LDR      r0,[sp,#0x5b4]
00017a  f7fffffe          BL       __aeabi_ui2f
00017e  f04f418b          MOV      r1,#0x45800000
000182  9007              STR      r0,[sp,#0x1c]
000184  f7fffffe          BL       __aeabi_fdiv
000188  4683              MOV      r11,r0
00018a  4954              LDR      r1,|L5.732|
00018c  f7fffffe          BL       __aeabi_fmul
000190  4953              LDR      r1,|L5.736|
000192  9008              STR      r0,[sp,#0x20]
000194  f7fffffe          BL       __aeabi_fmul
000198  4680              MOV      r8,r0
00019a  4952              LDR      r1,|L5.740|
00019c  f7fffffe          BL       __aeabi_fdiv
0001a0  f04f4181          MOV      r1,#0x40800000
0001a4  9009              STR      r0,[sp,#0x24]
0001a6  f7fffffe          BL       __aeabi_fmul
0001aa  4607              MOV      r7,r0
0001ac  f7fffffe          BL       __aeabi_f2uiz
0001b0  b280              UXTH     r0,r0
0001b2  f8cd05b4          STR      r0,[sp,#0x5b4]
;;;342    				r_AD[350-i] = AD_r;
0001b6  f8dd05b4          LDR      r0,[sp,#0x5b4]
0001ba  f7fffffe          BL       __aeabi_ui2f
0001be  f5c571af          RSB      r1,r5,#0x15e
0001c2  aa0c              ADD      r2,sp,#0x30
0001c4  f8420021          STR      r0,[r2,r1,LSL #2]
;;;343    				i--;
0001c8  1e68              SUBS     r0,r5,#1
0001ca  b285              UXTH     r5,r0
                  |L5.460|
0001cc  2d00              CMP      r5,#0                 ;337
0001ce  d1c2              BNE      |L5.342|
;;;344    			}
;;;345    			//采样结束
;;;346    			TIM_Cmd(TIM2, DISABLE);
0001d0  2100              MOVS     r1,#0
0001d2  f04f4080          MOV      r0,#0x40000000
0001d6  f7fffffe          BL       TIM_Cmd
;;;347    			TIM_CtrlPWMOutputs(TIM2, DISABLE );
0001da  2100              MOVS     r1,#0
0001dc  f04f4080          MOV      r0,#0x40000000
0001e0  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;348    			TIM_ForcedOC1Config(TIM2, TIM_ForcedAction_InActive);//输出PWM波结束后强制置低电平。没有则高低电平不定
0001e4  2140              MOVS     r1,#0x40
0001e6  0608              LSLS     r0,r1,#24
0001e8  f7fffffe          BL       TIM_ForcedOC1Config
;;;349    			PWM_Config();//强制置电平后无法恢复，只能重新初始化
0001ec  f7fffffe          BL       PWM_Config
;;;350    			
;;;351    			//输出内阻值
;;;352    			max = max_value(r_AD,sizeof(r_AD)/4);
0001f0  f44f71af          MOV      r1,#0x15e
0001f4  a80c              ADD      r0,sp,#0x30
0001f6  f7fffffe          BL       max_value
0001fa  900b              STR      r0,[sp,#0x2c]
;;;353    			min = min_value(r_AD,sizeof(r_AD)/4);
0001fc  f44f71af          MOV      r1,#0x15e
000200  a80c              ADD      r0,sp,#0x30
000202  f7fffffe          BL       min_value
000206  900a              STR      r0,[sp,#0x28]
;;;354    			r_value = max-min;
000208  e9dd100a          LDRD     r1,r0,[sp,#0x28]
00020c  f7fffffe          BL       __aeabi_fsub
000210  4682              MOV      r10,r0
;;;355    			printf("r_value= ,%f,",r_value/1000);	//打印内阻值
000212  4936              LDR      r1,|L5.748|
000214  4650              MOV      r0,r10
000216  f7fffffe          BL       __aeabi_fdiv
00021a  4683              MOV      r11,r0
00021c  f7fffffe          BL       __aeabi_f2d
000220  4607              MOV      r7,r0
000222  463a              MOV      r2,r7
000224  460b              MOV      r3,r1
000226  a03e              ADR      r0,|L5.800|
000228  f7fffffe          BL       __2printf
;;;356    			C_value= 180 - 80 * r_value / r_Cal_C/1000;
00022c  4651              MOV      r1,r10
00022e  4840              LDR      r0,|L5.816|
000230  f7fffffe          BL       __aeabi_fmul
000234  4683              MOV      r11,r0
000236  493f              LDR      r1,|L5.820|
000238  f7fffffe          BL       __aeabi_fdiv
00023c  4680              MOV      r8,r0
00023e  492b              LDR      r1,|L5.748|
000240  f7fffffe          BL       __aeabi_fdiv
000244  4607              MOV      r7,r0
000246  493c              LDR      r1,|L5.824|
000248  f7fffffe          BL       __aeabi_frsub
00024c  f8cd05a8          STR      r0,[sp,#0x5a8]
;;;357    			printf("C_value = ,%f\r\n",C_value);
000250  f8dd05a8          LDR      r0,[sp,#0x5a8]
000254  f7fffffe          BL       __aeabi_f2d
000258  4607              MOV      r7,r0
00025a  463a              MOV      r2,r7
00025c  460b              MOV      r3,r1
00025e  a037              ADR      r0,|L5.828|
000260  f7fffffe          BL       __2printf
;;;358    
;;;359    			//有线通讯
;;;360    			temp = (uint32_t)V_value;
000264  f8dd05b0          LDR      r0,[sp,#0x5b0]
000268  f7fffffe          BL       __aeabi_f2uiz
00026c  4604              MOV      r4,r0
;;;361    			COM_Buffer[0] = (uint8_t)(temp&0x000000FF);
00026e  4937              LDR      r1,|L5.844|
000270  700c              STRB     r4,[r1,#0]
;;;362    			COM_Buffer[1] = (uint8_t)( (temp&0x0000FF00)>>8 );
000272  0a20              LSRS     r0,r4,#8
000274  7048              STRB     r0,[r1,#1]
;;;363    			COM_Buffer[2] = (uint8_t)( (temp&0x00FF0000)>>16 );
000276  0c20              LSRS     r0,r4,#16
000278  7088              STRB     r0,[r1,#2]
;;;364    			COM_Buffer[3] = (uint8_t)( (temp&0xFF000000)>>24 );	
00027a  0e20              LSRS     r0,r4,#24
00027c  70c8              STRB     r0,[r1,#3]
;;;365    //			printf("V_value= ,%d,",temp);	//打印
;;;366    			temp = (uint32_t)T_value;
00027e  f8dd05ac          LDR      r0,[sp,#0x5ac]
000282  f7fffffe          BL       __aeabi_f2uiz
000286  4604              MOV      r4,r0
;;;367    			COM_Buffer[4] = (uint8_t)(temp&0x000000FF);
000288  4930              LDR      r1,|L5.844|
00028a  710c              STRB     r4,[r1,#4]
;;;368    			COM_Buffer[5] = (uint8_t)( (temp&0x0000FF00)>>8 );
00028c  0a20              LSRS     r0,r4,#8
00028e  7148              STRB     r0,[r1,#5]
;;;369    			COM_Buffer[6] = (uint8_t)( (temp&0x00FF0000)>>16 );
000290  0c20              LSRS     r0,r4,#16
000292  7188              STRB     r0,[r1,#6]
;;;370    			COM_Buffer[7] = (uint8_t)( (temp&0xFF000000)>>24 );	
000294  0e20              LSRS     r0,r4,#24
000296  71c8              STRB     r0,[r1,#7]
;;;371    //			printf("T_value= ,%d,",temp);	//打印			
;;;372    			temp = (uint32_t)r_value;
000298  4650              MOV      r0,r10
00029a  f7fffffe          BL       __aeabi_f2uiz
00029e  4604              MOV      r4,r0
;;;373    			COM_Buffer[8] = (uint8_t)(temp&0x000000FF);
0002a0  492a              LDR      r1,|L5.844|
0002a2  720c              STRB     r4,[r1,#8]
;;;374    			COM_Buffer[9] = (uint8_t)( (temp&0x0000FF00)>>8 );
0002a4  0a20              LSRS     r0,r4,#8
0002a6  7248              STRB     r0,[r1,#9]
;;;375    			COM_Buffer[10] = (uint8_t)( (temp&0x00FF0000)>>16 );
0002a8  0c20              LSRS     r0,r4,#16
0002aa  7288              STRB     r0,[r1,#0xa]
;;;376    			COM_Buffer[11] = (uint8_t)( (temp&0xFF000000)>>24 );		
0002ac  0e20              LSRS     r0,r4,#24
0002ae  72c8              STRB     r0,[r1,#0xb]
;;;377    //			printf("r_value= ,%d,",temp);	//打印
;;;378    			//两个邮箱一个供有线通信用，一个供无线通讯用
;;;379    			OSMboxPost(ParaMbox, (void *)COM_Buffer);
0002b0  4827              LDR      r0,|L5.848|
0002b2  6800              LDR      r0,[r0,#0]  ; ParaMbox
0002b4  f7fffffe          BL       OSMboxPost
;;;380    			OSMboxPost(ParaMbox, (void *)COM_Buffer);	
0002b8  4924              LDR      r1,|L5.844|
0002ba  4825              LDR      r0,|L5.848|
0002bc  6800              LDR      r0,[r0,#0]  ; ParaMbox
0002be  f7fffffe          BL       OSMboxPost
;;;381    			
;;;382    //			n95_Sendout(COM_Buffer);					// 无线发送
;;;383    			
;;;384    			FLAG_LED = FALSE;//关闭指示灯
0002c2  2000              MOVS     r0,#0
0002c4  4903              LDR      r1,|L5.724|
0002c6  7008              STRB     r0,[r1,#0]
                  |L5.712|
0002c8  e6b3              B        |L5.50|
;;;385    			
;;;386    						//内阻检测时间间隔
;;;387    //			OSTimeDlyHMSM(0,0,10,0);
;;;388    		}
;;;389    
;;;390    
;;;391    }
;;;392    
                          ENDP

0002ca  0000              DCW      0x0000
                  |L5.716|
0002cc  6f6b00            DCB      "ok",0
0002cf  00                DCB      0
                  |L5.720|
                          DCD      DetectSem
                  |L5.724|
                          DCD      FLAG_LED
                  |L5.728|
                          DCD      ADC1ConvertedValue
                  |L5.732|
                          DCD      0x454e4000
                  |L5.736|
                          DCD      0x43460000
                  |L5.740|
                          DCD      0x421c0000
                  |L5.744|
                          DCD      0x42900000
                  |L5.748|
                          DCD      0x447a0000
                  |L5.752|
0002f0  565f7661          DCB      "V_value= ,%f,",0
0002f4  6c75653d
0002f8  202c2566
0002fc  2c00    
0002fe  00                DCB      0
0002ff  00                DCB      0
                  |L5.768|
                          DCD      0x3fe00000
                  |L5.772|
                          DCD      0x407f4000
                  |L5.776|
                          DCD      0x408f4000
                  |L5.780|
                          DCD      0x40240000
                  |L5.784|
000310  545f7661          DCB      "T_value= ,%f,",0
000314  6c75653d
000318  202c2566
00031c  2c00    
00031e  00                DCB      0
00031f  00                DCB      0
                  |L5.800|
000320  725f7661          DCB      "r_value= ,%f,",0
000324  6c75653d
000328  202c2566
00032c  2c00    
00032e  00                DCB      0
00032f  00                DCB      0
                  |L5.816|
                          DCD      0x42a00000
                  |L5.820|
                          DCD      0x41200000
                  |L5.824|
                          DCD      0x43340000
                  |L5.828|
00033c  435f7661          DCB      "C_value = ,%f\r\n",0
000340  6c756520
000344  3d202c25
000348  660d0a00
                  |L5.844|
                          DCD      COM_Buffer
                  |L5.848|
                          DCD      ParaMbox

                          AREA ||i.AppTaskUserif||, CODE, READONLY, ALIGN=2

                  AppTaskUserif PROC
;;;250    
;;;251    static void AppTaskUserif(void *pdata)
000000  bf00              NOP      
;;;252    {
;;;253    		INT8U err;
;;;254    		uint32_t temp=0;
;;;255    		float V_value = 0.0;
000002  bf00              NOP      
;;;256        float T_value = 0.0;
000004  bf00              NOP      
;;;257    		float r_value = 0.0;	
000006  bf00              NOP      
;;;258    		float C_value = 0.0;	
000008  bf00              NOP      
;;;259    		
;;;260    
;;;261    		n95_Init_IO();										// 初始化nRF905引脚状态
00000a  f7fffffe          BL       n95_Init_IO
;;;262    		n95_Init_Dev();										// 初始化nRF905,并将其转换为接收状态
00000e  f7fffffe          BL       n95_Init_Dev
;;;263    	  while (DEF_TRUE)
000012  e00c              B        |L6.46|
                  |L6.20|
;;;264       {
;;;265    			if(n95_Check_DR(n95_RX_Buff)){					// 检查IRQ引脚状态
000014  4806              LDR      r0,|L6.48|
000016  f7fffffe          BL       n95_Check_DR
00001a  b110              CBZ      r0,|L6.34|
;;;266    				com(n95_RX_Buff);
00001c  4804              LDR      r0,|L6.48|
00001e  f7fffffe          BL       ||com||
                  |L6.34|
;;;267    #if 0				
;;;268    				// 接收处理
;;;269    				temp = ( ((uint32_t)n95_RX_Buff[3])<<24 ) + ( ((uint32_t)n95_RX_Buff[2])<<16 ) \
;;;270    							+ ( ((uint32_t)n95_RX_Buff[1])<<8 ) + (uint32_t)n95_RX_Buff[0];
;;;271    					V_value=((float)temp)/1000;
;;;272    					printf("V_value = ,%f,",V_value);
;;;273    						
;;;274    					temp = ( ((uint32_t)n95_RX_Buff[7])<<24 ) + ( ((uint32_t)n95_RX_Buff[6])<<16 ) \
;;;275    							+ ( ((uint32_t)n95_RX_Buff[5])<<8 ) + (uint32_t)n95_RX_Buff[4];	
;;;276    					T_value=((float)temp)/1000;
;;;277    					printf("T_value = ,%f,",T_value);
;;;278    					
;;;279    					temp = ( ((uint32_t)n95_RX_Buff[11])<<24 ) + ( ((uint32_t)n95_RX_Buff[10])<<16 ) \
;;;280    							+ ( ((uint32_t)n95_RX_Buff[9])<<8 ) + (uint32_t)n95_RX_Buff[8];
;;;281    					r_value=((float)temp)/1000;
;;;282    					printf("r_value = ,%f,",r_value);
;;;283    					
;;;284    					C_value= 180 - 80 * r_value / r_Cal_C;
;;;285    					printf("C_value = ,%f\r\n",C_value);
;;;286    #endif			
;;;287    			}
;;;288    				OSTimeDlyHMSM(0,0,0,10);
000022  230a              MOVS     r3,#0xa
000024  2200              MOVS     r2,#0
000026  4611              MOV      r1,r2
000028  4610              MOV      r0,r2
00002a  f7fffffe          BL       OSTimeDlyHMSM
                  |L6.46|
00002e  e7f1              B        |L6.20|
;;;289    	 }
;;;290    
;;;291    }
;;;292    
                          ENDP

                  |L6.48|
                          DCD      n95_RX_Buff

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;75     	 
;;;76     int  main(void)
000000  b500              PUSH     {lr}
;;;77      {
000002  b087              SUB      sp,sp,#0x1c
;;;78         INT8U  err;
;;;79     
;;;80     		
;;;81         /* Set the Vector Table base location at 0x08000000 */
;;;82         NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x00);
000004  2100              MOVS     r1,#0
000006  f04f6000          MOV      r0,#0x8000000
00000a  f7fffffe          BL       NVIC_SetVectorTable
;;;83         //BSP_IntDisAll();                   /* Disable all interrupts until we are ready to accept them */
;;;84         OSInit();                          /* Initialize "uC/OS-II, The Real-Time Kernel"              */
00000e  f7fffffe          BL       OSInit
;;;85     				
;;;86         /* Create the start task */
;;;87         OSTaskCreateExt(AppTaskStart, (void *)0, (OS_STK *)&AppTaskStartStk[APP_TASK_START_STK_SIZE - 1], APP_TASK_START_PRIO, APP_TASK_START_PRIO, (OS_STK *)&AppTaskStartStk[0], APP_TASK_START_STK_SIZE, (void *)0, OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
000012  2003              MOVS     r0,#3
000014  2100              MOVS     r1,#0
000016  229c              MOVS     r2,#0x9c
000018  4b0a              LDR      r3,|L7.68|
00001a  e9cd1003          STRD     r1,r0,[sp,#0xc]
00001e  e9cd3201          STRD     r3,r2,[sp,#4]
000022  9000              STR      r0,[sp,#0]
000024  4603              MOV      r3,r0
000026  4a08              LDR      r2,|L7.72|
000028  4808              LDR      r0,|L7.76|
00002a  f7fffffe          BL       OSTaskCreateExt
;;;88     #if (OS_TASK_NAME_SIZE > 13)
;;;89         OSTaskNameSet(APP_TASK_START_PRIO, "Start Task", &err);
00002e  aa06              ADD      r2,sp,#0x18
000030  a107              ADR      r1,|L7.80|
000032  2003              MOVS     r0,#3
000034  f7fffffe          BL       OSTaskNameSet
;;;90     #endif
;;;91         OSStart();                                                  /* Start multitasking (i.e. give control to uC/OS-II)       */
000038  f7fffffe          BL       OSStart
;;;92     }
00003c  2000              MOVS     r0,#0
00003e  b007              ADD      sp,sp,#0x1c
000040  bd00              POP      {pc}
;;;93     
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      AppTaskStartStk
                  |L7.72|
                          DCD      AppTaskStartStk+0x26c
                  |L7.76|
                          DCD      AppTaskStart
                  |L7.80|
000050  53746172          DCB      "Start Task",0
000054  74205461
000058  736b00  
00005b  00                DCB      0

                          AREA ||i.max_value||, CODE, READONLY, ALIGN=1

                  max_value PROC
;;;394    /*求数组最大值*/
;;;395    static float max_value(float arr[],uint16_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;396    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;397    	int i;
;;;398    	float max = arr[0];
000008  6827              LDR      r7,[r4,#0]
;;;399    	for(i=1;i<size;i++)
00000a  2501              MOVS     r5,#1
00000c  e008              B        |L8.32|
                  |L8.14|
;;;400    	{
;;;401    		if(max<arr[i])
00000e  f8541025          LDR      r1,[r4,r5,LSL #2]
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       __aeabi_cfcmple
000018  d201              BCS      |L8.30|
;;;402    		{
;;;403    			max = arr[i];
00001a  f8547025          LDR      r7,[r4,r5,LSL #2]
                  |L8.30|
00001e  1c6d              ADDS     r5,r5,#1              ;399
                  |L8.32|
000020  42b5              CMP      r5,r6                 ;399
000022  dbf4              BLT      |L8.14|
;;;404    		}
;;;405    	}
;;;406    	return max;
000024  4638              MOV      r0,r7
;;;407    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;408    
                          ENDP


                          AREA ||i.min_value||, CODE, READONLY, ALIGN=1

                  min_value PROC
;;;409    /*求数组最小值*/
;;;410    static float min_value(float arr[],uint16_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;411    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;412    	int i;
;;;413    	float min = arr[0];
000008  6827              LDR      r7,[r4,#0]
;;;414    	for(i=1;i<size;i++)
00000a  2501              MOVS     r5,#1
00000c  e008              B        |L9.32|
                  |L9.14|
;;;415    	{
;;;416    		if(min>arr[i])
00000e  f8541025          LDR      r1,[r4,r5,LSL #2]
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       __aeabi_cfrcmple
000018  d201              BCS      |L9.30|
;;;417    		{
;;;418    			min = arr[i];
00001a  f8547025          LDR      r7,[r4,r5,LSL #2]
                  |L9.30|
00001e  1c6d              ADDS     r5,r5,#1              ;414
                  |L9.32|
000020  42b5              CMP      r5,r6                 ;414
000022  dbf4              BLT      |L9.14|
;;;419    		}
;;;420    	}
;;;421    	return min;
000024  4638              MOV      r0,r7
;;;422    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;423    static void ADC_Configuration(void)
                          ENDP


                          AREA ||i.wtd||, CODE, READONLY, ALIGN=1

                  wtd PROC
;;;497    
;;;498    void wtd(void)
000000  b510              PUSH     {r4,lr}
;;;499    {
;;;500    	if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
000002  207d              MOVS     r0,#0x7d
000004  f7fffffe          BL       RCC_GetFlagStatus
000008  b108              CBZ      r0,|L10.14|
;;;501    	
;;;502    		RCC_ClearFlag();
00000a  f7fffffe          BL       RCC_ClearFlag
                  |L10.14|
;;;503    	
;;;504    	
;;;505    	
;;;506    	/* NVIC configuration */
;;;507    //	NVIC_Configuration();
;;;508    	
;;;509    	/* WWDG configuration */
;;;510    	/* Enable WWDG clock */
;;;511    //	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
;;;512    	
;;;513    	  IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
00000e  f2455055          MOV      r0,#0x5555
000012  f7fffffe          BL       IWDG_WriteAccessCmd
;;;514    	
;;;515    	  /* IWDG counter clock: 40KHz(LSI) / 32 = 1.25 KHz */
;;;516    	  IWDG_SetPrescaler(IWDG_Prescaler_64);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       IWDG_SetPrescaler
;;;517    	
;;;518    	  /* Set counter reload value to 349 */
;;;519    	  IWDG_SetReload(0xfff);
00001c  f64070ff          MOV      r0,#0xfff
000020  f7fffffe          BL       IWDG_SetReload
;;;520    	
;;;521    	  /* Reload IWDG counter */
;;;522    	  IWDG_ReloadCounter();
000024  f7fffffe          BL       IWDG_ReloadCounter
;;;523    	
;;;524    	  /* Enable IWDG (the LSI oscillator will be enabled by hardware) */
;;;525    	  IWDG_Enable();
000028  f7fffffe          BL       IWDG_Enable
;;;526    }
00002c  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  COM_Buffer
                          %        16
                  AppTaskStartStk
                          %        624
                  AppTaskUserIFStk
                          %        4096
                  AppTaskT_VSampleStk
                          %        4096
                  AppTaskCom_485Stk
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  r_Cal_C
000000  41200000          DCFS     0x41200000 ; 10

                          AREA ||.data||, DATA, ALIGN=2

                  FLAG_LED
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  TxMbox
                          DCD      0x00000000
                  DisMbox
                          DCD      0x00000000
                  ParaMbox
                          DCD      0x00000000
                  CalSem
                          DCD      0x00000000
                  DetectSem
                          DCD      0x00000000
                  ADC1ConvertedValue
                          %        8

                  __ARM_use_no_argv EQU 0
