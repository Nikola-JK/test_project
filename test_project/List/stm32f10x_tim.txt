; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_tim.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\Source\APP -I.\Source\BSP -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\inc -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\Source\Libraries\CMSIS\Core\CM3 -I.\Source\APP\HMI -I"D:\Program Files (x86)\keil\ARM\RV31\INC" -I"D:\Program Files (x86)\keil\ARM\PACK\ARM\CMSIS\3.20.3\CMSIS\Include" -I"D:\Program Files (x86)\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.2\Device\Include" -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_tim.crf Source\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;2654     */
;;;2655   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2656                          uint16_t TIM_ICFilter)
;;;2657   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2658     uint16_t tmpccmr1 = 0, tmpccer = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;2659     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2660     TIMx->CCER &= CCER_CC1E_Reset;
00000a  8c06              LDRH     r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;2661     tmpccmr1 = TIMx->CCMR1;
000014  8b01              LDRH     r1,[r0,#0x18]
;;;2662     tmpccer = TIMx->CCER;
000016  8c02              LDRH     r2,[r0,#0x20]
;;;2663     /* Select the Input and set the filter */
;;;2664     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000018  f64f760c          MOV      r6,#0xff0c
00001c  4031              ANDS     r1,r1,r6
;;;2665     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00001e  1c7e              ADDS     r6,r7,#1
000020  ea061603          AND      r6,r6,r3,LSL #4
000024  432e              ORRS     r6,r6,r5
000026  4331              ORRS     r1,r1,r6
;;;2666     /* Select the Polarity and set the CC1E Bit */
;;;2667     tmpccer &= CCER_CC1P_Reset;
000028  1e7e              SUBS     r6,r7,#1
00002a  4032              ANDS     r2,r2,r6
;;;2668     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)CCER_CC1E_Set);
00002c  f0440601          ORR      r6,r4,#1
000030  4332              ORRS     r2,r2,r6
;;;2669     /* Write to TIMx CCMR1 and CCER registers */
;;;2670     TIMx->CCMR1 = tmpccmr1;
000032  8301              STRH     r1,[r0,#0x18]
;;;2671     TIMx->CCER = tmpccer;
000034  8402              STRH     r2,[r0,#0x20]
;;;2672   }
000036  bdf0              POP      {r4-r7,pc}
;;;2673   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;2689     */
;;;2690   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2691                          uint16_t TIM_ICFilter)
;;;2692   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2693     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;2694     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2695     TIMx->CCER &= CCER_CC2E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2696     tmpccmr1 = TIMx->CCMR1;
000018  8b01              LDRH     r1,[r0,#0x18]
;;;2697     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;2698     tmp = (uint16_t)(TIM_ICPolarity << 4);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea071604          AND      r6,r7,r4,LSL #4
;;;2699     /* Select the Input and set the filter */
;;;2700     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;2701     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea073703          AND      r7,r7,r3,LSL #12
000032  4339              ORRS     r1,r1,r7
;;;2702     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea072705          AND      r7,r7,r5,LSL #8
00003c  4339              ORRS     r1,r1,r7
;;;2703     /* Select the Polarity and set the CC2E Bit */
;;;2704     tmpccer &= CCER_CC2P_Reset;
00003e  f64f77df          MOV      r7,#0xffdf
000042  403a              ANDS     r2,r2,r7
;;;2705     tmpccer |=  (uint16_t)(tmp | (uint16_t)CCER_CC2E_Set);
000044  f0460710          ORR      r7,r6,#0x10
000048  433a              ORRS     r2,r2,r7
;;;2706     /* Write to TIMx CCMR1 and CCER registers */
;;;2707     TIMx->CCMR1 = tmpccmr1 ;
00004a  8301              STRH     r1,[r0,#0x18]
;;;2708     TIMx->CCER = tmpccer;
00004c  8402              STRH     r2,[r0,#0x20]
;;;2709   }
00004e  bdf0              POP      {r4-r7,pc}
;;;2710   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;2726     */
;;;2727   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2728                          uint16_t TIM_ICFilter)
;;;2729   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2730     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;2731     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2732     TIMx->CCER &= CCER_CC3E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2733     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;2734     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;2735     tmp = (uint16_t)(TIM_ICPolarity << 8);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea072604          AND      r6,r7,r4,LSL #8
;;;2736     /* Select the Input and set the filter */
;;;2737     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000024  f64f770c          MOV      r7,#0xff0c
000028  4039              ANDS     r1,r1,r7
;;;2738     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea071703          AND      r7,r7,r3,LSL #4
000032  432f              ORRS     r7,r7,r5
000034  4339              ORRS     r1,r1,r7
;;;2739     /* Select the Polarity and set the CC3E Bit */
;;;2740     tmpccer &= CCER_CC3P_Reset;
000036  f64f57ff          MOV      r7,#0xfdff
00003a  403a              ANDS     r2,r2,r7
;;;2741     tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC3E_Set);
00003c  f4467780          ORR      r7,r6,#0x100
000040  433a              ORRS     r2,r2,r7
;;;2742     /* Write to TIMx CCMR2 and CCER registers */
;;;2743     TIMx->CCMR2 = tmpccmr2;
000042  8381              STRH     r1,[r0,#0x1c]
;;;2744     TIMx->CCER = tmpccer;
000044  8402              STRH     r2,[r0,#0x20]
;;;2745   }
000046  bdf0              POP      {r4-r7,pc}
;;;2746   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;2762     */
;;;2763   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2764                          uint16_t TIM_ICFilter)
;;;2765   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2766     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;2767   
;;;2768     /* Disable the Channel 4: Reset the CC4E Bit */
;;;2769     TIMx->CCER &= CCER_CC4E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2770     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;2771     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;2772     tmp = (uint16_t)(TIM_ICPolarity << 12);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea073604          AND      r6,r7,r4,LSL #12
;;;2773   
;;;2774     /* Select the Input and set the filter */
;;;2775     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;2776     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea072705          AND      r7,r7,r5,LSL #8
000032  4339              ORRS     r1,r1,r7
;;;2777     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea073703          AND      r7,r7,r3,LSL #12
00003c  4339              ORRS     r1,r1,r7
;;;2778   
;;;2779     /* Select the Polarity and set the CC4E Bit */
;;;2780     tmpccer &= CCER_CC4P_Reset;
00003e  f64d77ff          MOV      r7,#0xdfff
000042  403a              ANDS     r2,r2,r7
;;;2781     tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC4E_Set);
000044  f4465780          ORR      r7,r6,#0x1000
000048  433a              ORRS     r2,r2,r7
;;;2782     /* Write to TIMx CCMR2 and CCER registers */
;;;2783     TIMx->CCMR2 = tmpccmr2;
00004a  8381              STRH     r1,[r0,#0x1c]
;;;2784     TIMx->CCER = tmpccer ;
00004c  8402              STRH     r2,[r0,#0x20]
;;;2785   }
00004e  bdf0              POP      {r4-r7,pc}
;;;2786   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1385     */
;;;1386   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;1387   {
;;;1388     /* Check the parameters */
;;;1389     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1390     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1391     if (NewState != DISABLE)
;;;1392     {
;;;1393       /* Set the ARR Preload Bit */
;;;1394       TIMx->CR1 |= CR1_ARPE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;1395     }
;;;1396     else
;;;1397     {
;;;1398       /* Reset the ARR Preload Bit */
;;;1399       TIMx->CR1 &= CR1_ARPE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f240337f          MOV      r3,#0x37f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;1400     }
;;;1401   }
000016  4770              BX       lr
;;;1402   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;693      */
;;;694    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;695    {
;;;696      /* Check the parameters */
;;;697      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;698      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;699      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;700      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;701      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;702      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;703      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;704      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;705         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;706      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02044          STRH     r2,[r0,#0x44]
;;;707                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;708                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;709                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;710    }
00001e  4770              BX       lr
;;;711    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;768      */
;;;769    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;770    {
;;;771      /* Set the default configuration */
;;;772      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;773      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;774      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;775      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;776      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;777      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;778      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;779    }
000010  4770              BX       lr
;;;780    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1457     */
;;;1458   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;1459   { 
;;;1460     /* Check the parameters */
;;;1461     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1462     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1463     if (NewState != DISABLE)
;;;1464     {
;;;1465       /* Set the CCPC Bit */
;;;1466       TIMx->CR2 |= CR2_CCPC_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;1467     }
;;;1468     else
;;;1469     {
;;;1470       /* Reset the CCPC Bit */
;;;1471       TIMx->CR2 &= CR2_CCPC_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;1472     }
;;;1473   }
000016  4770              BX       lr
;;;1474   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1944     */
;;;1945   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b530              PUSH     {r4,r5,lr}
;;;1946   {
;;;1947     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1948   
;;;1949     /* Check the parameters */
;;;1950     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1951     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1952     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1953   
;;;1954     tmp = CCER_CCE_Set << TIM_Channel;
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1955   
;;;1956     /* Reset the CCxE Bit */
;;;1957     TIMx->CCER &= (uint16_t)~ tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1958   
;;;1959     /* Set or reset the CCxE Bit */ 
;;;1960     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1961   }
00001c  bd30              POP      {r4,r5,pc}
;;;1962   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1974     */
;;;1975   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b530              PUSH     {r4,r5,lr}
;;;1976   {
;;;1977     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1978   
;;;1979     /* Check the parameters */
;;;1980     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1981     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1982     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1983   
;;;1984     tmp = CCER_CCNE_Set << TIM_Channel;
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1985   
;;;1986     /* Reset the CCxNE Bit */
;;;1987     TIMx->CCER &= (uint16_t) ~tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1988   
;;;1989     /* Set or reset the CCxNE Bit */ 
;;;1990     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1991   }
00001c  bd30              POP      {r4,r5,pc}
;;;1992   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2561     */
;;;2562   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2563   {  
;;;2564     /* Check the parameters */
;;;2565     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2566     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2567      
;;;2568     /* Clear the flags */
;;;2569     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2570   }
000004  4770              BX       lr
;;;2571   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2629     */
;;;2630   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2631   {
;;;2632     /* Check the parameters */
;;;2633     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2634     assert_param(IS_TIM_IT(TIM_IT));
;;;2635     /* Clear the IT pending Bit */
;;;2636     TIMx->SR = (uint16_t)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;2637   }
000004  4770              BX       lr
;;;2638   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1679     */
;;;1680   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1681   {
;;;1682     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1683     /* Check the parameters */
;;;1684     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1685     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1686     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1687     /* Reset the OC1CE Bit */
;;;1688     tmpccmr1 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1689     /* Enable or Disable the Output Compare Clear Bit */
;;;1690     tmpccmr1 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1691     /* Write to TIMx CCMR1 register */
;;;1692     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1693   }
000010  4770              BX       lr
;;;1694   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1703     */
;;;1704   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1705   {
;;;1706     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1707     /* Check the parameters */
;;;1708     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1709     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1710     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1711     /* Reset the OC2CE Bit */
;;;1712     tmpccmr1 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1713     /* Enable or Disable the Output Compare Clear Bit */
;;;1714     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1715     /* Write to TIMx CCMR1 register */
;;;1716     TIMx->CCMR1 = tmpccmr1;
000014  8301              STRH     r1,[r0,#0x18]
;;;1717   }
000016  4770              BX       lr
;;;1718   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1727     */
;;;1728   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1729   {
;;;1730     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1731     /* Check the parameters */
;;;1732     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1733     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1734     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1735     /* Reset the OC3CE Bit */
;;;1736     tmpccmr2 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1737     /* Enable or Disable the Output Compare Clear Bit */
;;;1738     tmpccmr2 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1739     /* Write to TIMx CCMR2 register */
;;;1740     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1741   }
000010  4770              BX       lr
;;;1742   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1751     */
;;;1752   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1753   {
;;;1754     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1757     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1758     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1759     /* Reset the OC4CE Bit */
;;;1760     tmpccmr2 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1761     /* Enable or Disable the Output Compare Clear Bit */
;;;1762     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1763     /* Write to TIMx CCMR2 register */
;;;1764     TIMx->CCMR2 = tmpccmr2;
000014  8381              STRH     r1,[r0,#0x1c]
;;;1765   }
000016  4770              BX       lr
;;;1766   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;787      */
;;;788    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;789    {
;;;790      /* Check the parameters */
;;;791      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;792      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;793      
;;;794      if (NewState != DISABLE)
;;;795      {
;;;796        /* Enable the TIM Counter */
;;;797        TIMx->CR1 |= CR1_CEN_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;798      }
;;;799      else
;;;800      {
;;;801        /* Disable the TIM Counter */
;;;802        TIMx->CR1 &= CR1_CEN_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fe          MOV      r3,#0x3fe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;803      }
;;;804    }
000016  4770              BX       lr
;;;805    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1173     */
;;;1174   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;1175   {
;;;1176     uint16_t tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;1177     /* Check the parameters */
;;;1178     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1179     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1180     tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;1181     /* Reset the CMS and DIR Bits */
;;;1182     tmpcr1 &= CR1_CounterMode_Mask;
000006  f240338f          MOV      r3,#0x38f
00000a  4019              ANDS     r1,r1,r3
;;;1183     /* Set the Counter Mode */
;;;1184     tmpcr1 |= TIM_CounterMode;
00000c  4311              ORRS     r1,r1,r2
;;;1185     /* Write to TIMx CR1 register */
;;;1186     TIMx->CR1 = tmpcr1;
00000e  8001              STRH     r1,[r0,#0]
;;;1187   }
000010  4770              BX       lr
;;;1188   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;812      */
;;;813    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;814    {
;;;815      /* Check the parameters */
;;;816      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;817      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;818      if (NewState != DISABLE)
;;;819      {
;;;820        /* Enable the TIM Main Output */
;;;821        TIMx->BDTR |= BDTR_MOE_Set;
000002  f8b02044          LDRH     r2,[r0,#0x44]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02044          STRH     r2,[r0,#0x44]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;822      }
;;;823      else
;;;824      {
;;;825        /* Disable the TIM Main Output */
;;;826        TIMx->BDTR &= BDTR_MOE_Reset;
000010  f8b02044          LDRH     r2,[r0,#0x44]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02044          STRH     r2,[r0,#0x44]
                  |L19.28|
;;;827      }  
;;;828    }
00001c  4770              BX       lr
;;;829    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;939      */
;;;940    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;941    { 
;;;942      /* Check the parameters */
;;;943      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;944      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;945      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;946      
;;;947      if (NewState != DISABLE)
;;;948      {
;;;949        /* Enable the DMA sources */
;;;950        TIMx->DIER |= TIM_DMASource; 
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L20.16|
                  |L20.10|
;;;951      }
;;;952      else
;;;953      {
;;;954        /* Disable the DMA sources */
;;;955        TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L20.16|
;;;956      }
;;;957    }
000010  4770              BX       lr
;;;958    
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;913      */
;;;914    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;915    {
;;;916      /* Check the parameters */
;;;917      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;918      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;919      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;920      /* Set the DMA Base and the DMA Burst Length */
;;;921      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;922    }
000008  4770              BX       lr
;;;923    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;186      */
;;;187    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;188    {
000002  4604              MOV      r4,r0
;;;189      /* Check the parameters */
;;;190      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;191     
;;;192      if (TIMx == TIM1)
000004  482f              LDR      r0,|L22.196|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L22.28|
;;;193      {
;;;194        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  14c0              ASRS     r0,r0,#19
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;195        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  14e0              ASRS     r0,r4,#19
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e052              B        |L22.194|
                  |L22.28|
;;;196      }     
;;;197      else if (TIMx == TIM2)
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L22.52|
;;;198      {
;;;199        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;200        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e046              B        |L22.194|
                  |L22.52|
;;;201      }
;;;202      else if (TIMx == TIM3)
000034  4824              LDR      r0,|L22.200|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L22.76|
;;;203      {
;;;204        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;205        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e03a              B        |L22.194|
                  |L22.76|
;;;206      }
;;;207      else if (TIMx == TIM4)
00004c  481f              LDR      r0,|L22.204|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L22.100|
;;;208      {
;;;209        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;210        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e02e              B        |L22.194|
                  |L22.100|
;;;211      } 
;;;212      else if (TIMx == TIM5)
000064  481a              LDR      r0,|L22.208|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L22.124|
;;;213      {
;;;214        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;215        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e022              B        |L22.194|
                  |L22.124|
;;;216      } 
;;;217      else if (TIMx == TIM6)
00007c  4815              LDR      r0,|L22.212|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L22.148|
;;;218      {
;;;219        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;220        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e016              B        |L22.194|
                  |L22.148|
;;;221      } 
;;;222      else if (TIMx == TIM7)
000094  4810              LDR      r0,|L22.216|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L22.172|
;;;223      {
;;;224        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;225        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e00a              B        |L22.194|
                  |L22.172|
;;;226      } 
;;;227      else
;;;228      {
;;;229        if (TIMx == TIM8)
0000ac  480b              LDR      r0,|L22.220|
0000ae  4284              CMP      r4,r0
0000b0  d107              BNE      |L22.194|
;;;230        {
;;;231          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  1440              ASRS     r0,r0,#17
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;232          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
0000ba  2100              MOVS     r1,#0
0000bc  1460              ASRS     r0,r4,#17
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L22.194|
;;;233        }  
;;;234      }
;;;235    }
0000c2  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  |L22.196|
                          DCD      0x40012c00
                  |L22.200|
                          DCD      0x40000400
                  |L22.204|
                          DCD      0x40000800
                  |L22.208|
                          DCD      0x40000c00
                  |L22.212|
                          DCD      0x40001000
                  |L22.216|
                          DCD      0x40001400
                  |L22.220|
                          DCD      0x40013400

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1049     */
;;;1050   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1051                                uint16_t ExtTRGFilter)
;;;1052   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1053     uint16_t tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1056     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1057     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1058     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1059     /* Configure the ETR Clock source */
;;;1060     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;1061     
;;;1062     /* Get the TIMx SMCR register value */
;;;1063     tmpsmcr = TIMx->SMCR;
00001a  892c              LDRH     r4,[r5,#8]
;;;1064     /* Reset the SMS Bits */
;;;1065     tmpsmcr &= SMCR_SMS_Mask;
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4004              ANDS     r4,r4,r0
;;;1066     /* Select the External clock mode1 */
;;;1067     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0440407          ORR      r4,r4,#7
;;;1068     /* Select the Trigger selection : ETRF */
;;;1069     tmpsmcr &= SMCR_TS_Mask;
000026  f64f708f          MOV      r0,#0xff8f
00002a  4004              ANDS     r4,r4,r0
;;;1070     tmpsmcr |= TIM_TS_ETRF;
00002c  f0440470          ORR      r4,r4,#0x70
;;;1071     /* Write to TIMx SMCR */
;;;1072     TIMx->SMCR = tmpsmcr;
000030  812c              STRH     r4,[r5,#8]
;;;1073   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1074   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1091     */
;;;1092   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;1093                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1094   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1095     /* Check the parameters */
;;;1096     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1097     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1098     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1099     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1100     /* Configure the ETR Clock source */
;;;1101     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;1102     /* Enable the External clock mode2 */
;;;1103     TIMx->SMCR |= SMCR_ECE_Set;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;1104   }
00001e  bdf0              POP      {r4-r7,pc}
;;;1105   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1122     */
;;;1123   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b530              PUSH     {r4,r5,lr}
;;;1124                      uint16_t ExtTRGFilter)
;;;1125   {
000002  460c              MOV      r4,r1
;;;1126     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1129     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1130     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1131     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1132     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;1133     /* Reset the ETR Bits */
;;;1134     tmpsmcr &= SMCR_ETR_Mask;
000008  b2c9              UXTB     r1,r1
;;;1135     /* Set the Prescaler, the Filter value and the Polarity */
;;;1136     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
00000a  f64f75ff          MOV      r5,#0xffff
00000e  ea052503          AND      r5,r5,r3,LSL #8
000012  4315              ORRS     r5,r5,r2
000014  4325              ORRS     r5,r5,r4
000016  4329              ORRS     r1,r1,r5
;;;1137     /* Write to TIMx SMCR */
;;;1138     TIMx->SMCR = tmpsmcr;
000018  8101              STRH     r1,[r0,#8]
;;;1139   }
00001a  bd30              POP      {r4,r5,pc}
;;;1140   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1238     */
;;;1239   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1240                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1241   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;1242     uint16_t tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;1243     uint16_t tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;1244     uint16_t tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;1245       
;;;1246     /* Check the parameters */
;;;1247     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1248     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1249     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1250     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1251   
;;;1252     /* Get the TIMx SMCR register value */
;;;1253     tmpsmcr = TIMx->SMCR;
00000e  8901              LDRH     r1,[r0,#8]
;;;1254   
;;;1255     /* Get the TIMx CCMR1 register value */
;;;1256     tmpccmr1 = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;1257   
;;;1258     /* Get the TIMx CCER register value */
;;;1259     tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;1260   
;;;1261     /* Set the encoder Mode */
;;;1262     tmpsmcr &= SMCR_SMS_Mask;
000014  f64f77f8          MOV      r7,#0xfff8
000018  4039              ANDS     r1,r1,r7
;;;1263     tmpsmcr |= TIM_EncoderMode;
00001a  4321              ORRS     r1,r1,r4
;;;1264   
;;;1265     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1266     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
00001c  f64f47fc          MOV      r7,#0xfcfc
000020  403a              ANDS     r2,r2,r7
;;;1267     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
000022  f2401701          MOV      r7,#0x101
000026  433a              ORRS     r2,r2,r7
;;;1268   
;;;1269     /* Set the TI1 and the TI2 Polarities */
;;;1270     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000028  f64f77dd          MOV      r7,#0xffdd
00002c  403b              ANDS     r3,r3,r7
;;;1271     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071706          AND      r7,r7,r6,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  433b              ORRS     r3,r3,r7
;;;1272   
;;;1273     /* Write to TIMx SMCR */
;;;1274     TIMx->SMCR = tmpsmcr;
00003a  8101              STRH     r1,[r0,#8]
;;;1275   
;;;1276     /* Write to TIMx CCMR1 */
;;;1277     TIMx->CCMR1 = tmpccmr1;
00003c  8302              STRH     r2,[r0,#0x18]
;;;1278   
;;;1279     /* Write to TIMx CCER */
;;;1280     TIMx->CCER = tmpccer;
00003e  8403              STRH     r3,[r0,#0x20]
;;;1281   }
000040  bdf0              POP      {r4-r7,pc}
;;;1282   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1291     */
;;;1292   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1293   {
;;;1294     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1295     /* Check the parameters */
;;;1296     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1297     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1298     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1299     /* Reset the OC1M Bits */
;;;1300     tmpccmr1 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1301     /* Configure The Forced output Mode */
;;;1302     tmpccmr1 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1303     /* Write to TIMx CCMR1 register */
;;;1304     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1305   }
000010  4770              BX       lr
;;;1306   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1315     */
;;;1316   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1317   {
;;;1318     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1319     /* Check the parameters */
;;;1320     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1321     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1322     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1323     /* Reset the OC2M Bits */
;;;1324     tmpccmr1 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1325     /* Configure The Forced output Mode */
;;;1326     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1327     /* Write to TIMx CCMR1 register */
;;;1328     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1329   }
000018  4770              BX       lr
;;;1330   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1339     */
;;;1340   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1341   {
;;;1342     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1343     /* Check the parameters */
;;;1344     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1345     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1346     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1347     /* Reset the OC1M Bits */
;;;1348     tmpccmr2 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1349     /* Configure The Forced output Mode */
;;;1350     tmpccmr2 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1351     /* Write to TIMx CCMR2 register */
;;;1352     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1353   }
000010  4770              BX       lr
;;;1354   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1363     */
;;;1364   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1365   {
;;;1366     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1367     /* Check the parameters */
;;;1368     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1369     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1370     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1371     /* Reset the OC2M Bits */
;;;1372     tmpccmr2 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1373     /* Configure The Forced output Mode */
;;;1374     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1375     /* Write to TIMx CCMR2 register */
;;;1376     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1377   }
000018  4770              BX       lr
;;;1378   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;886      */
;;;887    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;888    { 
;;;889      /* Check the parameters */
;;;890      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;891      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;892      
;;;893      /* Set the event sources */
;;;894      TIMx->EGR = TIM_EventSource;
;;;895    }
000002  4770              BX       lr
;;;896    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2426     */
;;;2427   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2428   {
;;;2429     /* Check the parameters */
;;;2430     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2431     /* Get the Capture 1 Register value */
;;;2432     return TIMx->CCR1;
000002  8e88              LDRH     r0,[r1,#0x34]
;;;2433   }
000004  4770              BX       lr
;;;2434   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2439     */
;;;2440   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2441   {
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2444     /* Get the Capture 2 Register value */
;;;2445     return TIMx->CCR2;
000002  8f08              LDRH     r0,[r1,#0x38]
;;;2446   }
000004  4770              BX       lr
;;;2447   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2452     */
;;;2453   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2454   {
;;;2455     /* Check the parameters */
;;;2456     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2457     /* Get the Capture 3 Register value */
;;;2458     return TIMx->CCR3;
000002  8f88              LDRH     r0,[r1,#0x3c]
;;;2459   }
000004  4770              BX       lr
;;;2460   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2465     */
;;;2466   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2467   {
;;;2468     /* Check the parameters */
;;;2469     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2470     /* Get the Capture 4 Register value */
;;;2471     return TIMx->CCR4;
000002  f8b10040          LDRH     r0,[r1,#0x40]
;;;2472   }
000006  4770              BX       lr
;;;2473   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2478     */
;;;2479   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2480   {
;;;2481     /* Check the parameters */
;;;2482     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2483     /* Get the Counter Register value */
;;;2484     return TIMx->CNT;
000002  8c88              LDRH     r0,[r1,#0x24]
;;;2485   }
000004  4770              BX       lr
;;;2486   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2521     */
;;;2522   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2523   { 
;;;2524     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2525     /* Check the parameters */
;;;2526     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2527     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2528     
;;;2529     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  420b              TST      r3,r1
000008  d001              BEQ      |L37.14|
;;;2530     {
;;;2531       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2532     }
;;;2533     else
;;;2534     {
;;;2535       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2536     }
;;;2537     return bitstatus;
;;;2538   }
000010  4770              BX       lr
;;;2539   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2589     */
;;;2590   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2591   {
000002  4602              MOV      r2,r0
;;;2592     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2593     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2594     /* Check the parameters */
;;;2595     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2596     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2597      
;;;2598     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2599     
;;;2600     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2601     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2602     {
;;;2603       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2604     }
;;;2605     else
;;;2606     {
;;;2607       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;2608     }
;;;2609     return bitstatus;
;;;2610   }
000020  bd30              POP      {r4,r5,pc}
;;;2611   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2491     */
;;;2492   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2493   {
;;;2494     /* Check the parameters */
;;;2495     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2496     /* Get the Prescaler Register value */
;;;2497     return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;2498   }
000004  4770              BX       lr
;;;2499   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;579      */
;;;580    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;581    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;582      /* Check the parameters */
;;;583      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;584      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;585      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;586      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;587      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;588      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;589      
;;;590      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;591      {
;;;592        /* TI1 Configuration */
;;;593        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  8923              LDRH     r3,[r4,#8]
00000c  88a2              LDRH     r2,[r4,#4]
00000e  8861              LDRH     r1,[r4,#2]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI1_Config
;;;594                   TIM_ICInitStruct->TIM_ICSelection,
;;;595                   TIM_ICInitStruct->TIM_ICFilter);
;;;596        /* Set the Input Capture Prescaler value */
;;;597        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e1              LDRH     r1,[r4,#6]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;598      }
;;;599      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8820              LDRH     r0,[r4,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;600      {
;;;601        /* TI2 Configuration */
;;;602        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI2_Config
;;;603                   TIM_ICInitStruct->TIM_ICSelection,
;;;604                   TIM_ICInitStruct->TIM_ICFilter);
;;;605        /* Set the Input Capture Prescaler value */
;;;606        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;607      }
;;;608      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8820              LDRH     r0,[r4,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;609      {
;;;610        /* TI3 Configuration */
;;;611        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  8923              LDRH     r3,[r4,#8]
000044  88a2              LDRH     r2,[r4,#4]
000046  8861              LDRH     r1,[r4,#2]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TI3_Config
;;;612                   TIM_ICInitStruct->TIM_ICSelection,
;;;613                   TIM_ICInitStruct->TIM_ICFilter);
;;;614        /* Set the Input Capture Prescaler value */
;;;615        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e1              LDRH     r1,[r4,#6]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;616      }
;;;617      else
;;;618      {
;;;619        /* TI4 Configuration */
;;;620        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  8923              LDRH     r3,[r4,#8]
00005a  88a2              LDRH     r2,[r4,#4]
00005c  8861              LDRH     r1,[r4,#2]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TI4_Config
;;;621                   TIM_ICInitStruct->TIM_ICSelection,
;;;622                   TIM_ICInitStruct->TIM_ICFilter);
;;;623        /* Set the Input Capture Prescaler value */
;;;624        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e1              LDRH     r1,[r4,#6]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;625      }
;;;626    }
00006c  bd70              POP      {r4-r6,pc}
;;;627    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;752      */
;;;753    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;754    {
;;;755      /* Set the default configuration */
;;;756      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;757      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;758      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;759      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;760      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;761    }
000010  4770              BX       lr
;;;762    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;849      */
;;;850    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L42.10|
;;;851    {  
;;;852      /* Check the parameters */
;;;853      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;854      assert_param(IS_TIM_IT(TIM_IT));
;;;855      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;856      
;;;857      if (NewState != DISABLE)
;;;858      {
;;;859        /* Enable the Interrupt sources */
;;;860        TIMx->DIER |= TIM_IT;
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L42.16|
                  |L42.10|
;;;861      }
;;;862      else
;;;863      {
;;;864        /* Disable the Interrupt sources */
;;;865        TIMx->DIER &= (uint16_t)~TIM_IT;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L42.16|
;;;866      }
;;;867    }
000010  4770              BX       lr
;;;868    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;982      */
;;;983    void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;984    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;985      /* Check the parameters */
;;;986      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;987      assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;988      /* Select the Internal Trigger */
;;;989      TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;990      /* Select the External clock mode1 */
;;;991      TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;992    }
000016  bd30              POP      {r4,r5,pc}
;;;993    
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;963      */
;;;964    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;965    {
;;;966      /* Check the parameters */
;;;967      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;968      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;969      TIMx->SMCR &=  SMCR_SMS_Mask;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;970    }
00000a  4770              BX       lr
;;;971    
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1579     */
;;;1580   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1581   {
;;;1582     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1583     /* Check the parameters */
;;;1584     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1585     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1586     /* Get the TIMx CCMR1 register value */
;;;1587     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1588     /* Reset the OC1FE Bit */
;;;1589     tmpccmr1 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1590     /* Enable or Disable the Output Compare Fast Bit */
;;;1591     tmpccmr1 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1592     /* Write to TIMx CCMR1 */
;;;1593     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1594   }
000010  4770              BX       lr
;;;1595   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;279      */
;;;280    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;281    {
;;;282      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;283       
;;;284      /* Check the parameters */
;;;285      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;286      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;287      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;288      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;289      /* Disable the Channel 1: Reset the CC1E Bit */
;;;290      TIMx->CCER &= CCER_CC1E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;291      
;;;292      /* Get the TIMx CCER register value */
;;;293      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;294      /* Get the TIMx CR2 register value */
;;;295      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;296      
;;;297      /* Get the TIMx CCMR1 register value */
;;;298      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;299        
;;;300      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;301      tmpccmrx &= CCMR_OC13M_Mask & CCMR_CC13S_Mask;
000018  f64f758c          MOV      r5,#0xff8c
00001c  402c              ANDS     r4,r4,r5
;;;302      
;;;303      /* Select the Output Compare Mode */
;;;304      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;305      
;;;306      /* Reset the Output Polarity level */
;;;307      tmpccer &= CCER_CC1P_Reset;
000022  1e75              SUBS     r5,r6,#1
000024  402a              ANDS     r2,r2,r5
;;;308      /* Set the Output Compare Polarity */
;;;309      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000026  890d              LDRH     r5,[r1,#8]
000028  432a              ORRS     r2,r2,r5
;;;310      
;;;311      /* Set the Output State */
;;;312      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002a  884d              LDRH     r5,[r1,#2]
00002c  432a              ORRS     r2,r2,r5
;;;313     
;;;314      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
00002e  4d10              LDR      r5,|L46.112|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L46.58|
000034  4d0f              LDR      r5,|L46.116|
000036  42a8              CMP      r0,r5
000038  d113              BNE      |L46.98|
                  |L46.58|
;;;315      {
;;;316        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;317        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;318        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;319        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;320        
;;;321        /* Reset the Output N Polarity level */
;;;322        tmpccer &= CCER_CC1NP_Reset;
00003a  f64f75f7          MOV      r5,#0xfff7
00003e  402a              ANDS     r2,r2,r5
;;;323        /* Set the Output N Polarity */
;;;324        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000040  894d              LDRH     r5,[r1,#0xa]
000042  432a              ORRS     r2,r2,r5
;;;325        /* Reset the Output N State */
;;;326        tmpccer &= CCER_CC1NE_Reset;
000044  f64f75fb          MOV      r5,#0xfffb
000048  402a              ANDS     r2,r2,r5
;;;327        
;;;328        /* Set the Output N State */
;;;329        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00004a  888d              LDRH     r5,[r1,#4]
00004c  432a              ORRS     r2,r2,r5
;;;330        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;331        tmpcr2 &= CR2_OIS1_Reset;
00004e  f64765ff          MOV      r5,#0x7eff
000052  402b              ANDS     r3,r3,r5
;;;332        tmpcr2 &= CR2_OIS1N_Reset;
000054  f64755ff          MOV      r5,#0x7dff
000058  402b              ANDS     r3,r3,r5
;;;333        /* Set the Output Idle state */
;;;334        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005a  898d              LDRH     r5,[r1,#0xc]
00005c  432b              ORRS     r3,r3,r5
;;;335        /* Set the Output N Idle state */
;;;336        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00005e  89cd              LDRH     r5,[r1,#0xe]
000060  432b              ORRS     r3,r3,r5
                  |L46.98|
;;;337      }
;;;338      /* Write to TIMx CR2 */
;;;339      TIMx->CR2 = tmpcr2;
000062  8083              STRH     r3,[r0,#4]
;;;340      
;;;341      /* Write to TIMx CCMR1 */
;;;342      TIMx->CCMR1 = tmpccmrx;
000064  8304              STRH     r4,[r0,#0x18]
;;;343    
;;;344      /* Set the Capture Compare Register value */
;;;345      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000066  88cd              LDRH     r5,[r1,#6]
000068  8685              STRH     r5,[r0,#0x34]
;;;346      
;;;347      /* Write to TIMx CCER */
;;;348      TIMx->CCER = tmpccer;
00006a  8402              STRH     r2,[r0,#0x20]
;;;349    }
00006c  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

00006e  0000              DCW      0x0000
                  |L46.112|
                          DCD      0x40012c00
                  |L46.116|
                          DCD      0x40013400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1798     */
;;;1799   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1800   {
;;;1801     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1802     /* Check the parameters */
;;;1803     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1804     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1805      
;;;1806     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1807     /* Set or Reset the CC1NP Bit */
;;;1808     tmpccer &= CCER_CC1NP_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1809     tmpccer |= TIM_OCNPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1810     /* Write to TIMx CCER register */
;;;1811     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1812   }
000010  4770              BX       lr
;;;1813   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1775     */
;;;1776   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1777   {
;;;1778     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1779     /* Check the parameters */
;;;1780     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1781     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1782     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1783     /* Set or Reset the CC1P Bit */
;;;1784     tmpccer &= CCER_CC1P_Reset;
000006  f64f73fd          MOV      r3,#0xfffd
00000a  4019              ANDS     r1,r1,r3
;;;1785     tmpccer |= TIM_OCPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1786     /* Write to TIMx CCER register */
;;;1787     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1788   }
000010  4770              BX       lr
;;;1789   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1483     */
;;;1484   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1485   {
;;;1486     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1487     /* Check the parameters */
;;;1488     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1489     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1490     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1491     /* Reset the OC1PE Bit */
;;;1492     tmpccmr1 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1493     /* Enable or Disable the Output Compare Preload feature */
;;;1494     tmpccmr1 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1495     /* Write to TIMx CCMR1 register */
;;;1496     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1497   }
000010  4770              BX       lr
;;;1498   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1604     */
;;;1605   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1606   {
;;;1607     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1608     /* Check the parameters */
;;;1609     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1610     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1611     /* Get the TIMx CCMR1 register value */
;;;1612     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1613     /* Reset the OC2FE Bit */
;;;1614     tmpccmr1 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1615     /* Enable or Disable the Output Compare Fast Bit */
;;;1616     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1617     /* Write to TIMx CCMR1 */
;;;1618     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1619   }
000018  4770              BX       lr
;;;1620   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;358      */
;;;359    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;360    {
;;;361      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;362       
;;;363      /* Check the parameters */
;;;364      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;365      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;366      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;367      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;368      /* Disable the Channel 2: Reset the CC2E Bit */
;;;369      TIMx->CCER &= CCER_CC2E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;370      
;;;371      /* Get the TIMx CCER register value */  
;;;372      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;373      /* Get the TIMx CR2 register value */
;;;374      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;375      
;;;376      /* Get the TIMx CCMR1 register value */
;;;377      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;378    
;;;379      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;380      tmpccmrx &= CCMR_OC24M_Mask & CCMR_CC24S_Mask;  
000018  f64845ff          MOV      r5,#0x8cff
00001c  402c              ANDS     r4,r4,r5
;;;381      
;;;382      /* Select the Output Compare Mode */
;;;383      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;384      
;;;385      /* Reset the Output Polarity level */
;;;386      tmpccer &= CCER_CC2P_Reset;
00002a  f64f75df          MOV      r5,#0xffdf
00002e  402a              ANDS     r2,r2,r5
;;;387      /* Set the Output Compare Polarity */
;;;388      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000030  890d              LDRH     r5,[r1,#8]
000032  ea061505          AND      r5,r6,r5,LSL #4
000036  432a              ORRS     r2,r2,r5
;;;389      
;;;390      /* Set the Output State */
;;;391      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea061505          AND      r5,r6,r5,LSL #4
00003e  432a              ORRS     r2,r2,r5
;;;392        
;;;393      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
000040  4d14              LDR      r5,|L51.148|
000042  42a8              CMP      r0,r5
000044  d002              BEQ      |L51.76|
000046  4d14              LDR      r5,|L51.152|
000048  42a8              CMP      r0,r5
00004a  d11d              BNE      |L51.136|
                  |L51.76|
;;;394      {
;;;395        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;396        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;397        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;398        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;399        
;;;400        /* Reset the Output N Polarity level */
;;;401        tmpccer &= CCER_CC2NP_Reset;
00004c  f64f757f          MOV      r5,#0xff7f
000050  402a              ANDS     r2,r2,r5
;;;402        /* Set the Output N Polarity */
;;;403        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000052  894d              LDRH     r5,[r1,#0xa]
000054  f64f76ff          MOV      r6,#0xffff
000058  ea061505          AND      r5,r6,r5,LSL #4
00005c  432a              ORRS     r2,r2,r5
;;;404        /* Reset the Output N State */
;;;405        tmpccer &= CCER_CC2NE_Reset;
00005e  f64f75bf          MOV      r5,#0xffbf
000062  402a              ANDS     r2,r2,r5
;;;406        
;;;407        /* Set the Output N State */
;;;408        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000064  888d              LDRH     r5,[r1,#4]
000066  ea061505          AND      r5,r6,r5,LSL #4
00006a  432a              ORRS     r2,r2,r5
;;;409        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;410        tmpcr2 &= CR2_OIS2_Reset;
00006c  f64735ff          MOV      r5,#0x7bff
000070  402b              ANDS     r3,r3,r5
;;;411        tmpcr2 &= CR2_OIS2N_Reset;
000072  f24775ff          MOV      r5,#0x77ff
000076  402b              ANDS     r3,r3,r5
;;;412        /* Set the Output Idle state */
;;;413        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000078  898d              LDRH     r5,[r1,#0xc]
00007a  ea060585          AND      r5,r6,r5,LSL #2
00007e  432b              ORRS     r3,r3,r5
;;;414        /* Set the Output N Idle state */
;;;415        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000080  89cd              LDRH     r5,[r1,#0xe]
000082  ea060585          AND      r5,r6,r5,LSL #2
000086  432b              ORRS     r3,r3,r5
                  |L51.136|
;;;416      }
;;;417      /* Write to TIMx CR2 */
;;;418      TIMx->CR2 = tmpcr2;
000088  8083              STRH     r3,[r0,#4]
;;;419      
;;;420      /* Write to TIMx CCMR1 */
;;;421      TIMx->CCMR1 = tmpccmrx;
00008a  8304              STRH     r4,[r0,#0x18]
;;;422    
;;;423      /* Set the Capture Compare Register value */
;;;424      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
00008c  88cd              LDRH     r5,[r1,#6]
00008e  8705              STRH     r5,[r0,#0x38]
;;;425      
;;;426      /* Write to TIMx CCER */
;;;427      TIMx->CCER = tmpccer;
000090  8402              STRH     r2,[r0,#0x20]
;;;428    }
000092  bd70              POP      {r4-r6,pc}
;;;429    
                          ENDP

                  |L51.148|
                          DCD      0x40012c00
                  |L51.152|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1845     */
;;;1846   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1847   {
;;;1848     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1849     /* Check the parameters */
;;;1850     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1851     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1852     
;;;1853     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1854     /* Set or Reset the CC2NP Bit */
;;;1855     tmpccer &= CCER_CC2NP_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1856     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1857     /* Write to TIMx CCER register */
;;;1858     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1859   }
000018  4770              BX       lr
;;;1860   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1822     */
;;;1823   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1824   {
;;;1825     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1826     /* Check the parameters */
;;;1827     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1828     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1829     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1830     /* Set or Reset the CC2P Bit */
;;;1831     tmpccer &= CCER_CC2P_Reset;
000006  f64f73df          MOV      r3,#0xffdf
00000a  4019              ANDS     r1,r1,r3
;;;1832     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1833     /* Write to TIMx CCER register */
;;;1834     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1835   }
000018  4770              BX       lr
;;;1836   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1507     */
;;;1508   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1509   {
;;;1510     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1511     /* Check the parameters */
;;;1512     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1513     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1514     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1515     /* Reset the OC2PE Bit */
;;;1516     tmpccmr1 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1517     /* Enable or Disable the Output Compare Preload feature */
;;;1518     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1519     /* Write to TIMx CCMR1 register */
;;;1520     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1521   }
000018  4770              BX       lr
;;;1522   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1629     */
;;;1630   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1631   {
;;;1632     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1635     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1636     /* Get the TIMx CCMR2 register value */
;;;1637     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1638     /* Reset the OC3FE Bit */
;;;1639     tmpccmr2 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1640     /* Enable or Disable the Output Compare Fast Bit */
;;;1641     tmpccmr2 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1642     /* Write to TIMx CCMR2 */
;;;1643     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1644   }
000010  4770              BX       lr
;;;1645   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;437      */
;;;438    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;439    {
;;;440      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;441       
;;;442      /* Check the parameters */
;;;443      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;444      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;445      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;446      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;447      /* Disable the Channel 2: Reset the CC2E Bit */
;;;448      TIMx->CCER &= CCER_CC3E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;449      
;;;450      /* Get the TIMx CCER register value */
;;;451      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;452      /* Get the TIMx CR2 register value */
;;;453      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;454      
;;;455      /* Get the TIMx CCMR2 register value */
;;;456      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;457        
;;;458      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;459      tmpccmrx &= CCMR_OC13M_Mask & CCMR_CC13S_Mask;  
000018  f64f758c          MOV      r5,#0xff8c
00001c  402c              ANDS     r4,r4,r5
;;;460      
;;;461      /* Select the Output Compare Mode */
;;;462      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;463      
;;;464      /* Reset the Output Polarity level */
;;;465      tmpccer &= CCER_CC3P_Reset;
000022  f64f55ff          MOV      r5,#0xfdff
000026  402a              ANDS     r2,r2,r5
;;;466      /* Set the Output Compare Polarity */
;;;467      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000028  890d              LDRH     r5,[r1,#8]
00002a  f64f76ff          MOV      r6,#0xffff
00002e  ea062505          AND      r5,r6,r5,LSL #8
000032  432a              ORRS     r2,r2,r5
;;;468      
;;;469      /* Set the Output State */
;;;470      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000034  884d              LDRH     r5,[r1,#2]
000036  ea062505          AND      r5,r6,r5,LSL #8
00003a  432a              ORRS     r2,r2,r5
;;;471       
;;;472      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
00003c  4d14              LDR      r5,|L56.144|
00003e  42a8              CMP      r0,r5
000040  d002              BEQ      |L56.72|
000042  4d14              LDR      r5,|L56.148|
000044  42a8              CMP      r0,r5
000046  d11d              BNE      |L56.132|
                  |L56.72|
;;;473      {
;;;474        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;475        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;476        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;477        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;478        
;;;479        /* Reset the Output N Polarity level */
;;;480        tmpccer &= CCER_CC3NP_Reset;
000048  f24f75ff          MOV      r5,#0xf7ff
00004c  402a              ANDS     r2,r2,r5
;;;481        /* Set the Output N Polarity */
;;;482        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00004e  894d              LDRH     r5,[r1,#0xa]
000050  f64f76ff          MOV      r6,#0xffff
000054  ea062505          AND      r5,r6,r5,LSL #8
000058  432a              ORRS     r2,r2,r5
;;;483        /* Reset the Output N State */
;;;484        tmpccer &= CCER_CC3NE_Reset;
00005a  f64f35ff          MOV      r5,#0xfbff
00005e  402a              ANDS     r2,r2,r5
;;;485        
;;;486        /* Set the Output N State */
;;;487        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000060  888d              LDRH     r5,[r1,#4]
000062  ea062505          AND      r5,r6,r5,LSL #8
000066  432a              ORRS     r2,r2,r5
;;;488        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;489        tmpcr2 &= CR2_OIS3_Reset;
000068  f64675ff          MOV      r5,#0x6fff
00006c  402b              ANDS     r3,r3,r5
;;;490        tmpcr2 &= CR2_OIS3N_Reset;
00006e  f64575ff          MOV      r5,#0x5fff
000072  402b              ANDS     r3,r3,r5
;;;491        /* Set the Output Idle state */
;;;492        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000074  898d              LDRH     r5,[r1,#0xc]
000076  ea061505          AND      r5,r6,r5,LSL #4
00007a  432b              ORRS     r3,r3,r5
;;;493        /* Set the Output N Idle state */
;;;494        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
00007c  89cd              LDRH     r5,[r1,#0xe]
00007e  ea061505          AND      r5,r6,r5,LSL #4
000082  432b              ORRS     r3,r3,r5
                  |L56.132|
;;;495      }
;;;496      /* Write to TIMx CR2 */
;;;497      TIMx->CR2 = tmpcr2;
000084  8083              STRH     r3,[r0,#4]
;;;498      
;;;499      /* Write to TIMx CCMR2 */
;;;500      TIMx->CCMR2 = tmpccmrx;
000086  8384              STRH     r4,[r0,#0x1c]
;;;501    
;;;502      /* Set the Capture Compare Register value */
;;;503      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000088  88cd              LDRH     r5,[r1,#6]
00008a  8785              STRH     r5,[r0,#0x3c]
;;;504      
;;;505      /* Write to TIMx CCER */
;;;506      TIMx->CCER = tmpccer;
00008c  8402              STRH     r2,[r0,#0x20]
;;;507    }
00008e  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

                  |L56.144|
                          DCD      0x40012c00
                  |L56.148|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1892     */
;;;1893   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1894   {
;;;1895     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1896    
;;;1897     /* Check the parameters */
;;;1898     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1899     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1900       
;;;1901     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1902     /* Set or Reset the CC3NP Bit */
;;;1903     tmpccer &= CCER_CC3NP_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1904     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1905     /* Write to TIMx CCER register */
;;;1906     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1907   }
000018  4770              BX       lr
;;;1908   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1869     */
;;;1870   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1871   {
;;;1872     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1873     /* Check the parameters */
;;;1874     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1875     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1876     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1877     /* Set or Reset the CC3P Bit */
;;;1878     tmpccer &= CCER_CC3P_Reset;
000006  f64f53ff          MOV      r3,#0xfdff
00000a  4019              ANDS     r1,r1,r3
;;;1879     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1880     /* Write to TIMx CCER register */
;;;1881     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1882   }
000018  4770              BX       lr
;;;1883   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1531     */
;;;1532   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1533   {
;;;1534     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1535     /* Check the parameters */
;;;1536     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1537     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1538     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1539     /* Reset the OC3PE Bit */
;;;1540     tmpccmr2 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1541     /* Enable or Disable the Output Compare Preload feature */
;;;1542     tmpccmr2 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1543     /* Write to TIMx CCMR2 register */
;;;1544     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1545   }
000010  4770              BX       lr
;;;1546   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1654     */
;;;1655   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1656   {
;;;1657     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1660     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1661     /* Get the TIMx CCMR2 register value */
;;;1662     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1663     /* Reset the OC4FE Bit */
;;;1664     tmpccmr2 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1665     /* Enable or Disable the Output Compare Fast Bit */
;;;1666     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1667     /* Write to TIMx CCMR2 */
;;;1668     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1669   }
000018  4770              BX       lr
;;;1670   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;516      */
;;;517    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;518    {
;;;519      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;520       
;;;521      /* Check the parameters */
;;;522      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;523      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;524      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;525      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;526      /* Disable the Channel 2: Reset the CC4E Bit */
;;;527      TIMx->CCER &= CCER_CC4E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;528      
;;;529      /* Get the TIMx CCER register value */
;;;530      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;531      /* Get the TIMx CR2 register value */
;;;532      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;533      
;;;534      /* Get the TIMx CCMR2 register value */
;;;535      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;536        
;;;537      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;538      tmpccmrx &= CCMR_OC24M_Mask & CCMR_CC24S_Mask; 
000018  f64845ff          MOV      r5,#0x8cff
00001c  402c              ANDS     r4,r4,r5
;;;539       
;;;540      /* Select the Output Compare Mode */
;;;541      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;542      
;;;543      /* Reset the Output Polarity level */
;;;544      tmpccer &= CCER_CC4P_Reset;
00002a  f64d75ff          MOV      r5,#0xdfff
00002e  402a              ANDS     r2,r2,r5
;;;545      /* Set the Output Compare Polarity */
;;;546      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000030  890d              LDRH     r5,[r1,#8]
000032  ea063505          AND      r5,r6,r5,LSL #12
000036  432a              ORRS     r2,r2,r5
;;;547      
;;;548      /* Set the Output State */
;;;549      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea063505          AND      r5,r6,r5,LSL #12
00003e  432a              ORRS     r2,r2,r5
;;;550        
;;;551      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
000040  4d0a              LDR      r5,|L61.108|
000042  42a8              CMP      r0,r5
000044  d002              BEQ      |L61.76|
000046  4d0a              LDR      r5,|L61.112|
000048  42a8              CMP      r0,r5
00004a  d107              BNE      |L61.92|
                  |L61.76|
;;;552      {
;;;553        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;554        /* Reset the Ouput Compare IDLE State */
;;;555        tmpcr2 &= CR2_OIS4_Reset;
00004c  f3c3030d          UBFX     r3,r3,#0,#14
;;;556        /* Set the Output Idle state */
;;;557        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000050  898d              LDRH     r5,[r1,#0xc]
000052  f64f76ff          MOV      r6,#0xffff
000056  ea061585          AND      r5,r6,r5,LSL #6
00005a  432b              ORRS     r3,r3,r5
                  |L61.92|
;;;558      }
;;;559      /* Write to TIMx CR2 */
;;;560      TIMx->CR2 = tmpcr2;
00005c  8083              STRH     r3,[r0,#4]
;;;561      
;;;562      /* Write to TIMx CCMR2 */  
;;;563      TIMx->CCMR2 = tmpccmrx;
00005e  8384              STRH     r4,[r0,#0x1c]
;;;564    
;;;565      /* Set the Capture Compare Register value */
;;;566      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000060  88cd              LDRH     r5,[r1,#6]
000062  f8a05040          STRH     r5,[r0,#0x40]
;;;567      
;;;568      /* Write to TIMx CCER */
;;;569      TIMx->CCER = tmpccer;
000066  8402              STRH     r2,[r0,#0x20]
;;;570    }
000068  bd70              POP      {r4-r6,pc}
;;;571    
                          ENDP

00006a  0000              DCW      0x0000
                  |L61.108|
                          DCD      0x40012c00
                  |L61.112|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1917     */
;;;1918   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1919   {
;;;1920     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1921     /* Check the parameters */
;;;1922     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1923     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1924     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1925     /* Set or Reset the CC4P Bit */
;;;1926     tmpccer &= CCER_CC4P_Reset;
000006  f64d73ff          MOV      r3,#0xdfff
00000a  4019              ANDS     r1,r1,r3
;;;1927     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea033302          AND      r3,r3,r2,LSL #12
000014  4319              ORRS     r1,r1,r3
;;;1928     /* Write to TIMx CCER register */
;;;1929     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1930   }
000018  4770              BX       lr
;;;1931   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1555     */
;;;1556   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1559     /* Check the parameters */
;;;1560     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1561     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1562     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1563     /* Reset the OC4PE Bit */
;;;1564     tmpccmr2 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1565     /* Enable or Disable the Output Compare Preload feature */
;;;1566     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1567     /* Write to TIMx CCMR2 register */
;;;1568     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1569   }
000018  4770              BX       lr
;;;1570   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;733      */
;;;734    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;735    {
;;;736      /* Set the default configuration */
;;;737      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;738      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;739      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;740      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;741      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;742      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;743      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;744      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;745    }
000012  4770              BX       lr
;;;746    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;635      */
;;;636    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;637    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;638      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;639      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;640      /* Check the parameters */
;;;641      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;642      /* Select the Opposite Input Polarity */
;;;643      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;644      {
;;;645        icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;646      }
;;;647      else
;;;648      {
;;;649        icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;650      }
;;;651      /* Select the Opposite Input */
;;;652      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;653      {
;;;654        icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;655      }
;;;656      else
;;;657      {
;;;658        icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;659      }
;;;660      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;661      {
;;;662        /* TI1 Configuration */
;;;663        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;664                   TIM_ICInitStruct->TIM_ICFilter);
;;;665        /* Set the Input Capture Prescaler value */
;;;666        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;667        /* TI2 Configuration */
;;;668        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;669        /* Set the Input Capture Prescaler value */
;;;670        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;671      }
;;;672      else
;;;673      { 
;;;674        /* TI2 Configuration */
;;;675        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;676                   TIM_ICInitStruct->TIM_ICFilter);
;;;677        /* Set the Input Capture Prescaler value */
;;;678        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;679        /* TI1 Configuration */
;;;680        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;681        /* Set the Input Capture Prescaler value */
;;;682        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;683      }
;;;684    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;685    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1150     */
;;;1151   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1152   {
;;;1153     /* Check the parameters */
;;;1154     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1155     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1156     /* Set the Prescaler value */
;;;1157     TIMx->PSC = Prescaler;
;;;1158     /* Set or reset the UG Bit */
;;;1159     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1160   }
000004  4770              BX       lr
;;;1161   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1433     */
;;;1434   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L67.12|
;;;1435   {
;;;1436     /* Check the parameters */
;;;1437     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1438     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1439     if (NewState != DISABLE)
;;;1440     {
;;;1441       /* Set the CCDS Bit */
;;;1442       TIMx->CR2 |= CR2_CCDS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L67.22|
                  |L67.12|
;;;1443     }
;;;1444     else
;;;1445     {
;;;1446       /* Reset the CCDS Bit */
;;;1447       TIMx->CR2 &= CR2_CCDS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L67.22|
;;;1448     }
;;;1449   }
000016  4770              BX       lr
;;;1450   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1409     */
;;;1410   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;1411   {
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1414     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1415     if (NewState != DISABLE)
;;;1416     {
;;;1417       /* Set the COM Bit */
;;;1418       TIMx->CR2 |= CR2_CCUS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;1419     }
;;;1420     else
;;;1421     {
;;;1422       /* Reset the COM Bit */
;;;1423       TIMx->CR2 &= CR2_CCUS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;1424     }
;;;1425   }
000016  4770              BX       lr
;;;1426   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2114     */
;;;2115   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2116   {
;;;2117     /* Check the parameters */
;;;2118     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2119     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2120     if (NewState != DISABLE)
;;;2121     {
;;;2122       /* Set the TI1S Bit */
;;;2123       TIMx->CR2 |= CR2_TI1S_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2124     }
;;;2125     else
;;;2126     {
;;;2127       /* Reset the TI1S Bit */
;;;2128       TIMx->CR2 &= CR2_TI1S_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2129     }
;;;2130   }
000016  4770              BX       lr
;;;2131   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1203     */
;;;1204   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;1205   {
;;;1206     uint16_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;1207     /* Check the parameters */
;;;1208     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1209     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1210     /* Get the TIMx SMCR register value */
;;;1211     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;1212     /* Reset the TS Bits */
;;;1213     tmpsmcr &= SMCR_TS_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1214     /* Set the Input Trigger source */
;;;1215     tmpsmcr |= TIM_InputTriggerSource;
00000c  4311              ORRS     r1,r1,r2
;;;1216     /* Write to TIMx SMCR */
;;;1217     TIMx->SMCR = tmpsmcr;
00000e  8101              STRH     r1,[r0,#8]
;;;1218   }
000010  4770              BX       lr
;;;1219   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2216     */
;;;2217   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2218   {
;;;2219     /* Check the parameters */
;;;2220     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2221     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2222     /* Reset the MSM Bit */
;;;2223     TIMx->SMCR &= SMCR_MSM_Reset;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2224     
;;;2225     /* Set or Reset the MSM Bit */
;;;2226     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2227   }
000010  4770              BX       lr
;;;2228   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2015     */
;;;2016   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2017   {
000002  4603              MOV      r3,r0
;;;2018     uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;2019     uint16_t tmp1 = 0;
000006  2400              MOVS     r4,#0
;;;2020   
;;;2021     /* Check the parameters */
;;;2022     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2023     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2024     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2025   
;;;2026     tmp = (uint32_t) TIMx;
000008  4618              MOV      r0,r3
;;;2027     tmp += CCMR_Offset;
00000a  3018              ADDS     r0,r0,#0x18
;;;2028   
;;;2029     tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
00000c  2501              MOVS     r5,#1
00000e  408d              LSLS     r5,r5,r1
000010  b2ac              UXTH     r4,r5
;;;2030   
;;;2031     /* Disable the Channel: Reset the CCxE Bit */
;;;2032     TIMx->CCER &= (uint16_t) ~tmp1;
000012  8c1d              LDRH     r5,[r3,#0x20]
000014  43a5              BICS     r5,r5,r4
000016  841d              STRH     r5,[r3,#0x20]
;;;2033   
;;;2034     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000018  b109              CBZ      r1,|L72.30|
00001a  2908              CMP      r1,#8
00001c  d10a              BNE      |L72.52|
                  |L72.30|
;;;2035     {
;;;2036       tmp += (TIM_Channel>>1);
00001e  eb000061          ADD      r0,r0,r1,ASR #1
;;;2037   
;;;2038       /* Reset the OCxM bits in the CCMRx register */
;;;2039       *(__IO uint32_t *) tmp &= CCMR_OC13M_Mask;
000022  6805              LDR      r5,[r0,#0]
000024  f64f768f          MOV      r6,#0xff8f
000028  4035              ANDS     r5,r5,r6
00002a  6005              STR      r5,[r0,#0]
;;;2040      
;;;2041       /* Configure the OCxM bits in the CCMRx register */
;;;2042       *(__IO uint32_t *) tmp |= TIM_OCMode;
00002c  6805              LDR      r5,[r0,#0]
00002e  4315              ORRS     r5,r5,r2
000030  6005              STR      r5,[r0,#0]
000032  e00f              B        |L72.84|
                  |L72.52|
;;;2043     }
;;;2044     else
;;;2045     {
;;;2046       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000034  1f0d              SUBS     r5,r1,#4
000036  f3c5054e          UBFX     r5,r5,#1,#15
00003a  4428              ADD      r0,r0,r5
;;;2047   
;;;2048       /* Reset the OCxM bits in the CCMRx register */
;;;2049       *(__IO uint32_t *) tmp &= CCMR_OC24M_Mask;
00003c  6805              LDR      r5,[r0,#0]
00003e  f64876ff          MOV      r6,#0x8fff
000042  4035              ANDS     r5,r5,r6
000044  6005              STR      r5,[r0,#0]
;;;2050       
;;;2051       /* Configure the OCxM bits in the CCMRx register */
;;;2052       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000046  6805              LDR      r5,[r0,#0]
000048  f64f76ff          MOV      r6,#0xffff
00004c  ea062602          AND      r6,r6,r2,LSL #8
000050  4335              ORRS     r5,r5,r6
000052  6005              STR      r5,[r0,#0]
                  |L72.84|
;;;2053     }
;;;2054   }
000054  bd70              POP      {r4-r6,pc}
;;;2055   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2140     */
;;;2141   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2142   {
;;;2143     /* Check the parameters */
;;;2144     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2145     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2146     /* Reset the OPM Bit */
;;;2147     TIMx->CR1 &= CR1_OPM_Reset;
000002  f24033f7          MOV      r3,#0x3f7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;2148     /* Configure the OPM Mode */
;;;2149     TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2150   }
000010  4770              BX       lr
;;;2151   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2172     */
;;;2173   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2174   {
;;;2175     /* Check the parameters */
;;;2176     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2177     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2178     /* Reset the MMS Bits */
;;;2179     TIMx->CR2 &= CR2_MMS_Mask;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2180     /* Select the TRGO source */
;;;2181     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2182   }
000010  4770              BX       lr
;;;2183   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2195     */
;;;2196   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2197   {
;;;2198     /* Check the parameters */
;;;2199     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2200     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2201     /* Reset the SMS Bits */
;;;2202     TIMx->SMCR &= SMCR_SMS_Mask;
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2203     /* Select the Slave Mode */
;;;2204     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2205   }
000010  4770              BX       lr
;;;2206   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2248     */
;;;2249   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2250   {
;;;2251     /* Check the parameters */
;;;2252     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2253     /* Set the Autoreload Register value */
;;;2254     TIMx->ARR = Autoreload;
;;;2255   }
000002  4770              BX       lr
;;;2256   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2410     */
;;;2411   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2412   {
;;;2413     /* Check the parameters */
;;;2414     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2415     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2416     /* Reset the CKD Bits */
;;;2417     TIMx->CR1 &= CR1_CKD_Mask;
000002  b2d2              UXTB     r2,r2
000004  8002              STRH     r2,[r0,#0]
;;;2418     /* Set the CKD value */
;;;2419     TIMx->CR1 |= TIM_CKD;
000006  8802              LDRH     r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  8002              STRH     r2,[r0,#0]
;;;2420   }
00000c  4770              BX       lr
;;;2421   
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2262     */
;;;2263   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2264   {
;;;2265     /* Check the parameters */
;;;2266     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2267     /* Set the Capture Compare1 Register value */
;;;2268     TIMx->CCR1 = Compare1;
;;;2269   }
000002  4770              BX       lr
;;;2270   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2276     */
;;;2277   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2278   {
;;;2279     /* Check the parameters */
;;;2280     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2281     /* Set the Capture Compare2 Register value */
;;;2282     TIMx->CCR2 = Compare2;
;;;2283   }
000002  4770              BX       lr
;;;2284   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2290     */
;;;2291   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2292   {
;;;2293     /* Check the parameters */
;;;2294     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2295     /* Set the Capture Compare3 Register value */
;;;2296     TIMx->CCR3 = Compare3;
;;;2297   }
000002  4770              BX       lr
;;;2298   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2304     */
;;;2305   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2306   {
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2309     /* Set the Capture Compare4 Register value */
;;;2310     TIMx->CCR4 = Compare4;
;;;2311   }
000004  4770              BX       lr
;;;2312   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2234     */
;;;2235   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2236   {
;;;2237     /* Check the parameters */
;;;2238     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2239     /* Set the Counter Register value */
;;;2240     TIMx->CNT = Counter;
;;;2241   }
000002  4770              BX       lr
;;;2242   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2323     */
;;;2324   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2325   {
;;;2326     /* Check the parameters */
;;;2327     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2328     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2329     /* Reset the IC1PSC Bits */
;;;2330     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2331     /* Set the IC1PSC value */
;;;2332     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2333   }
000010  4770              BX       lr
;;;2334   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2345     */
;;;2346   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2347   {
;;;2348     /* Check the parameters */
;;;2349     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2350     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2351     /* Reset the IC2PSC Bits */
;;;2352     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2353     /* Set the IC2PSC value */
;;;2354     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8302              STRH     r2,[r0,#0x18]
;;;2355   }
000018  4770              BX       lr
;;;2356   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2367     */
;;;2368   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2369   {
;;;2370     /* Check the parameters */
;;;2371     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2372     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2373     /* Reset the IC3PSC Bits */
;;;2374     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2375     /* Set the IC3PSC value */
;;;2376     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2377   }
000010  4770              BX       lr
;;;2378   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2389     */
;;;2390   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2391   {  
;;;2392     /* Check the parameters */
;;;2393     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2394     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2395     /* Reset the IC4PSC Bits */
;;;2396     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2397     /* Set the IC4PSC value */
;;;2398     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8382              STRH     r2,[r0,#0x1c]
;;;2399   }
000018  4770              BX       lr
;;;2400   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1009     */
;;;1010   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1011                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1012   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1013     /* Check the parameters */
;;;1014     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1015     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1016     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1017     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1018     /* Configure the Timer Input Clock Source */
;;;1019     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L87.30|
;;;1020     {
;;;1021       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L87.42|
                  |L87.30|
;;;1022     }
;;;1023     else
;;;1024     {
;;;1025       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L87.42|
;;;1026     }
;;;1027     /* Select the Trigger source */
;;;1028     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;1029     /* Select the External clock mode1 */
;;;1030     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;1031   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1032   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;244      */
;;;245    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  8802              LDRH     r2,[r0,#0]
;;;246    {
;;;247      /* Check the parameters */
;;;248      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;249      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;250      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;251      /* Select the Counter Mode and set the clock division */
;;;252      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
000002  f002028f          AND      r2,r2,#0x8f
000006  8002              STRH     r2,[r0,#0]
;;;253      TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
000008  88ca              LDRH     r2,[r1,#6]
00000a  884b              LDRH     r3,[r1,#2]
00000c  431a              ORRS     r2,r2,r3
00000e  8803              LDRH     r3,[r0,#0]
000010  431a              ORRS     r2,r2,r3
000012  8002              STRH     r2,[r0,#0]
;;;254                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;255      
;;;256      /* Set the Autoreload value */
;;;257      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000014  888a              LDRH     r2,[r1,#4]
000016  8582              STRH     r2,[r0,#0x2c]
;;;258     
;;;259      /* Set the Prescaler value */
;;;260      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000018  880a              LDRH     r2,[r1,#0]
00001a  8502              STRH     r2,[r0,#0x28]
;;;261        
;;;262      if ((((uint32_t) TIMx) == TIM1_BASE) || (((uint32_t) TIMx) == TIM8_BASE))  
00001c  4a05              LDR      r2,|L88.52|
00001e  4290              CMP      r0,r2
000020  d002              BEQ      |L88.40|
000022  4a05              LDR      r2,|L88.56|
000024  4290              CMP      r0,r2
000026  d101              BNE      |L88.44|
                  |L88.40|
;;;263      {
;;;264        /* Set the Repetition Counter value */
;;;265        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000028  7a0a              LDRB     r2,[r1,#8]
00002a  8602              STRH     r2,[r0,#0x30]
                  |L88.44|
;;;266      }
;;;267    
;;;268      /* Generate an update event to reload the Prescaler value immediatly */
;;;269      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
00002c  2201              MOVS     r2,#1
00002e  8282              STRH     r2,[r0,#0x14]
;;;270    }
000030  4770              BX       lr
;;;271    
                          ENDP

000032  0000              DCW      0x0000
                  |L88.52|
                          DCD      0x40012c00
                  |L88.56|
                          DCD      0x40013400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;717      */
;;;718    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;719    {
;;;720      /* Set the default configuration */
;;;721      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;722      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;723      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;724      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;725      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;726    }
000010  4770              BX       lr
;;;727    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2062     */
;;;2063   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L90.12|
;;;2064   {
;;;2065     /* Check the parameters */
;;;2066     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2067     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2068     if (NewState != DISABLE)
;;;2069     {
;;;2070       /* Set the Update Disable Bit */
;;;2071       TIMx->CR1 |= CR1_UDIS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L90.22|
                  |L90.12|
;;;2072     }
;;;2073     else
;;;2074     {
;;;2075       /* Reset the Update Disable Bit */
;;;2076       TIMx->CR1 &= CR1_UDIS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fd          MOV      r3,#0x3fd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L90.22|
;;;2077     }
;;;2078   }
000016  4770              BX       lr
;;;2079   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2090     */
;;;2091   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  b121              CBZ      r1,|L91.12|
;;;2092   {
;;;2093     /* Check the parameters */
;;;2094     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2095     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2096     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2097     {
;;;2098       /* Set the URS Bit */
;;;2099       TIMx->CR1 |= CR1_URS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;2100     }
;;;2101     else
;;;2102     {
;;;2103       /* Reset the URS Bit */
;;;2104       TIMx->CR1 &= CR1_URS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fb          MOV      r3,#0x3fb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;2105     }
;;;2106   }
000016  4770              BX       lr
;;;2107   
                          ENDP

